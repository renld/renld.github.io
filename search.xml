<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Greedy & Violent]]></title>
      <url>http://renld.github.io/2016/07/22/greedy/</url>
      <content type="html"><![CDATA[<p>贪心可不是件简单事儿.</p>
<a id="more"></a>
<h1 id="有趣的贪心"><a href="#有趣的贪心" class="headerlink" title="有趣的贪心"></a>有趣的贪心</h1><h2 id="依据与思想"><a href="#依据与思想" class="headerlink" title="依据与思想"></a>依据与思想</h2><ol>
<li><p>贪心既然是一个方向的dp,往往<strong>相邻交换法</strong>可以得到优先级</p>
</li>
<li><p>真正不要脑洞的贪心还是很少的(比如例题11,UVA11520)</p>
<p>​</p>
<blockquote>
<p>贪心法是每步选择局部最优解，然后一步一步<strong>向目标迈进</strong>。这个“目标”两字很关键，说明贪心法是<strong>目标导向</strong>的，每一步的方向一定是目标。那么我上面两种方法其实只是在模仿那个经典问题的模式，但是却没有时刻注意到这个问题最终目标是实现从1到n每一位都能放上满足条件的车，比如第二个反例最后一个格最后都无法放车了，就是因为前面没有按照对最终目标的影响效果去选择局部最优解，单纯的选最左边一个是毫无道理的，因为本题已经不是那个经典的选最少点的问题了。(UVA11134题解摘录)</p>
</blockquote>
</li>
</ol>
<h2 id="热身训练"><a href="#热身训练" class="headerlink" title="热身训练"></a><a href="http://acm.hust.edu.cn/vjudge/contest/122013" target="_blank" rel="external">热身训练</a></h2><p>sort大法好==.</p>
<ol>
<li><p>HEllo World  (2 ^ ans &gt; n)</p>
</li>
<li><p><a href="http://www.codeforces.com/contest/699/problem/A" target="_blank" rel="external">CF363A</a>最小碰撞时间</p>
</li>
<li><p>Building designing sort两个指针扫</p>
</li>
<li><p>Ancient Cipher sort计数</p>
</li>
<li><p>DNA Consensus String 枚举</p>
</li>
<li><p>Big Chocolate 找规律==</p>
</li>
<li><p>All in All 两个指针扫</p>
</li>
<li><p>Children’s Game(UVA10905) 字符串最大==sort by a + b &gt; b + a</p>
</li>
<li><p>UVA11389 给出两个数组,使得搭配后所有超出S的值 超出部分和最小</p>
</li>
<li><p>例题1 <strong>UVA11292</strong> 勇者斗恶龙,两个指针往后扫</p>
<p>加上这两句话(if)才能过???</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n) sort(dg, dg + n);</span><br><span class="line"><span class="keyword">if</span>(m) sort(hero, hero + m);</span><br></pre></td></tr></table></figure>
<ul>
<li>进阶 LA3266 田忌赛马</li>
<li>(这个我CSDN博客有详细题解==</li>
<li>当初放弃ACM Steps题目..现在看来脸皮厚多了)</li>
</ul>
</li>
<li><p>UVA11100 (进阶)个数尽量少严格递增…等差(距)数列</p>
</li>
<li><p>LA4094(进阶) 梦之队 这道题网上题解分析很贪心hhh</p>
</li>
<li><p>LA4636(进阶) 给出主视图和左视图,求最小立体…(每次找max,相等加到ans,不相等舍弃大的那个)</p>
</li>
<li><p>LA3303 相邻交换法 a1b2 &lt; a2b1</p>
</li>
<li><p>LA2757 从后向前</p>
</li>
</ol>
<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="最早完成"><a href="#最早完成" class="headerlink" title="最早完成"></a>最早完成</h3><ol>
<li><p>例题2 <strong>UVA11729</strong> Bi时间交代任务,Ji时间完成. ==&gt; (交换法证明)完成时间长的先交代</p>
</li>
<li><p>例题10 <strong>UVA11384</strong> 用最少次数全部变成0 =&gt;&gt; <strong>保持平衡</strong> ,每次把大的一半减去(n/2)+1</p>
<blockquote>
<p>递归/二分(每次减大的数的一半)</p>
</blockquote>
</li>
</ol>
<h3 id="最少区间选择"><a href="#最少区间选择" class="headerlink" title="最少区间选择"></a>最少区间选择</h3><ol>
<li>UVA10382 sort by zuo when equal by you</li>
</ol>
<h3 id="最多区间选点"><a href="#最多区间选点" class="headerlink" title="最多区间选点"></a>最多区间选点</h3><ol>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/121165#problem/E" target="_blank" rel="external">UVA11134</a> 二维的..等价于两个一维,紫书P237</li>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/122663#problem/I" target="_blank" rel="external">Priest John’s Busiest Day</a> 至少出席区间一半时间 因为左右等价,sort by middle</li>
</ol>
<h3 id="最小惩罚"><a href="#最小惩罚" class="headerlink" title="最小惩罚"></a>最小惩罚</h3><ol>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/122663#problem/A" target="_blank" rel="external">LA4850</a> 求两个最大惩罚之和,end排序贪心扫一遍后,枚举</p>
<p>做法一: 枚举一个任务以及调动位置</p>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; struct seg</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     int f,e;</span><br><span class="line">&gt;     bool operator&lt;(const seg &amp; b)const&#123;</span><br><span class="line">&gt;         return e &lt; b.e;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;cs[500 + 5];</span><br><span class="line">&gt; /* in main</span><br><span class="line">&gt; sort(cs, cs + n);</span><br><span class="line">&gt; int ans = gao(-1,10000,n);</span><br><span class="line">&gt; for(int i = 0;i &lt; n;i++)//枚举一个任务调动</span><br><span class="line">&gt;   for(int j = 0;j &lt; n;j++)//枚举调动位置</span><br><span class="line">&gt;     ans = min(ans,gao(i,j,n));</span><br><span class="line">&gt; printf("%d\n", ans);</span><br><span class="line">&gt; */</span><br><span class="line">&gt; int gao(int cur,int to,int n)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     int sum = 0, cnt = 0;</span><br><span class="line">&gt;     int max1 = 0,max2 = 0;</span><br><span class="line">&gt;     for(int i = 0; i &lt;= n; i++)</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         if(cnt == to)</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             sum += cs[cur].f;</span><br><span class="line">&gt;             max2 = max(max2,sum - cs[cur].e);</span><br><span class="line">&gt;             if(max2 &gt; max1) swap(max2,max1);</span><br><span class="line">&gt;         &#125;//调动位置</span><br><span class="line">&gt;       </span><br><span class="line">&gt;         if(i != cur &amp;&amp; i &lt; n)</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             sum += cs[i].f;</span><br><span class="line">&gt;             max2 = max(max2,sum - cs[i].e);</span><br><span class="line">&gt;             if(max2 &gt; max1) swap(max1,max2);</span><br><span class="line">&gt;             cnt++;</span><br><span class="line">&gt;         &#125;//未调动位置</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     return max1 + max2;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>  <a href="http://blog.csdn.net/l123012013048/article/details/44000965" target="_blank" rel="external">剪枝</a></p>
<blockquote>
<p>牺牲的任务只能在两个最大惩罚值中的最后一个任务的前面，只有牺牲前面的任务才能使最大惩罚值的值减小，注意这里是牺牲，就表示有可能牺牲这个任务后，该任务的惩罚值变成了最大惩罚值的其中一个。</p>
</blockquote>
<p>   ​</p>
<p>  方法2 <a href="http://chieh.is-programmer.com/posts/79046.html" target="_blank" rel="external">二分套二分</a></p>
<h3 id="半边界"><a href="#半边界" class="headerlink" title="半边界"></a>半边界</h3><p>优先队列维护</p>
<ul>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/source/6513475" target="_blank" rel="external">LA3507</a> 知道DDL和花费,用优先队列维护最优值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  ans += af[i].q;</span><br><span class="line">  dd.push(af[i].q);</span><br><span class="line">  <span class="keyword">while</span> (ans &gt; af[i].d) &#123;</span><br><span class="line">    ans -= dd.top();</span><br><span class="line">    dd.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="路径最小"><a href="#路径最小" class="headerlink" title="路径最小"></a>路径最小</h2><ol>
<li><p>例题3 <strong>UVA11300</strong> 所有人转手金币之和最小</p>
<ol>
<li>(少一个方程的线性方程组=&gt;)单变量极值不等式</li>
<li><strong>数轴上一串点距离和,中位数是极小值点.</strong></li>
</ol>
</li>
<li><p>例题4 <strong>LA3708</strong> 加入m个雕塑到n个等距中,求最小移动距离</p>
<blockquote>
<ol>
<li>变换坐标系为len = 1;</li>
<li>tot最小,一定移动到最接近的位置</li>
<li>随机选一个坐标原点不动</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//坐标缩小后就可以更方便的选择</span></span><br><span class="line"><span class="keyword">double</span> pos = (<span class="keyword">double</span>)i / n * (n + m);<span class="comment">//原来雕像的位置</span></span><br><span class="line">ans += <span class="built_in">fabs</span>(pos - <span class="built_in">floor</span>(pos + <span class="number">0.5</span>))/(n + m);<span class="comment">//*n+m后就选四舍五入最近的</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="相对不变问题"><a href="#相对不变问题" class="headerlink" title="相对不变问题"></a>相对不变问题</h2><ol>
<li><p>例题5 <strong>UVA10881</strong> 蚂蚁爬.求每个蚂蚁最后的位置和方向</p>
<p><strong>每个蚂蚁的相对顺序不会改变</strong>=&gt;记录id,最后对应回去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(before, before + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  order[before[i].id] = i;</span><br><span class="line">&#125;<span class="comment">// 之后i := 0-&gt;n, a = order[i]就是从小到大的顺上去</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="树形贪心"><a href="#树形贪心" class="headerlink" title="树形贪心"></a>树形贪心</h2><ol>
<li><p>例题15 LA3902 </p>
<blockquote>
<p>每个叶节点不超过k有个站</p>
<p>求站的最小数</p>
<p>​</p>
<p>每次取<strong>最深的</strong></p>
<p>通过node表flood fill.</p>
<p>(node[dis]表示深度为dis的<strong>叶子</strong>))</p>
</blockquote>
<p>​</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) v = fa[v];<span class="comment">//第k级祖先</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e[u].size() == <span class="number">1</span> &amp;&amp; d &gt; k) node[d].push_back(u);<span class="comment">//node表构建</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.codeforces.com/contest/697/problem/C" target="_blank" rel="external">CF363c</a> 完全二叉树..每次找最近公共祖先还是很简单的==</p>
</li>
</ol>
<h2 id="左右互搏法"><a href="#左右互搏法" class="headerlink" title="左右互搏法"></a>左右互搏法</h2><ol>
<li>例题16 LA3177 </li>
</ol>
<p>围成一个圈每个人拿r[i]个礼物,相邻不相同</p>
<ol>
<li>n == 1,特殊情况总共r[1]个</li>
<li>​n % 2 == 0 =&gt; max(r[i] + r[i+1])个</li>
<li>n % 2 == 1 <ol>
<li>二分答案</li>
<li>以r[1]为界限循环一圈,(除了第一个)奇数尽量拿右边的,偶数尽量拿左边的,</li>
<li>(因为第一个和最后一个都是奇数位)看最后一个是否会拿左边的.</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a[<span class="number">1</span>], y = p - a[<span class="number">1</span>];<span class="comment">//bound</span></span><br><span class="line">    left[<span class="number">1</span>] = x,right[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right[i] = min(a[i],y - right[i<span class="number">-1</span>]);<span class="comment">//奇数尽量拿右边的</span></span><br><span class="line">            left[i] = a[i] - right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left[i] = min(a[i], x - left[i<span class="number">-1</span>]);<span class="comment">//偶数尽量拿左边的</span></span><br><span class="line">            right[i] = a[i] - left[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left[n] == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/source/6457753" target="_blank" rel="external">UVA11627(数据有毒)</a> 过障碍维护当前最左和最右</p>
</li>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/121165#problem/G" target="_blank" rel="external">LA4725</a> 两个飞机一个入口,问最小编码..维护当前飞机,ab能飞和tot能飞</p>
<p> 维护当前机场的飞机数目，机场可以供起飞的数目还有可以起飞的总数。</p>
<p> 超过数目后，判断可供起飞的数目是否为0就行了。</p>
<p>其实也就是因为a起飞数和b起飞数不是完全相干的</p>
<p>所以要多个变量定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> &amp;b,<span class="keyword">int</span> &amp;c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; c)</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;<span class="comment">//high cnt = m</span></span><br><span class="line">    <span class="keyword">int</span> ap = <span class="number">0</span>,bp = <span class="number">0</span>;<span class="comment">//当前飞机场数目</span></span><br><span class="line">    <span class="keyword">int</span> af = <span class="number">0</span>,bf = <span class="number">0</span>,tf = <span class="number">0</span>;<span class="comment">//a可以起飞数,b,总</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; m || b[i] &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ap += a[i];<span class="comment">//时间i降落</span></span><br><span class="line">        bp += b[i];</span><br><span class="line">        <span class="keyword">if</span>(ap &gt; m)<span class="comment">//之前起飞</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dec = min(ap - m, af,tf);</span><br><span class="line">            ap -= dec,af -= dec,tf -= dec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bp &gt; m) &#123;</span><br><span class="line">            <span class="keyword">int</span> dec = min(bp - m, bf,tf);</span><br><span class="line">            bp -= dec,bf -= dec,tf -= dec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ap &gt; m || bp &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(af &lt; ap) af++;<span class="comment">//主要是这个if限制了状态定义</span></span><br><span class="line">        <span class="keyword">if</span>(bf &lt; bp) bf++;</span><br><span class="line">        <span class="keyword">if</span>(tf &lt; ap + bp) tf++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/123289#problem/G" target="_blank" rel="external">LA3403</a> (紫书例题)天平难题…二进制枚举二叉树,记录左右最大值</p>
</li>
</ul>
<h2 id="滑动窗口-单调队列"><a href="#滑动窗口-单调队列" class="headerlink" title="滑动窗口/单调队列"></a>滑动窗口/单调队列</h2><ol>
<li><p>例题18 UVA11078 找Ai和Aj使得<code>Ai - Aj</code>尽量大</p>
<blockquote>
<p>维护小于j的最大i值 <code>MaxAi = max(Aj,MaxAi)</code></p>
</blockquote>
</li>
<li><p>例题21 <a href="http://acm.hust.edu.cn/vjudge/problem/source/6392140" target="_blank" rel="external">LA2678</a> 正整数序列,求最短子序列和&gt;S</p>
<ul>
<li>重点在于随后加一个<code>if (ans == maxn) ans = 0</code></li>
</ul>
<h4 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ptr1 = ptr2 = <span class="number">0</span>; ptr2 &lt; N; ptr2++) &#123;</span><br><span class="line">  sum += a[ptr2];<span class="comment">//每次后面的指针后移</span></span><br><span class="line">  <span class="keyword">while</span> (ptr1 &lt;= ptr2 &amp;&amp; sum - a[ptr1] &gt;= S)</span><br><span class="line">  &#123;</span><br><span class="line">    sum -= a[ptr1];</span><br><span class="line">    ptr1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sum &gt;= S)update(ans, ptr2 - ptr1 + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ptr1 = ptr2 = <span class="number">0</span>; ptr2 &lt; N; ) &#123;</span><br><span class="line">  <span class="keyword">while</span> (sum &lt; S &amp;&amp; ptr2 &lt; N ) &#123;</span><br><span class="line">    sum += a[ptr2];</span><br><span class="line">    ptr2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (sum &gt;= S &amp;&amp; ptr1 &lt; ptr2) &#123;</span><br><span class="line">    update(ans, ptr2 - ptr1);</span><br><span class="line">    sum -= a[ptr1];</span><br><span class="line">    ptr1++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="可怕的暴力"><a href="#可怕的暴力" class="headerlink" title="可怕的暴力"></a>可怕的暴力</h1><h2 id="三维问题"><a href="#三维问题" class="headerlink" title="三维问题"></a>三维问题</h2><ol>
<li><p>例题6 <strong>LA2995</strong> (最大立体)三维坐标系转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> &amp;z)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">0</span>) &#123; x = len; y = j; z = i; &#125; </span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; x = n - <span class="number">1</span> - j; y = len; z = i; &#125;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">2</span>) &#123; x = n - <span class="number">1</span> - len; y = n - <span class="number">1</span> - j; z = i; &#125;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">3</span>) &#123; x = j; y = n - <span class="number">1</span> - len; z = i; &#125;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">4</span>) &#123; x = n - <span class="number">1</span> - i; y = j; z = len; &#125;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">5</span>) &#123; x = i; y = j; z = n - <span class="number">1</span> - len; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*	给出六个面</span><br><span class="line">	k: 前 左 后 右 顶 底</span><br><span class="line">	i j 枚举位置</span><br><span class="line">	len是深入的长度</span><br><span class="line">	x y z从上往下看的坐标系</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例题8 <strong>LA3401</strong> 修改最少的面使得立方体相同</p>
<ol>
<li>写个小程序枚举”姿态”</li>
<li>枚举每个立方体每种姿态最少涂色数</li>
</ol>
</li>
</ol>
<h2 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h2><ol>
<li><p>例题7 UVA11464 <strong>01矩阵枚举第一行</strong></p>
</li>
<li><p>例题11 UVA10795 汉诺塔的扩展</p>
<blockquote>
<p>汉诺塔变形,给出始态终态,求移动步数</p>
<p>赋予中间态定义f(P,i,final)表示把1…i全部移动到final所需要的步数</p>
<p>ans = f(start,k-1,6-start[k]-finish[k]) + f(finish,k-1,6-start[k]-finish[k])+1</p>
<p>(k 是最大编号要移动的盘子)</p>
<p>f(P,i,final) = (P[i] == final) ? f(P , i-1, final): f(P,i-1,6-P[i]-final) + (1LL&lt;&lt;(i-1));</p>
</blockquote>
</li>
<li><p>例题17 计数排序</p>
</li>
<li><p>例题19 UVa11549 Floyd判圈法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a = k,b = k;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  a = next_num(a);</span><br><span class="line">  b = next_num(b); <span class="keyword">if</span>(b &gt; ans) ans = b;</span><br><span class="line">  b = next_num(b); <span class="keyword">if</span>(b &gt; ans) ans = b;</span><br><span class="line">&#125;<span class="keyword">while</span> (a != b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>例题24 <a href="http://acm.hust.edu.cn/vjudge/problem/source/6396193" target="_blank" rel="external">三维最大子空间</a></p>
</li>
</ol>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分模板= =</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(check(m)) l = m;</span><br><span class="line">  <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">l is answer</span><br><span class="line">  </span><br><span class="line"><span class="comment">//浮点数</span></span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">0.000001</span>) &#123;</span><br><span class="line">  <span class="keyword">double</span> m = (r + l )/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (check(m)) &#123;</span><br><span class="line">    l = m;</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">    r = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单调时最小位置</span></span><br><span class="line">i = lower_bound(a,a + n,val) - a;</span><br></pre></td></tr></table></figure>
<ol>
<li>例题12 最小品质因子最大值<strong>最小a值最大b</strong></li>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/source/6454756" target="_blank" rel="external">LA4254</a> 白书手写题解==</li>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/source/6527447" target="_blank" rel="external">LA4253</a> 返回值有意义的二分(判存在性,极角维护左右)  </li>
</ol>
<h3 id="二维降-扫描线"><a href="#二维降-扫描线" class="headerlink" title="二维降,扫描线"></a>二维降,扫描线</h3><ol>
<li><p>例题20 <a href="http://acm.hust.edu.cn/vjudge/problem/source/6391473" target="_blank" rel="external">LA3905</a> 流星最多的时间</p>
<blockquote>
<ol>
<li>扫描线计数法(碰到起点+1)</li>
<li>抽象为起点和终点,由于是直线,二维= 一维∩一维</li>
<li>整数计算</li>
</ol>
</blockquote>
</li>
<li><p>例题23 LA3695 找一个矩形边上包括尽量多的点</p>
<blockquote>
<p>求平行坐标轴的矩形边上最多点覆盖</p>
<p>扫描线,对所有点依据x排序,对所有y排序,unique</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; m; a++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> b = a + <span class="number">1</span>; b &lt; m; b++) &#123;</span><br><span class="line">    <span class="keyword">int</span> low = y[a], high = y[b];<span class="comment">//枚举平行于x轴的两条边</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,M = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//扫描平行于y轴的边</span></span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span> || p[i].x != p[i<span class="number">-1</span>].x) &#123;</span><br><span class="line">        k++;<span class="comment">//统计x坐标个数</span></span><br><span class="line">        on[k] = on2[k] = <span class="number">0</span>;</span><br><span class="line">        left[k] = k == <span class="number">0</span> ? <span class="number">0</span> : on2[k<span class="number">-1</span>] - on[k<span class="number">-1</span>] + left[k<span class="number">-1</span>];<span class="comment">//y = low (+) high 上已经有多少点</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p[i].y &gt; low &amp;&amp; p[i].y &lt; high) on[k]++;<span class="comment">//左记录线记录low,high之间的边(不含端点)</span></span><br><span class="line">      <span class="keyword">if</span>(p[i].y &gt;= low &amp;&amp; p[i].y &lt;= high) on2[k]++;<span class="comment">//右记录线记录low,high之间的边(含端点)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;<span class="comment">//总共只有两个坐标(这里不用再对x排序- -)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      ans = max(ans,on2[j] + M + left[j]);<span class="comment">//ans = max(on2[j] + on2[j-1] + left[j] - left[j-1])</span></span><br><span class="line">      M = max(M,on[j] - left[j]);<span class="comment">//维护on[i] - left[j]的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h3><ol>
<li><p>例题22 <a href="http://acm.hust.edu.cn/vjudge/problem/source/6392400" target="_blank" rel="external">LA3029</a> 最大子矩阵.</p>
<blockquote>
<p><strong>把每个格子向上延伸的连续空格看成一条悬线</strong></p>
<p>有障碍物的区域中的最大子矩阵</p>
<p>(USACO用一个height数组过的(USACO6.1))</p>
<p>训练指南是维护up,l,r三个数组,l,r标记以up为高度的矩形最左和最右的位置</p>
</blockquote>
</li>
</ol>
<h3 id="01-GUY"><a href="#01-GUY" class="headerlink" title="01 GUY"></a>01 GUY</h3><ol>
<li><p>例题25 <a href="http://acm.hust.edu.cn/vjudge/problem/source/6403147" target="_blank" rel="external">LA2965</a> 尽量多的串使得大写字母都出现偶数次</p>
<ul>
<li>=&gt;用二进制位表示字母</li>
</ul>
</li>
</ol>
<ul>
<li>=&gt;xor == 0</li>
</ul>
<ul>
<li>=&gt;枚举前一半,而后枚举后一半<strong>中途相遇</strong></li>
</ul>
<h2 id="码农题"><a href="#码农题" class="headerlink" title="码农题"></a>码农题</h2><ol>
<li><p>例题9 <strong>UVA11210</strong> 麻将(判断”听牌”)</p>
</li>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/122663#problem/H" target="_blank" rel="external">Ugly Windows</a> 代码量不大但是有坑</p>
</li>
<li><p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1668" target="_blank" rel="external">LA3667</a> 最少刻度 二进制bfs扩展<a href="http://winterfell30.com/2015/11/21/hdoj3667/" target="_blank" rel="external">参考</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cur.found &amp; (<span class="number">1</span>&lt;&lt;i)) <span class="keyword">continue</span>;<span class="comment">//当前存在</span></span><br><span class="line">  <span class="keyword">int</span> v = *iter + arr[i];<span class="comment">//扩展节点</span></span><br><span class="line">  <span class="keyword">if</span>(cur.st.find(v) != cur.st.end()) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">if</span>(v &gt; MAX) <span class="keyword">continue</span>;</span><br><span class="line">  next = cur;</span><br><span class="line">  next.st.insert(v);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter2 = cur.st.begin();<span class="comment">//进一步扩展</span></span><br><span class="line">       iter2 != cur.st.end(); iter2++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">abs</span>(v - *iter2);</span><br><span class="line">    <span class="keyword">if</span> (idx[x] != <span class="number">-1</span>) &#123;</span><br><span class="line">      next.found |= (<span class="number">1</span>&lt;&lt;idx[x]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (next.found != cur.found) &#123;</span><br><span class="line">    q.push(next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/123289#problem/E" target="_blank" rel="external">UVA10825</a> 乘2..m后所有位数字还是那些…..枚举最后一位生成所有位数</p>
</li>
<li><p><a href="http://acm.hust.edu.cn/vjudge/contest/123289#problem/I" target="_blank" rel="external">LA3621</a> 最少几次乘除得到${X}^{n}$.迭代加深搜索+剪枝</p>
</li>
</ol>
<h2 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h2><ol>
<li><p>writein &amp; readin</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">readint</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">  	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">  		x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">      	c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">10</span>];<span class="comment">//global varible</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeint</span><span class="params">(<span class="keyword">int</span> i)</span></span><br><span class="line"></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">0</span>)p++;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">while</span>(i)</span><br><span class="line">  &#123;</span><br><span class="line">    buf[p++] = i % <span class="number">10</span>;</span><br><span class="line">    i /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = p - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--) <span class="built_in">putchar</span>(<span class="string">'0'</span> + j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol>
<li><p>例题及习题指 &lt;&lt;算法竞赛入门经典(训练指南)&gt;&gt;对应例题</p>
</li>
<li><p>私在vjudge中开题集(因为uva墙外服务器是在是慢啊…)</p>
<ul>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/122013#overview" target="_blank" rel="external">1-1</a></li>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/121165" target="_blank" rel="external">1-2-1</a></li>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/122663#overview" target="_blank" rel="external">1-2-2</a></li>
<li><a href="http://acm.hust.edu.cn/vjudge/contest/123289#overview" target="_blank" rel="external">1-3</a></li>
</ul>
</li>
<li><p>求LA5704 Yummy Triangular Pizza传统题解,<a href="oeis.org/A006534">oeis</a>是个好地方</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BYE Freshman]]></title>
      <url>http://renld.github.io/2016/07/09/byefresh/</url>
      <content type="html"><![CDATA[<p>据说珠海最好的景点.是澳门.</p>
<a id="more"></a>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/bike.jpg" alt=""></p>
<p>于是在离开中珠的前一天,与两位同样留有签注的少年同行.</p>
<p>一脸懵逼的自助游还是挺新奇与快乐的.第一次体会到资本主义的奢靡社会(并不..刚刚在高铁站的物价明明比澳门还贵…)坐了很久很久的K3到了拱北口岸.去KFC扒了两口汉堡换了一些葡币便过关了..异常地平静安和的刷了两次卡就过了..</p>
<p>真的走着出境的感觉.还是挺奇妙的.但是..还是没有什么异样…</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/img.jpg" alt=""></p>
<p>资本主义的天并没有想象中的不一样..倒是珠海会更多几分白云.没有遇见诗壕的豪华游艇倒是一进去就被发了两张卡.恩..三个人发了两张,我一脸莫名的去要了一张发现是新葡京…于是大概就默认是那位女士觉得我太真诚单纯善良了(微笑脸:)</p>
<p>随步到公交站后随意选了一个似曾相识(也就是前一天百度的..)地名,做了好久好久的车,莫名来到了氹仔=.=填海造路的场景还是挺有意思的.寸土寸金四个字被潇航说出莫名的耳熟.不过话说回到这个围湖造田的地域他们会不会有些惊奇.</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/road.jpg" alt=""></p>
<p>正当我们觉得或许坐错车/坐过站的时候.似乎到了那个似曾相识的地名(官街?)</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/foods.jpg" alt=""></p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/liulian.jpg" alt=""></p>
<p>下去后发现居然是一条小吃街.顿时两眼发光去点了一个猪扒包-.菠萝包皮配上猪扒的感觉回味到现在都很奇妙.只可惜当时一时错过了猫山王雪糕的宣传.真的架势做的很大.而后混了进去找了一家纪念品店大家又兴奋起来.凯丹给女友送去一张明信片,我和潇航各自买了一个筹码做个留恋(其实觉得纪念品这种东西似乎送人就少了几分纪念意义?)</p>
<p>散步去某个葡萄牙博物馆后又走了一圈.发现澳门这个神奇的地方居然几乎只有单行道相通,所有公交车也都是环线而行.(为什么我对右侧驾驶又毫无新奇感..或许反正是环线吧…)绕了一些路太阳实在太大于是便找个位置歇息准备去大三巴签个到.</p>
<p>路上碰到一个好心的爷爷努力用国语告诉我们在哪下车.但其实当我们看到新葡京的真相后便也大抵知晓我们回到了景区.旁边几个必胜典当行欢迎着rmb消费,金光闪闪的外表下,这就是当时和同桌说的”我才不会去当兵,我还想享受一点资本主义的奢靡生活”?</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/newpj.jpg" alt=""></p>
<p>或许这只是表面的绚烂,还没感受到内在的浮华吧.</p>
<p>到了牌坊后又是一脸无感的拍照纪念.唯一有(新)趣(奇)一些的或许是旁边有某著名教派的宣传摊位.</p>
<p>不过牌坊旁边便是澳门博物馆了.这大概是这场旅行最惊艳的地方了,8mop的学生票简直告诉了我博物馆的奇妙世界.几乎每一个展品都有互动步骤,入门处的四大发明让人忍不住留影.教课书实在太过枯燥与乏味,当真正与活字印刷机相邻之后,简直被古人的智慧震撼.</p>
<p>博物馆中努力还原澳门的历史,许多的小人小像栩栩如生.特别有趣的是一排留声空间留下了当年卖货郎的叫卖声,吆喝语气.动人而又客人.平常一日的浏览居然一次一次地被带来惊喜,这大概是那儿最美的东西吧.</p>
<p>外面烈日,内部空调,摆设不经意间简直华丽到像天堂.这或许是第一个我想再来一次的博物馆吧.</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/food.jpg" alt=""></p>
<p>好吃的?!</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/guojixiangqi.jpg" alt=""></p>
<p>真的国际象棋</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/jiaozi.jpg" alt=""></p>
<p>好漂亮的花轿.</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/macow/money.jpg" alt=""></p>
<p>money</p>
<p>出去后拜见了牌坊后的墓地.门口记录着天主教的殉教着,推开门后,第一次被天主教的圣洁和肃穆震撼,内心似乎多了一些感受,又似乎无法表达出来那份震惊和内心发出的敬意吧.或许这是与牌坊门口那某著名教派所相异相差的地方.</p>
<p>慕名去马嘉烈花光了最后几十mop,很香的蛋挞,同行的男生十分喜欢.可我或许曾在培楠宿舍蹭过一个,也没有那么惊艳.可惜对面银联不能取钱,而名气太大的店子居然拒收RMB..想给预约了这种手信的同学花了很大心力找了几个人才把身上最后20rmb换成了20mop带了两个回去.</p>
<p>澳门此行不知道也没有遗憾.不过被一些东西惊艳后便算是满足和感动了.见识了一处新的风景大概也能理解别人周游世界的理想了.看到这个世界中很多新奇而有趣的东西,作为人生的向往,或许也不错吧.</p>
<p>之后便是吃饱喝足元气满满的准备回迁了.完全没想到居然有那么多的物资.五点折腾到八点半后洗了个澡便四肢发软的躺倒床上.到了饭点后与宿舍在东北人家聚了个餐,也算了在中珠外四大食堂签了一遍到了.麻婆豆腐味道很不错.就像珠海这边的川菜很棒一般.(尽管四川/重庆同学并不这么认为).</p>
<p>岐关车外迎着保安的敬礼也算是告别中珠了.去年当时也大概是这几天知道被移动录取.然后发现是一个神奇的四年珠海学院.不过更神奇的是.发现中山大学居然有个珠海校区…不过算是邂逅也算是意外地感受了这里的蓝天白云和面朝大海后的春暖花开.秋天的中珠的云美如画,而夏日的滚滚浓云便印证着孙逸仙魔法学校的名号.清空烈日的常态下,雨珠在大树垂须下的晶莹令人称奇.第一次感受春风十里的舒适也是第一次感受到蓝天白云的纯净.大概就像微信地图中给它的定义—景点.</p>
<p>当了一年的freshman似乎也就第一个学期特别拼,而看到努力学习和绩点并不成正比后第二个学期便开始努力调整习惯开始适当地去体验和感受生活.(似乎变成了半条咸鱼?)不再日出而作全心投入的结果当然不是更加优秀的绩点(刚刚出了两门公选后均绩成功掉下了4..却似乎没有太多莫名的忧伤),反而觉得又像高三一样,更加追求的是有趣的生活,和舍友的关系也日渐亲密起来.没加社团或许是个遗憾,但是通过ACM的打拼认识了很多很优秀的少年少女,也算是心满意足.</p>
<p>和别人聊天时发现自己再过一个月也成了学长.或许要努力把自己变得更加成熟和强大一点才能胜任吧.也可以借此机会好好玩一下羊城的风光,东校寒假的伙食配置简直对它充满的向往和期望.暑假拉开了真正的序幕,努力把自己打造成一个更强大的人吧.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Primary Engineering Practice]]></title>
      <url>http://renld.github.io/2016/07/04/egt1/</url>
      <content type="html"><![CDATA[<p>engerineering time</p>
<a id="more"></a>
<h1 id="Finding"><a href="#Finding" class="headerlink" title="Finding"></a>Finding</h1><blockquote>
<p>十多天了谢谢两条大腿带飞😭</p>
<p>每天都可以准时吃饭非常爽</p>
<p>hhhh虽然每天也是花式懵逼地坐在一边有点惭愧</p>
<p><em>(:з」∠)</em>总之非常开心的（😘</p>
</blockquote>
<p>很有意思的课程,怪不得那么多人怀念小学期.</p>
<h2 id="disappear"><a href="#disappear" class="headerlink" title="disappear"></a>disappear</h2><p>实训最开始三天去参加4+2了,把两个队友抛在珠海焊电路板感觉还是有一些愧疚.4+2被淘汰那天看到电路板真是那天唯一的欣慰与感动.有点可惜错过了这份雕琢的经历.不过这张照片还是在那天朋友圈刷屏中特别醒目.</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/board.jpg" alt=""></p>
<h2 id="learn-C"><a href="#learn-C" class="headerlink" title="learn C"></a>learn C</h2><p>不过4+2回来后,对于位运算有莫名的信心.所以在回来前几天发现都是在水一些C语言的知识后..觉得实训怎么这么水啊…..每天都能早早的水完task然后就快乐的离场吃饭…</p>
<p>那两三天真的过得挺轻松的…每天讲一点大一最开始自学的C语言…然后就水几个task.</p>
<p>然后发现俊爷在快乐的刷进度0.0舍友对他也赞美有嘉233</p>
<p>不过真的水到好无聊..于是就开始大冒险…</p>
<p>有一次debugTASK看了两个后直接把文杰喊了过来验收..</p>
<p>然后水到倒数第二个时候发现..居然是一道写代码题.</p>
<p>然后文杰留下了一句评价</p>
<p><strong>空手套白狼</strong></p>
<h2 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h2><p>整个实训中最恐怖的传说便是烧掉一块FPGA板子了</p>
<p>因为淘宝价1200…简直精贵了整个实验的配置..</p>
<p>每一天都有烧板子的消息传来…没想到有一天终于轮到了我们组..</p>
<p>调试了一个下午后发现小车有毒…居然不能脱离USB线</p>
<p>把问题归罪到H桥后去找老师更换H桥…</p>
<p>过了十分钟队长还没回来..去看一眼得知板子坏了…</p>
<p>那个心情还是挺忐忑的..</p>
<p>那个TA顺便恐吓了我们一人200的要求= =</p>
<p>然后似乎那次验收顺便收货了一个B…</p>
<p>(字居然写的这么丑了-.-)</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/0705.jpg" alt=""></p>
<p>最后一天整整一个上午…都ELF过去..问文杰= =我们又被”恐吓”恭喜中奖了…</p>
<p>中午得知换了台电脑可以烧了..兴奋地不会宿舍洗澡睡觉直接滚去实验室干活了233</p>
<h2 id="Teachers"><a href="#Teachers" class="headerlink" title="Teachers"></a>Teachers</h2><p>移动的TA果然超级赞..发现他们不在电工群后就去私加了一个TA的QQ..想要问要不要带板子和小车来上课..结果那天TA8:50回了我一句不要= =/////</p>
<p>见识了文杰师兄的卖萌.简直有趣到可怕..居然把我的语气语调带的有点标普了..然而文杰似乎也是fu南的??!!每次都被莫名喊成”大腿”立得一手好flag..于是守候到了实验室关门的晚霞0.0可惜文杰居然不要我爆照..真的好萌XD</p>
<p>huangkai老师的慕尼黑工业大学的团队0….0据说高薪聘请过来的..似乎让我在雅礼的招生群装了一个逼…另外上课似乎觉得我们大一还是通识教育..鼓励我们创新精神?几次样例代码都有一些小bug..什么Switch大写了首字母..接口多了一个参数!!?….估计就是防止我们copy&amp;paste的小tirck吧..</p>
<p>不过说实话..被坑(水)久了之后..还是觉得TA讲课会切中要害一些.</p>
<p>另外外教这种生物..在我出国梦暗淡之后…就成了我自习的一个借口了2333</p>
<h2 id="else1"><a href="#else1" class="headerlink" title="else1"></a>else1</h2><p>这几天每一天晚上都好悠闲啊2333..</p>
<p>终于享受到了一年级学生应有的愉悦</p>
<p>水完了一本\<html游戏开发秘笈>…</html游戏开发秘笈></p>
<p>不知道谁安利的书…</p>
<p>一章学一个引擎简直可怕..</p>
<p>然后美化博客debug很久..换了个域名2333</p>
<p>…于是每次我都是朋友圈错乱感的制造者</p>
<h2 id="else2"><a href="#else2" class="headerlink" title="else2"></a>else2</h2><p>这次实训两个室友都当上了他们组的大腿2333</p>
<p>每天回宿舍给我各种秀-.-</p>
<p>似乎看到他们下个学期冉冉升起的学霸希望</p>
<p>而且我们宿舍崛起的绩点23333</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/sr.jpg" alt=""></p>
<p>最后有一点想提的是..这几天伙食也是经历了由万象纷呈到过零丁洋再到普通中珠伙食的经历.给大家一点希望吧..中珠太美..但是暑假还是东校伙食美(每次逛食堂都能快乐地..抓一盘菜233)</p>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/food.jpg" alt=""></p>
<div class="owl-media owl-video owl-youku"><iframe src="http://player.youku.com/embed/XMTY0MDc5NTY1Mg" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe></div>
<blockquote>
<p>面向硬件的编程主要是对于宏文件的套用</p>
<p>说白了,就是学会用模板.</p>
<p>很不幸的是苦于找模板.忘模板…这样就还是很尴尬.</p>
<p>–原文抬头</p>
</blockquote>
<h1 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h1><ol>
<li>加载C盘<a href="[http://radar-10050281.file.myqcloud.com/drivers.rar](http://radar-10050281.cos.myqcloud.com/drivers.rar">驱动</a>)</li>
<li><code>Quartus</code>载入单片机,载入<a href="http://radar-10050281.file.myqcloud.com/NOISCar.rar" target="_blank" rel="external">sof文件</a></li>
<li>打开eclipse,创建工程,载入<code>NIOS_Sys.sopcinfo</code>(也在上面那个链接中)</li>
<li>eclipse编译的时候<strong>需要</strong>忽略两个选项.</li>
<li><a href="http://radar-10050281.file.myqcloud.com/DE0_Nano_User_Manual_v1.9.pdf" target="_blank" rel="external">FPGA文档</a></li>
</ol>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//standard C library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> <span class="comment">//like int16_t;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"io.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"system.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"altera_avalon_pio_regs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;altera_avalon_performance_counter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//what?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"sys/alt_irq.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"adc_spi_read.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"terasic_includes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"alt_types.h"</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"terasic_includes.h"</span></span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt; // malloc, free</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;  // usleep (unix standard?)</span><br><span class="line">#include &lt;io.h&gt;</span><br><span class="line">#include "sys/alt_flash.h"</span><br><span class="line">#include "sys/alt_flash_types.h"</span><br><span class="line">#include "alt_types.h"  // alt_u32</span><br><span class="line">#include "altera_avalon_pio_regs.h" //IOWR_ALTERA_AVALON_PIO_DATA</span><br><span class="line">#include "sys/alt_irq.h"  // interrupt</span><br><span class="line">#include "sys/alt_alarm.h" // time tick function (alt_nticks(), alt_ticks_per_second())</span><br><span class="line">#include "sys/alt_timestamp.h" </span><br><span class="line">#include "sys/alt_stdio.h"</span><br><span class="line">#include "system.h"</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include "terasic_debug.h"</span><br><span class="line">typedef int bool;</span><br><span class="line">#define TRUE    1</span><br><span class="line">#define FALSE   0</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"alt_types.h"</span></span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">typedef signed char  alt_8;</span><br><span class="line">typedef unsigned char  alt_u8;</span><br><span class="line">typedef signed short alt_16;</span><br><span class="line">typedef unsigned short alt_u16;</span><br><span class="line">typedef signed long alt_32;</span><br><span class="line">typedef unsigned long alt_u32;</span><br><span class="line">typedef long long alt_64;</span><br><span class="line">typedef unsigned long long alt_u64;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="基本IO"><a href="#基本IO" class="headerlink" title="基本IO"></a>基本IO</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本亮灯方式</span></span><br><span class="line">IOWR(LED_BASE,<span class="number">0</span>,<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//机器key按压状态</span></span><br><span class="line">KEY_BASE</span><br><span class="line">  </span><br><span class="line"><span class="comment">// write register</span></span><br><span class="line">IOWR(LED_BASE,<span class="number">0</span>,led);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;<span class="comment">//按照输出数的二进制位亮灯</span></span><br><span class="line">IOWR_ALTERA_AVALON_PIO_DATA( PIO_LED_BASE, value );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// read register, 普通情况下是3 if(val ^ 3)说明被按键,自动带有防抖</span></span><br><span class="line"><span class="keyword">int</span> value = IORD_ALTERA_AVALON_PIO_DATA( PIO_LED_BASE );</span><br></pre></td></tr></table></figure>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断就是在程序任意阶段突然发生的一个函数</p>
<p>清空中断标记之后还原.</p>
<blockquote>
<p> Initialization</p>
<p> Enable the interrupt for the specific input    </p>
<p>IOWR_ALTERA_AVALON_PIO_IRQ_MASK(<base>, <mask>);</mask></p>
<p> Set the edge capability </p>
<p>IOWR_ALTERA_AVALON_PIO_EDGE_CAP(<base>, <val>)</val></p>
<p> Register handler </p>
<p>alt_ic_isr_regsiter( <irq_controller_id>, <irq>,<isr_function>, <isr_context>, <flags> )</flags></isr_context></isr_function></irq></irq_controller_id></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">char</span> key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nirq_isr_context;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得在main中initial</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得声明在前面...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">//todo: set up interrupt function</span></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,<span class="number">3</span>);<span class="comment">//3 = 1 | 2,表示1和2输入时都有反应</span></span><br><span class="line"></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);<span class="comment">//这句话是清空中断状态</span></span><br><span class="line"></span><br><span class="line">    alt_ic_isr_register( <span class="number">0</span>, <span class="number">1</span>,isr_function, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">//声明中断函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计时模块"><a href="#计时模块" class="headerlink" title="计时模块"></a>计时模块</h1><p>usleep(264762)大概是一秒.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//开始计时器 </span></span><br><span class="line">    	PERF_RESET(PERFORMANCE_COUNTER_BASE);</span><br><span class="line">      	PERF_START_MEASURING(PERFORMANCE_COUNTER_BASE);</span><br><span class="line">     	PERF_BEGIN(PERFORMANCE_COUNTER_BASE,<span class="number">1</span>);<span class="comment">//1在这里是个标示，标示1号位的计数 重复计数会累加，</span></span><br><span class="line">	</span><br><span class="line">   <span class="comment">/*</span><br><span class="line">   		想要测试间的函数部分 ，每一个测试时间块设置一个函数出去，比如这里测的print函数</span><br><span class="line">   </span><br><span class="line">   	  	当然不写函数也是可以的,可以把下面的"printf"改成"for"便可以测试for循环的时间</span><br><span class="line">   </span><br><span class="line">   	  	所以我认为是在第一个BEGIN和END之间找到一个关键字(如果把下面的2改成1,它会记成上面的时间)</span><br><span class="line">   */</span></span><br><span class="line">   </span><br><span class="line">	PERF_END(PERFORMANCE_COUNTER_BASE,<span class="number">1</span>);<span class="comment">//结束时间计数，对应上面1的标志 </span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    PERF_BEGIN(PERFORMANCE_COUNTER_BASE,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//usleep(1000);//这个是一个sleep封装，下面的for循环暴力模拟 </span></span><br><span class="line">    <span class="comment">//for(i = 0;i &lt; 200000 ;i++); 如果要测试usleep时间的话那么就得写在第2个 计时区域里面 </span></span><br><span class="line">    PERF_END(PERFORMANCE_COUNTER_BASE,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//最后一个标志stop </span></span><br><span class="line">    PERF_STOP_MEASURING(PERFORMANCE_COUNTER_BASE);</span><br><span class="line">    <span class="comment">//按照它的模板输出时间 </span></span><br><span class="line">    perf_print_formatted_report(PERFORMANCE_COUNTER_BASE,alt_get_cpu_freq(),</span><br><span class="line">  					<span class="number">2</span>,<span class="string">"printf"</span>,<span class="string">"usleep"</span>,<span class="string">"IOWR"</span>);<span class="comment">//第一个是输出时间的种类，后面的是要求测试的函数 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("Product of entered matrices: %d \n",*timer);</span></span><br></pre></td></tr></table></figure>
<h2 id="perf-get-total-time"><a href="#perf-get-total-time" class="headerlink" title="perf_get_total_time"></a>perf_get_total_time</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alt_u64 <span class="title">perf_get_total_time</span>   <span class="params">(<span class="keyword">void</span>* hw_base_address)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> perf_get_section_time (hw_base_address, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="subTask-Volatilevariables"><a href="#subTask-Volatilevariables" class="headerlink" title="subTask Volatilevariables"></a>subTask Volatilevariables</h2><p>这个实在eclipse里面把编译选项级别改高(level2)后,很多变量被”优化”到不能修改的尴尬地步.</p>
<h2 id="subTask-存储位置"><a href="#subTask-存储位置" class="headerlink" title="subTask 存储位置"></a>subTask 存储位置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同存储位置声明 ,onclip是会快一些的.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_ONCHIP_MEMORY</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> USE_ONCHIP_MEMORY</span></span><br><span class="line">  <span class="keyword">int</span> first[<span class="number">10</span>][<span class="number">10</span>] __attribute__ (( section ( <span class="string">".onchip_memory2_0"</span> )));</span><br><span class="line">  <span class="keyword">int</span> second[<span class="number">10</span>][<span class="number">10</span>] __attribute__ (( section ( <span class="string">".onchip_memory2_0"</span> )));</span><br><span class="line">  <span class="keyword">int</span> multiply[<span class="number">10</span>][<span class="number">10</span>] __attribute__ (( section ( <span class="string">".onchip_memory2_0"</span> )));</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> first[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> second[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> multiply[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="读入电压"><a href="#读入电压" class="headerlink" title="读入电压"></a>读入电压</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START_FLAG  0x8000 <span class="comment">//标记已经测量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DONE_FLAG   0x8000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> adc_channel = <span class="number">2</span>;<span class="comment">//输入信号端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">char</span> key = <span class="number">0</span>;<span class="comment">//按键(中断)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;<span class="comment">//成功读取电压值</span></span><br><span class="line"><span class="keyword">int</span> spi_response; <span class="comment">// 读取电压值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nirq_isr_context;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得在main中initial</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得声明在前面...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">//todo: set up interrupt function</span></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,<span class="number">3</span>);<span class="comment">//3 = 1 | 2,表示1和2输入时都有反应</span></span><br><span class="line"></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);<span class="comment">//这句话是清空中断状态</span></span><br><span class="line"></span><br><span class="line">    alt_ic_isr_register( <span class="number">0</span>, <span class="number">1</span>,isr_function, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">//声明中断函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  	<span class="comment">//set the desired channel by writingit to the SPI bus.绑定?(terry)</span></span><br><span class="line">	IOWR(ADC_SPI_READ_BASE,<span class="number">0</span>,adc_channel);<span class="comment">//初始接口信号,必须每次中断初始化,取消START_FLAG</span></span><br><span class="line">  	<span class="comment">// start the converstion by writingthe START_FLAG to the SPI bus.(terry)</span></span><br><span class="line">	IOWR(ADC_SPI_READ_BASE,<span class="number">0</span>,adc_channel | START_FLAG);<span class="comment">//写入当前接口信号</span></span><br><span class="line">  </span><br><span class="line">  	done=<span class="number">0</span>;<span class="comment">//done去掉也可以实现任务.</span></span><br><span class="line">	<span class="keyword">while</span>(!done)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//只有最高位为1才代表SPI从ADC读取完成。(terry)</span></span><br><span class="line">		spi_response = IORD(ADC_SPI_READ_BASE,<span class="number">0</span>); 	<span class="comment">//读出当前借口信号</span></span><br><span class="line">		done = (spi_response &amp; DONE_FLAG); 			<span class="comment">//如果读出成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> adc_value = spi_response &amp; <span class="number">0xFFF</span>;		<span class="comment">//取有效位电压值</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"voltage = %d\n"</span>, adc_value);</span><br><span class="line">  	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	nIRQ_Initial();<span class="comment">//中断初始化</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//中断触发,输出ADC值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"done = %d\n"</span>,done);			<span class="comment">//检查时DONE_FLAG</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SUBTASK-测量实际电压数值"><a href="#SUBTASK-测量实际电压数值" class="headerlink" title="SUBTASK 测量实际电压数值"></a>SUBTASK 测量实际电压数值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增设这个函数的目的是为了去噪.(平均值采样分析)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	IOWR(ADC_SPI_READ_BASE,<span class="number">0</span>,adc_channel);<span class="comment">//初始接口信号</span></span><br><span class="line">	done=<span class="number">0</span>;</span><br><span class="line">	IOWR(ADC_SPI_READ_BASE,<span class="number">0</span>,adc_channel | START_FLAG);<span class="comment">//写入当前接口信号</span></span><br><span class="line">	<span class="keyword">while</span>(!done)</span><br><span class="line">	&#123;</span><br><span class="line">		spi_response = IORD(ADC_SPI_READ_BASE,<span class="number">0</span>); 	<span class="comment">//读出当前借口信号</span></span><br><span class="line">	done = (spi_response &amp; DONE_FLAG); 	<span class="comment">//如果读出成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> adc_value = spi_response &amp; <span class="number">0xFFF</span>;	<span class="comment">//取有效位电压值</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"voltage = %lfV\n"</span>, <span class="number">3.3</span>*adc_value/<span class="number">4096</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.3</span>*adc_value/<span class="number">4096</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来自terry博客对于信号处理的一段解释,我觉得很有意思</p>
<blockquote>
<p>ADC 将模拟型号转换成数字信号，通常地，</p>
<p>假如传感器测量范围是 <code>0V－3.3V</code>，ADC 是 <code>12bit</code>，</p>
<p><code>0V</code> 时是 <code>0000 0000 0000</code>，<code>3.3V</code> 时是 <code>1111 1111 1111</code>。</p>
<p>由于转换是线性的所以 <code>voltage = adc_value * 3.3 / 4096</code>。(<code>2^12 = 4096</code>)</p>
</blockquote>
<p><img src="http://i1.piimg.com/567571/23c51ba0a9247f6a.png" alt=""></p>
<p>这样之后mask也很好理解了</p>
<p>真正有意义的位是后面三个十六进制位(也就是后面12位01位)</p>
<p>那么mask = 0x8000 = 1000 0000 0000 0000 是首位掩码标记.</p>
<p><code>adc_channel | START_FLAG</code> 其实就是一个绑定,但是加上了一个mask(正常电压范围达不到mask)</p>
<p><code>spi_response &amp; DONE_FLAG</code>是在探测mask位是否有值,也就是检查<code>start_flag</code></p>
<p><code>spi_response &amp; 0xFFF</code> 取出来的时候需要提取有效部分,也就是后面12位.</p>
<p><strong>举个例子</strong>(由于md样式<code>|</code>表示成or):</p>
<table>
<thead>
<tr>
<th>-变量名/表达式</th>
<th>-对应二进制数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>adc_channel = 2</td>
<td>0000 0000 0000 0010</td>
</tr>
<tr>
<td>adc_channel or START_FLAG</td>
<td>1000 0000 0000 0010</td>
</tr>
<tr>
<td>spi_response = 1000 0011 1111 1111</td>
<td>1000 0011 1111 1111</td>
</tr>
<tr>
<td>spi_response &amp; DONE_FLAG</td>
<td>1000 0000 0000 0000</td>
</tr>
<tr>
<td>spi_response &amp; 0xFFF</td>
<td>0000 0011 1111 1111</td>
</tr>
<tr>
<td>START_FLAG<code>和</code>DONE_FLAG</td>
<td>1000 0000 0000 0000</td>
</tr>
</tbody>
</table>
<h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><p>PWM就是用数字信号的比率实现模拟信号的高低</p>
<h2 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * main.c</span><br><span class="line"> *</span><br><span class="line"> *  Created on: 07.11.2012</span><br><span class="line"> *      Author: karl_ee</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	 <span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;</span><br><span class="line">	 <span class="keyword">unsigned</span> <span class="keyword">long</span> phase1=<span class="number">0x0</span>,phase2=<span class="number">0x000</span><span class="comment">//分别是任务一和任务二的初始相位</span></span><br><span class="line">       				,duty1=<span class="number">0x1388</span>,duty2=<span class="number">0x1388</span><span class="comment">//分别是任务一输出和任务二输出占空比</span></span><br><span class="line">                  	,period=<span class="number">0x186A</span><span class="comment">//前面的相位和占空比需要与这个period作比</span></span><br><span class="line">                    ,enable=<span class="number">0x1</span>;<span class="comment">//0x3才能输出两个信号</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		 motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2550</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">2550</span>;j++);<span class="comment">//delay</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * motor_setting.c</span><br><span class="line"> *</span><br><span class="line"> *  Created on: 07.11.2012</span><br><span class="line"> *      Author: karl_ee</span><br><span class="line"> *          input parameters:</span><br><span class="line"> *      	phase: range from 0 to value of period</span><br><span class="line"> *     		duty cycle: set to number=period*percentage of duty cycle</span><br><span class="line"> *      	period: according to the freq of cpu,</span><br><span class="line"> *      			normally the period should be set to the value</span><br><span class="line"> *      			that makes the freq of pwm waveform to be 15 k</span><br><span class="line"> *      			e.g., for 50MHz, value should be 3333(0xD05)</span><br><span class="line"> *      	enable:'0' represents off, '1' is on, lease significant bit is for channel 1</span><br><span class="line"> *      			e.g., for channel 1 on and channel 2 off, enable=0x1</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"motor_setting.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motor_setting</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> phase1, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty1</span><br><span class="line">                   ,<span class="keyword">unsigned</span> <span class="keyword">long</span> phase2, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty2</span><br><span class="line">                   ,<span class="keyword">unsigned</span> <span class="keyword">long</span> period,<span class="keyword">unsigned</span> <span class="keyword">long</span> enable)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_en= (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_EN;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_period=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PERIOD;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_phase1=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PHASE1;<span class="comment">//这个是位置=&gt;.h头文件</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_phase2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PHASE2;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_duty1=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_DUTY1;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_duty2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_DUTY2;</span><br><span class="line"></span><br><span class="line">	* pwm_en=enable;</span><br><span class="line">	* pwm_period=period;</span><br><span class="line">	* pwm_phase1=phase1;</span><br><span class="line">	* pwm_phase2=phase2;</span><br><span class="line">	* pwm_duty1=duty1;</span><br><span class="line">	* pwm_duty2=duty2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * motor_setting.h</span><br><span class="line"> *</span><br><span class="line"> *  Created on: 07.11.2012</span><br><span class="line"> *      Author: karl_ee</span><br><span class="line"> *          input parameters:</span><br><span class="line"> *      	phase: range from</span><br><span class="line"> *     		duty cycle:</span><br><span class="line"> *      	period: according to the freq of cpu,</span><br><span class="line"> *      			normally the period should be set to the value</span><br><span class="line"> *      			that makes the freq of pwm waveform to be 15 k</span><br><span class="line"> *      			e.x for 50MHz, value should be 3333(0xD05)</span><br><span class="line"> *      	enable:'0' represents off, '1' is on</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MOTOR_SETTING_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR_SETTING_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_EN PWM0_BASE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PERIOD PWM0_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_DUTY1 PWM0_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_DUTY2 PWM0_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PHASE1 PWM0_BASE+4<span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PHASE2 PWM0_BASE+5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motor_setting</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> phase1, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty1,<span class="keyword">unsigned</span> <span class="keyword">long</span> phase2, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty2,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> period,<span class="keyword">unsigned</span> <span class="keyword">long</span> enable)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MOTOR_SETTING_H_ */</span></span></span><br></pre></td></tr></table></figure>
<p>顺着线索一路找下去可以在<code>NIOSCar.qsf</code>里面找到这样一段</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#reuse above pins for PWM0-3</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------</span></span><br><span class="line">set_location_assignment PIN_B6 -to PWM0Ch0</span><br><span class="line">set_instance_assignment -name IO_STANDARD <span class="string">"3.3-V LVTTL"</span> -to PWM0Ch0</span><br><span class="line">set_location_assignment PIN_A6 -to PWM0Ch1</span><br><span class="line">set_instance_assignment -name IO_STANDARD <span class="string">"3.3-V LVTTL"</span> -to PWM0Ch1</span><br></pre></td></tr></table></figure>
<p>也就是说它把<code>BASE</code>赋给<code>B6</code>和<code>A6</code>位了,在<code>DE0_Nano_User_Manual_v1.9.pdf</code>里面大概12页找到对应管脚以及它上面的物理位置,然后就有输出信号了.</p>
<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">30</span>)</span><br><span class="line">        IOWR(PIO0_BASE, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//这里的宏定义参考ppt</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IOWR(PIO0_BASE, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后对应这一段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================================================</span></span><br><span class="line"><span class="comment"># GPIO_0, GPIO_0 connect to GPIO Default</span></span><br><span class="line"><span class="comment">#============================================================</span></span><br><span class="line">set_location_assignment PIN_D3 -to GPIO_0[<span class="number">0</span>]</span><br><span class="line">set_instance_assignment -name IO_STANDARD <span class="string">"3.3-V LVTTL"</span> -to GPIO_0[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="RUN-THE-CAR"><a href="#RUN-THE-CAR" class="headerlink" title="RUN THE CAR"></a>RUN THE CAR</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">	组合了一些函数在这里</span><br><span class="line">	能让小车run起来~~~</span><br><span class="line">	1. 有两个头文件有毒..这里删了</span><br><span class="line">	2. 把main.h 和 motor_setting.h 仿制了一份</span><br><span class="line">	3. 采用pwm2,也就是pwm0后面两位的接口.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//standard C library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> <span class="comment">//like int16_t;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"io.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"system.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"altera_avalon_pio_regs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;altera_avalon_performance_counter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//what?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"sys/alt_irq.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"alt_types.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span>  char_8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  uchar_8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span> short_16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> ushort_16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> long_32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong_32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> long_64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong_64;</span><br><span class="line"></span><br><span class="line"><span class="comment">//first mortor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_EN PWM0_BASE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PERIOD PWM0_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_DUTY1 PWM0_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_DUTY2 PWM0_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PHASE1 PWM0_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PHASE2 PWM0_BASE+5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motor_setting</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> phase1, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty1,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> phase2, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty2,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> period,<span class="keyword">unsigned</span> <span class="keyword">long</span> enable)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_en= (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_EN;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_period=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PERIOD;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_phase1=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PHASE1;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_phase2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PHASE2;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_duty1=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_DUTY1;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_duty2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_DUTY2;</span><br><span class="line"></span><br><span class="line">	* pwm_en=enable;</span><br><span class="line">	* pwm_period=period;</span><br><span class="line">	* pwm_phase1=phase1;</span><br><span class="line">	* pwm_phase2=phase2;</span><br><span class="line">	* pwm_duty1=duty1;</span><br><span class="line">	* pwm_duty2=duty2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仿造PWM0函数写下的PWM2宏定义以及函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_EN1 PWM2_BASE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PERIOD1 PWM2_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_DUTY11 PWM2_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_DUTY21 PWM2_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PHASE11 PWM2_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWM_PHASE21 PWM2_BASE+5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motor_setting1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> phase1, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty1,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> phase2, <span class="keyword">unsigned</span> <span class="keyword">long</span> duty2,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> period,<span class="keyword">unsigned</span> <span class="keyword">long</span> enable)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_en= (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_EN1;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_period=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PERIOD1;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_phase1=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PHASE11;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_phase2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_PHASE21;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_duty1=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_DUTY11;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * pwm_duty2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PWM_DUTY21;</span><br><span class="line"></span><br><span class="line">	* pwm_en=enable;</span><br><span class="line">	* pwm_period=period;</span><br><span class="line">	* pwm_phase1=phase1;</span><br><span class="line">	* pwm_phase2=phase2;</span><br><span class="line">	* pwm_duty1=duty1;</span><br><span class="line">	* pwm_duty2=duty2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">char</span> key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nirq_isr_context;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得在main中initial</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得声明在前面...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">//todo: set up interrupt function</span></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,<span class="number">3</span>);<span class="comment">//3 = 1 | 2,表示1和2输入时都有反应</span></span><br><span class="line"></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);<span class="comment">//这句话是清空中断状态</span></span><br><span class="line"></span><br><span class="line">    alt_ic_isr_register( <span class="number">0</span>, <span class="number">1</span>,isr_function, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">//声明中断函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	a = !a;</span><br><span class="line">	<span class="comment">//这句话是用来测试是否进入中断的...</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"cs - %d\n"</span>,a);</span><br><span class="line">  	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	nIRQ_Initial();<span class="comment">//注意初始化!!!!!!!!!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> phase1=<span class="number">0x000</span>, phase2=<span class="number">0x000</span>, phase3=<span class="number">0x000</span>, phase4=<span class="number">0x000</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> duty1=<span class="number">0x0000</span>, duty2=<span class="number">0x0000</span>, duty3=<span class="number">0x0000</span>, duty4=<span class="number">0x0000</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> period=<span class="number">0x186A</span>,enable=<span class="number">0x3</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化,马达不会跑</span></span><br><span class="line">	motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(a)<span class="comment">//小车的普通状态,倒着跑</span></span><br><span class="line">		&#123;</span><br><span class="line">			phase1=<span class="number">0x000</span>, phase2=<span class="number">0x000</span>, phase3=<span class="number">0x000</span>, phase4=<span class="number">0x000</span>;</span><br><span class="line">			duty1=<span class="number">0x1000</span>, duty2=<span class="number">0x0000</span>, duty3=<span class="number">0x1000</span>, duty4=<span class="number">0x0000</span>;</span><br><span class="line">			period=<span class="number">0x186A</span>,enable=<span class="number">0x3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//按键后改变的状态,正向跑</span></span><br><span class="line">		&#123;</span><br><span class="line">			phase1=<span class="number">0x000</span>, phase2=<span class="number">0x000</span>, phase3=<span class="number">0x000</span>, phase4=<span class="number">0x000</span>;</span><br><span class="line">			duty1=<span class="number">0x0000</span>, duty2=<span class="number">0x1000</span>, duty3=<span class="number">0x0000</span>, duty4=<span class="number">0x1000</span>;</span><br><span class="line">			period=<span class="number">0x186A</span>,enable=<span class="number">0x3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">		motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2550</span>;i++);<span class="comment">//这里一个莫名的delay...或许数据可以改小一点..</span></span><br><span class="line">		<span class="comment">//for(j=0;j&lt;2550;j++);//delay</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>今天真的挺迷的…check电路时候一拔USB之后小车断电,</p>
<p>测了几次后FPGA漏电然后各种重新烧重新测..似乎就像搭这个博客一样…</p>
<p>反正码农嘛..写烂了debug后丢掉就好.</p>
<h1 id="超声波模块"><a href="#超声波模块" class="headerlink" title="超声波模块"></a>超声波模块</h1>
	<iframe src="http://www.slideshare.net/slideshow/embed_code/key/mt80mQ7q63ky5K" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<p><img src="http://radar-10050281.file.myqcloud.com/img/0706.png" alt=""></p>
<p>这次实验选用了GPIO1的一些管脚,注意是与GPIO0的方向相反</p>
<p>VCC和地线采用JP2 的11 和12口,提供4V电压(觉得这里可以优化成3.3V)</p>
<p>RX口和TK口对应NIOSCAR.qsf line355~line365行的引脚对应,分别对应模块的TK和RX</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#reuse above pins for New Ultrasound 0</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#set_location_assignment PIN_F13 -to GPIO_1[0]</span></span><br><span class="line"><span class="comment">#set_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to GPIO_1[0]</span></span><br><span class="line"><span class="comment">#set_location_assignment PIN_T15 -to GPIO_1[1]</span></span><br><span class="line"><span class="comment">#set_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to GPIO_1[1]</span></span><br><span class="line">set_location_assignment PIN_F13 -to New_Ultrasound0_rx</span><br><span class="line">set_instance_assignment -name IO_STANDARD <span class="string">"3.3-V LVTTL"</span> -to New_Ultrasound0_rx</span><br><span class="line">set_location_assignment PIN_T15 -to New_Ultrasound0_tx</span><br><span class="line">set_instance_assignment -name IO_STANDARD <span class="string">"3.3-V LVTTL"</span> -to New_Ultrasound0_tx</span><br></pre></td></tr></table></figure>
<p>然后这次实验有三个task,分别是对光敏,距离和时间的检测</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//standard C library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> <span class="comment">//like int16_t;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"io.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"system.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"altera_avalon_pio_regs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;altera_avalon_performance_counter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//what?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"sys/alt_irq.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"alt_types.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span>  char_8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  uchar_8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span> short_16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> ushort_16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> long_32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong_32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> long_64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong_64;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">char</span> key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nirq_isr_context;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得在main中initial</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//记得声明在前面...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nIRQ_Initial</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">//todo: set up interrupt function</span></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,<span class="number">3</span>);<span class="comment">//3 = 1 | 2,表示1和2输入时都有反应</span></span><br><span class="line"></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);<span class="comment">//这句话是清空中断状态</span></span><br><span class="line"></span><br><span class="line">    alt_ic_isr_register( <span class="number">0</span>, <span class="number">1</span>,isr_function, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">//声明中断函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr_function</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	a = !a;</span><br><span class="line">	<span class="comment">//这句话是用来测试是否进入中断的...</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"cs - %d\n"</span>,a);</span><br><span class="line">  	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作函数,Address是传入地址,x是对应命令</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">light</span><span class="params">(<span class="keyword">long</span> Address,<span class="keyword">long</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> res_l, res_h;</span><br><span class="line">	Uart_send_byte(Address, <span class="number">0xe8</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">		;</span><br><span class="line">	Uart_send_byte(Address, <span class="number">0x02</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">		;</span><br><span class="line">	Uart_send_byte(Address,x);<span class="comment">//修改的函数..</span></span><br><span class="line">  res_h = Uart_receive_byte(Address);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++);</span><br><span class="line">  res_l = Uart_receive_byte(Address);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (((<span class="keyword">unsigned</span> <span class="keyword">int</span>) res_h) &lt;&lt; <span class="number">8</span>) + res_l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> task3 <span class="comment">//这里改成123分别测试</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"HELLO WORLD\n"</span>);</span><br><span class="line">	nIRQ_Initial();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND0_BASE);<span class="comment">//重置测位函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> task2</span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>,i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;<span class="number">5</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt += ultrasound_read(NEW_ULTRASOUND0_BASE, a);<span class="comment">//a = 0, 5m; a = 1, 11m;</span></span><br><span class="line">		&#125;<span class="comment">//消除噪音</span></span><br><span class="line">		cnt /= <span class="number">5</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d.%dm\n"</span>,cnt/<span class="number">1000</span>,cnt%<span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> task1</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,light(NEW_ULTRASOUND0_BASE,<span class="number">0xa0</span>) );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> task3</span></span><br><span class="line">		<span class="keyword">int</span> clk = light(NEW_ULTRASOUND0_BASE,<span class="number">0x1e</span>)*<span class="number">170</span> ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d.%dm\n"</span>, clk / <span class="number">1000000</span> , clk % <span class="number">1000000</span>);</span><br><span class="line">      	<span class="comment">//相对来说,这个测距更为精确，但是探测很多次之后似乎会死机？？？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="light函数传入x小结"><a href="#light函数传入x小结" class="headerlink" title="light函数传入x小结"></a>light函数传入x小结</h2><table>
<thead>
<tr>
<th style="text-align:center">传入参数</th>
<th style="text-align:center">对应效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0xa0</td>
<td style="text-align:center">光敏传感器(1ms探测耗时)</td>
</tr>
<tr>
<td style="text-align:center">0x1e</td>
<td style="text-align:center">3m,返回测量时间</td>
</tr>
<tr>
<td style="text-align:center">x from 0x01 to 0x2f</td>
<td style="text-align:center">(63 ~ 93) ~ 577 * x µs</td>
</tr>
<tr>
<td style="text-align:center">0xb0 0xb2</td>
<td style="text-align:center">5m,33ms,返回mm 返回µs</td>
</tr>
<tr>
<td style="text-align:center">0xb8 0xba</td>
<td style="text-align:center">11m,68ms,返回mm 返回µs</td>
</tr>
<tr>
<td style="text-align:center">0xc4 0x45</td>
<td style="text-align:center">5s 1s 休眠等待</td>
</tr>
</tbody>
</table>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span><br><span class="line">  Function:</span><br><span class="line">    unsigned int ultrasound_read(long Address, unsigned char settings)</span><br><span class="line"></span><br><span class="line">  Description:</span><br><span class="line">   // This function receives one Byte via the corresponding UART from the Address</span><br><span class="line"></span><br><span class="line">  Precondition:</span><br><span class="line">    Call ultrasound_init(long Address) prior to use this function</span><br><span class="line"></span><br><span class="line">  Parameters:</span><br><span class="line">    long Address 			- Address of the UART (and therefore of the Ultrasound)</span><br><span class="line">	unsigned char settings 	- defines maximum distance to measure (1: 11m; 0: 5m)</span><br><span class="line"></span><br><span class="line">  Returns:</span><br><span class="line">    unsigned int - distance in mm</span><br><span class="line"></span><br><span class="line">  Remarks:</span><br><span class="line">    Distance in meter</span><br><span class="line">  ***************************************************************************/</span></span><br></pre></td></tr></table></figure>
<h2 id="另外的笔记"><a href="#另外的笔记" class="headerlink" title="另外的笔记"></a>另外的笔记</h2><h3 id="进一步的省电措施"><a href="#进一步的省电措施" class="headerlink" title="进一步的省电措施"></a>进一步的省电措施</h3><blockquote>
<p>如果用户希望将省电进行到底</p>
<p>发送 0xc1 关 LED 探测显示，以降低电流消耗。</p>
<p>发送0xc0 可以恢复 LED 探测显示。</p>
<p>配置方法非常简单，向本模块发送指令时序：“I2C 地址 + 寄存器 2 +0xc0/0xc1”即可，<br>发送完成后请延时至少 2 秒，以让系统自动完成配置。并开始按照新配置工作。</p>
</blockquote>
<h3 id="测距范围"><a href="#测距范围" class="headerlink" title="测距范围"></a>测距范围</h3><p><img src="http://radar-10050281.file.myqcloud.com/img/07061.png" alt=""></p>
<h1 id="同步进程"><a href="#同步进程" class="headerlink" title="同步进程"></a>同步进程</h1><h2 id="单函数同步"><a href="#单函数同步" class="headerlink" title="单函数同步"></a>单函数同步</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"includes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"io.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Definition of Task Stacks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   TASK_STACKSIZE       2048</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   N_TASKS 8 <span class="comment">//最大进程数</span></span></span><br><span class="line">OS_STK    taskStk[N_TASKS][TASK_STACKSIZE];<span class="comment">//申请栈空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">void</span> * pdata)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pos = (<span class="keyword">int</span>) pdata;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,pos);<span class="comment">//调试输出当前改变的位</span></span><br><span class="line">		IOWR(LED_BASE, <span class="number">0</span>, IORD(LED_BASE,<span class="number">0</span>) ^ (<span class="number">1</span>&lt;&lt;pos));<span class="comment">//改变当前位的值</span></span><br><span class="line">		OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, (pos + <span class="number">1</span>), <span class="number">0</span>);<span class="comment">//每一个延迟时间,注意不能设为0.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">	OSInit();</span><br><span class="line">	<span class="keyword">int</span> idx;</span><br><span class="line">	<span class="keyword">for</span>(idx = <span class="number">0</span>;idx &lt; N_TASKS; ++idx)</span><br><span class="line">	&#123;</span><br><span class="line">		OSTaskCreate(   task,<span class="comment">//同步进程函数</span></span><br><span class="line">		                (<span class="keyword">void</span>*)idx,<span class="comment">//id(传入task函数参数)</span></span><br><span class="line">		                 &amp;taskStk[idx][TASK_STACKSIZE<span class="number">-1</span>],<span class="comment">//取最后一位地址</span></span><br><span class="line">		                idx+<span class="number">1</span>);<span class="comment">//优先级</span></span><br><span class="line">      <span class="comment">//成功之后返回0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  OSStart();<span class="comment">//不会初始化到这里</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双函数同步-努力异步"><a href="#双函数同步-努力异步" class="headerlink" title="双函数同步_努力异步"></a>双函数同步_努力异步</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"includes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"io.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Definition of Task Stacks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   TASK_STACKSIZE       2048</span></span><br><span class="line">OS_STK    task1_stk[TASK_STACKSIZE];</span><br><span class="line">OS_STK    task2_stk[TASK_STACKSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Definition of Task Priorities */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK1_PRIORITY      1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK2_PRIORITY      2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> msg1[]=&#123;<span class="number">89</span>,<span class="number">111</span>,<span class="number">117</span>,<span class="number">32</span>,<span class="number">115</span>,<span class="number">111</span>,<span class="number">108</span>,<span class="number">118</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">32</span>,<span class="number">116</span>,<span class="number">104</span>,<span class="number">105</span>,<span class="number">115</span>,<span class="number">32</span>,<span class="number">116</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">107</span>,<span class="number">33</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> msg2[]=&#123;<span class="number">71</span>,<span class="number">111</span>,<span class="number">111</span>,<span class="number">100</span>,<span class="number">32</span>,<span class="number">106</span>,<span class="number">111</span>,<span class="number">98</span>,<span class="number">33</span>,<span class="number">32</span>,<span class="number">89</span>,<span class="number">111</span>,<span class="number">117</span>,<span class="number">32</span>,<span class="number">97</span>,<span class="number">114</span>,<span class="number">101</span>,<span class="number">32</span>,<span class="number">97</span>,<span class="number">119</span>,<span class="number">101</span>,<span class="number">115</span>,<span class="number">111</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">33</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task1</span><span class="params">(<span class="keyword">void</span>* pdata)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">250</span>);<span class="comment">//这段时间走task2就好,其实没有设置的很精</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(msg1); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,msg1[i]);</span><br><span class="line">		IOWR(LED_BASE, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">0x7</span>) ));<span class="comment">//同时用亮灯展示当前输出位,顺时针</span></span><br><span class="line">		OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">250</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task2</span><span class="params">(<span class="keyword">void</span>* pdata)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(msg2); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,msg2[i]);</span><br><span class="line">		IOWR(LED_BASE, <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>-(i &amp; <span class="number">0x7</span>) ));<span class="comment">//逆时针</span></span><br><span class="line">		OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">250</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	OSTimeDlyHMSM(<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">250</span>);<span class="comment">//这段时间走task1就好,其实没有设置的很精确.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">  OSInit();<span class="comment">//初始化</span></span><br><span class="line">  <span class="comment">//声明task</span></span><br><span class="line">  OSTaskCreate(   Task1,</span><br><span class="line">                  (<span class="keyword">void</span>*)<span class="number">0</span>,</span><br><span class="line">                  (<span class="keyword">void</span> *)&amp;task1_stk[TASK_STACKSIZE<span class="number">-1</span>],</span><br><span class="line">                  TASK1_PRIORITY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  OSTaskCreate(   Task2,</span><br><span class="line">                  (<span class="keyword">void</span>*)<span class="number">0</span>,</span><br><span class="line">                  (<span class="keyword">void</span> *)&amp;task2_stk[TASK_STACKSIZE<span class="number">-1</span>],</span><br><span class="line">                  TASK2_PRIORITY);</span><br><span class="line">  <span class="comment">//start multitasking</span></span><br><span class="line">  OSStart();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很遗憾的是最后没有完全理解另一个进程同步函数,</p>
<p>在尝试的过程中发现那个函数也只是起了一个延时的作用,于是放弃了调试</p>
<p>同步进程这种事让我想起了C++中也可以实现233于是完成的挺顺利的</p>
<p>最后几次看中珠的夕阳.可惜没邂逅彩霞</p>
<h1 id="FINAL"><a href="#FINAL" class="headerlink" title="FINAL"></a>FINAL</h1><blockquote>
<p> task:</p>
<p> 完成小车避障功能</p>
<p> PID实现小车跟踪</p>
<p> 努力实现创新功能</p>
</blockquote>
<p>相关代码及注释…</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">	task1: 避障</span><br><span class="line">	task2: 包含中断的跟踪</span><br><span class="line">		状态一: 20cm 跟踪, 10cm 后退</span><br><span class="line">		状态二: 20cm 跟踪.</span><br><span class="line">	task3: 跟着光强的方向走</span><br><span class="line">*/</span><br><span class="line">#define task2 </span><br><span class="line"></span><br><span class="line">//standard C library</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt; //like int16_t;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">//else</span><br><span class="line">#include "io.h"</span><br><span class="line">#include "system.h"</span><br><span class="line">#include "altera_avalon_pio_regs.h"</span><br><span class="line">#include &lt;altera_avalon_performance_counter.h&gt;</span><br><span class="line"></span><br><span class="line">//what?</span><br><span class="line">#include "sys/alt_irq.h"</span><br><span class="line">#include "alt_types.h"</span><br><span class="line"></span><br><span class="line">typedef signed char  char_8;</span><br><span class="line">typedef unsigned char  uchar_8;</span><br><span class="line">typedef signed short short_16;</span><br><span class="line">typedef unsigned short ushort_16;</span><br><span class="line">typedef signed long long_32;</span><br><span class="line">typedef unsigned long ulong_32;</span><br><span class="line">typedef long long long_64;</span><br><span class="line">typedef unsigned long long ulong_64;</span><br><span class="line"></span><br><span class="line">/*PWM信号输出,控制马达*/</span><br><span class="line"></span><br><span class="line">//first mortor</span><br><span class="line">#define PWM_EN PWM0_BASE</span><br><span class="line">#define PWM_PERIOD PWM0_BASE+1</span><br><span class="line">#define PWM_DUTY1 PWM0_BASE+2</span><br><span class="line">#define PWM_DUTY2 PWM0_BASE+3</span><br><span class="line">#define PWM_PHASE1 PWM0_BASE+4</span><br><span class="line">#define PWM_PHASE2 PWM0_BASE+5</span><br><span class="line"></span><br><span class="line">//仿造PWM0函数写下的PWM2宏定义以及函数</span><br><span class="line">#define PWM_EN1 PWM2_BASE</span><br><span class="line">#define PWM_PERIOD1 PWM2_BASE+1</span><br><span class="line">#define PWM_DUTY11 PWM2_BASE+2</span><br><span class="line">#define PWM_DUTY21 PWM2_BASE+3</span><br><span class="line">#define PWM_PHASE11 PWM2_BASE+4</span><br><span class="line">#define PWM_PHASE21 PWM2_BASE+5</span><br><span class="line"></span><br><span class="line">void motor_setting(unsigned long phase1, unsigned long duty1,</span><br><span class="line">                   unsigned long phase2, unsigned long duty2,</span><br><span class="line">                   unsigned long period,unsigned long enable);</span><br><span class="line"></span><br><span class="line">void motor_setting1(unsigned long phase1, unsigned long duty1,</span><br><span class="line">                    unsigned long phase2, unsigned long duty2,</span><br><span class="line">                    unsigned long period,unsigned long enable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//中断</span><br><span class="line">int a = 1;</span><br><span class="line"></span><br><span class="line">volatile static char key = 0;</span><br><span class="line"></span><br><span class="line">unsigned int nirq_isr_context;</span><br><span class="line">void nIRQ_Initial(void);//记得在main中initial</span><br><span class="line">void isr_function(void);//记得声明在前面...</span><br><span class="line"></span><br><span class="line">void nIRQ_Initial(void)</span><br><span class="line">&#123;</span><br><span class="line">  //todo: set up interrupt function</span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,3);//3 = 1 | 2,表示1和2输入时都有反应</span><br><span class="line"></span><br><span class="line">    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);//这句话是清空中断状态</span><br><span class="line"></span><br><span class="line">    alt_ic_isr_register( 0, 1,isr_function, 0, 0 );//声明中断函数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void isr_function(void)</span><br><span class="line">&#123;</span><br><span class="line">	a = !a;</span><br><span class="line">	//这句话是用来测试是否进入中断的...</span><br><span class="line">	printf("cs - %d\n",a);</span><br><span class="line">  	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);</span><br><span class="line">&#125;</span><br><span class="line">//超声波操作函数,Address是传入地址,x是对应命令</span><br><span class="line">unsigned int light(long Address,long x)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	unsigned char res_l, res_h;</span><br><span class="line">	Uart_send_byte(Address, 0xe8);</span><br><span class="line">	for (i = 0; i &lt; 2000; i++)</span><br><span class="line">		;</span><br><span class="line">	Uart_send_byte(Address, 0x02);</span><br><span class="line">	for (i = 0; i &lt; 2000; i++)</span><br><span class="line">		;</span><br><span class="line">	Uart_send_byte(Address,x);//修改的函数..</span><br><span class="line">  res_h = Uart_receive_byte(Address);</span><br><span class="line">	for (i = 0; i &lt; 1000; i++);</span><br><span class="line">  res_l = Uart_receive_byte(Address);</span><br><span class="line"></span><br><span class="line">  return (((unsigned int) res_h) &lt;&lt; 8) + res_l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 马达驱动的参数</span><br><span class="line">	1,2是对右边马达,phase是初始相位,duty是占空比,都得/period</span><br><span class="line">	enable是对于两个端口的使能</span><br><span class="line">*/</span><br><span class="line">unsigned long phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;</span><br><span class="line">unsigned long duty1=0x0000, duty2=0x1000, duty3=0x0000, duty4=0x0000;</span><br><span class="line">unsigned long period=0x186A,enable=0x3;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	封装四个方向函数</span><br><span class="line">	up和down在for循环十次后基本能前进后退..调整了一定参数</span><br><span class="line">	避障中left和right函数先后退一步然后前进(也是一个for(10))</span><br><span class="line">	跟踪中的直接左右拐就行..for(5)</span><br><span class="line">*/</span><br><span class="line">void up()</span><br><span class="line">&#123;</span><br><span class="line">	phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;</span><br><span class="line">	duty1=0x0000, duty2=0x1000, duty3=0x0000, duty4=0x1000;</span><br><span class="line">	period=0x186A,enable=0x3;</span><br><span class="line">	motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">	usleep(8000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void down()</span><br><span class="line">&#123;</span><br><span class="line">	phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;</span><br><span class="line">	duty1=0x1000, duty2=0x0000, duty3=0x1000, duty4=0x0000;</span><br><span class="line">	period=0x186A,enable=0x3;</span><br><span class="line">	motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">	usleep(20000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#ifdef task1</span><br><span class="line">void le()</span><br><span class="line">&#123;</span><br><span class="line">	down();</span><br><span class="line">	phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;</span><br><span class="line">	duty1=0x0000, duty2=0x1000, duty3=0x1000, duty4=0x0000;</span><br><span class="line">	period=0x186A,enable=0x3;</span><br><span class="line">	motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">	usleep(5000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ri()</span><br><span class="line">&#123;</span><br><span class="line">	down();</span><br><span class="line">	phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;</span><br><span class="line">	duty1=0x1000, duty2=0x0000, duty3=0x0000, duty4=0x1000;</span><br><span class="line">	period=0x186A,enable=0x3;</span><br><span class="line">	motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">	usleep(5000);</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">void le()</span><br><span class="line">&#123;</span><br><span class="line">	phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;</span><br><span class="line">	duty1=0x0000, duty2=0x1000, duty3=0x1000, duty4=0x0000;</span><br><span class="line">	period=0x186A,enable=0x3;</span><br><span class="line">	motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">	usleep(5000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ri()</span><br><span class="line">&#123;</span><br><span class="line">	phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;</span><br><span class="line">	duty1=0x1000, duty2=0x0000, duty3=0x0000, duty4=0x1000;</span><br><span class="line">	period=0x186A,enable=0x3;</span><br><span class="line">	motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">	usleep(5000);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//避障中查询距离是否过近</span><br><span class="line">int ck(unsigned int dis)</span><br><span class="line">&#123;</span><br><span class="line">	//if(dis &gt; 2900000) return 0;</span><br><span class="line">	if(dis &lt; 200000) return 0;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">//如果已经超过范围</span><br><span class="line">int ck1(int dis)</span><br><span class="line">&#123;</span><br><span class="line">	if(dis &gt; 300000 &amp;&amp; dis &lt; 2900000) return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf("HELLO WORLD\n");//hello world DEBUG大法好</span><br><span class="line">	nIRQ_Initial();//中断初始化函数</span><br><span class="line">	//默认马达初始化为0</span><br><span class="line">	 motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">	 motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">	//PID积分参数</span><br><span class="line">	 int tot = 0,tot1 = 0;</span><br><span class="line">	/*</span><br><span class="line">	跟踪参数</span><br><span class="line">		第一个是最远有效距离66.6666cm</span><br><span class="line">		第二个是跟踪距离</span><br><span class="line">		第三个是后退距离</span><br><span class="line">	*/</span><br><span class="line">	 int meter =   666666;</span><br><span class="line">	 int meter02 = 200000;</span><br><span class="line">	 int meter03 = 100000;</span><br><span class="line">	 int p; // cycle</span><br><span class="line">	//pid系数</span><br><span class="line">	 double k = 0.3 ,j = 0.05,d = 0;</span><br><span class="line">	//这里是先调了一个直线的PID,然后转化成有角度后改的一个参量</span><br><span class="line">	 int clk11; //pace</span><br><span class="line"></span><br><span class="line">	 while(1)&#123;</span><br><span class="line"></span><br><span class="line">#ifdef task3 //光敏测距</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数</span><br><span class="line">		int clk = light(NEW_ULTRASOUND0_BASE,0xa0) ;</span><br><span class="line">		printf("1 =&gt; %d.%dm\t", clk );</span><br><span class="line">		usleep(10000);</span><br><span class="line">		int clk1 = light(NEW_ULTRASOUND1_BASE,0xa0) ;</span><br><span class="line">		printf("2 =&gt; %d.%dm\t", clk1 );</span><br><span class="line">		usleep(10000);</span><br><span class="line">		int clk2 = light(NEW_ULTRASOUND2_BASE,0xa0) ;</span><br><span class="line">		printf("3 =&gt; %d.%dm\n", clk2 );</span><br><span class="line">		usleep(10000);</span><br><span class="line"></span><br><span class="line"> #define run for(p = 0;p &lt; 5;p++)</span><br><span class="line">		//选取光最强的方向</span><br><span class="line">		if (clk1 &gt;= clk &amp;&amp; clk1 &gt;= clk2)</span><br><span class="line">		&#123;</span><br><span class="line">			clk11 = clk1;</span><br><span class="line">		&#125;//don' rotate</span><br><span class="line">		else if(clk &gt;= clk1 &amp;&amp; clk &gt;= clk2)</span><br><span class="line">		&#123;</span><br><span class="line">			clk11 = clk;</span><br><span class="line">			run le();</span><br><span class="line">		&#125;//left rotate</span><br><span class="line">		else if(clk2 &gt;= clk &amp;&amp; clk2 &gt;= clk1)</span><br><span class="line">		&#123;</span><br><span class="line">			clk11 = clk2;</span><br><span class="line">			run ri();</span><br><span class="line">		&#125;//right rotate</span><br><span class="line">		//go go go</span><br><span class="line">		if(clk11 &lt; 200 )//光太弱停止..参数应该适当调大的..</span><br><span class="line">		&#123;</span><br><span class="line">			tot = tot1 = 0;</span><br><span class="line">			duty1=0x0000, duty2=0x0000;</span><br><span class="line">			duty3=0x0000, duty4=0x0000;</span><br><span class="line">		&#125;</span><br><span class="line">		else//PID向前跑</span><br><span class="line">		&#123;</span><br><span class="line">			printf("up\n");</span><br><span class="line">			d = clk11 ;</span><br><span class="line">			duty1=0x0000, duty2=0x1000;</span><br><span class="line">			duty3=0x0000, duty4=0x1000;</span><br><span class="line">			tot += d;</span><br><span class="line">			tot1 = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">		motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">		int rtime = (int)(100 * d );//这里乘了一个d之后记得强制转换,double有毒</span><br><span class="line">		if(rtime &lt;= 0) rtime = 0;//小于零有毒..这两个有可能保持后退状态</span><br><span class="line">		usleep(rtime);</span><br><span class="line">#endif</span><br><span class="line">#ifdef task21 //测试只能前进的跟踪</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数</span><br><span class="line">		int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ;</span><br><span class="line">		printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000);</span><br><span class="line">		usleep(10000);</span><br><span class="line">		int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ;</span><br><span class="line">		printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000);</span><br><span class="line">		usleep(10000);</span><br><span class="line">		int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ;</span><br><span class="line">		printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000);</span><br><span class="line">		usleep(10000);</span><br><span class="line"></span><br><span class="line">#define run for(p = 0;p &lt; 5;p++)</span><br><span class="line"></span><br><span class="line">		if (clk1 &lt;= clk &amp;&amp; clk1 &lt;= clk2)</span><br><span class="line">		&#123;</span><br><span class="line">			clk11 = clk1;</span><br><span class="line">		&#125;//don' rotate</span><br><span class="line">		else if(clk &lt;= clk1 &amp;&amp; clk &lt;= clk2)</span><br><span class="line">		&#123;</span><br><span class="line">			clk11 = clk;</span><br><span class="line">			run le();</span><br><span class="line">		&#125;//left rotate</span><br><span class="line">		else if(clk2 &lt;= clk &amp;&amp; clk2 &lt;= clk1)</span><br><span class="line">		&#123;</span><br><span class="line">			clk11 = clk2;</span><br><span class="line">			run ri();</span><br><span class="line">		&#125;//right rotate</span><br><span class="line">		//go go go</span><br><span class="line">		if(clk11 &gt; meter )</span><br><span class="line">		&#123;</span><br><span class="line">			tot = 0;</span><br><span class="line">			duty1=0x0000, duty2=0x0000;</span><br><span class="line">			duty3=0x0000, duty4=0x0000;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(clk11 &gt; meter02)</span><br><span class="line">		&#123;</span><br><span class="line">			printf("up\n");</span><br><span class="line">			d = clk11 - meter02;</span><br><span class="line">			duty1=0x0000, duty2=0x1000;</span><br><span class="line">			duty3=0x0000, duty4=0x1000;</span><br><span class="line">			tot += d;</span><br><span class="line">			tot1 = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">		motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">		int rtime = (int)(d * k +  tot  * j );</span><br><span class="line">		if(rtime &lt;= 0) rtime = 0;</span><br><span class="line">		usleep(rtime);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">		//get the distance</span><br><span class="line">#ifdef task2 //测试跟踪</span><br><span class="line">		if(a)</span><br><span class="line">		&#123;</span><br><span class="line">			ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数</span><br><span class="line">			ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数</span><br><span class="line">			ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数</span><br><span class="line">			//用前文自己写的3m内测速函数</span><br><span class="line">			int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ;</span><br><span class="line">			printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000);</span><br><span class="line">			usleep(10000);//记得usleep,因为每个测距有个时间,不然很容易死循环..</span><br><span class="line">			int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ;</span><br><span class="line">			printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000);</span><br><span class="line">			usleep(10000);</span><br><span class="line">			int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ;</span><br><span class="line">			printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000);</span><br><span class="line">			usleep(10000);</span><br><span class="line"></span><br><span class="line">		#define run for(p = 0;p &lt; 5;p++)//啊这个只是懒得写....</span><br><span class="line">			//选取距离最小的方向</span><br><span class="line">				if (clk1 &lt;= clk &amp;&amp; clk1 &lt;= clk2)</span><br><span class="line">				&#123;</span><br><span class="line">					clk11 = clk1;</span><br><span class="line">				&#125;//don' rotate</span><br><span class="line">				else if(clk &lt;= clk1 &amp;&amp; clk &lt;= clk2)</span><br><span class="line">				&#123;</span><br><span class="line">					clk11 = clk;</span><br><span class="line">					run le();</span><br><span class="line">				&#125;//left rotate</span><br><span class="line">				else if(clk2 &lt;= clk &amp;&amp; clk2 &lt;= clk1)</span><br><span class="line">				&#123;</span><br><span class="line">					clk11 = clk2;</span><br><span class="line">					run ri();</span><br><span class="line">				&#125;//right rotate</span><br><span class="line">				//go go go</span><br><span class="line">				if(clk11 &gt; meter || tot1)//保证只后退一步....(这个是一开始一直后退的修复)</span><br><span class="line">				&#123;</span><br><span class="line">					tot = tot1 = 0;</span><br><span class="line">					duty1=0x0000, duty2=0x0000;</span><br><span class="line">					duty3=0x0000, duty4=0x0000;</span><br><span class="line">				&#125;</span><br><span class="line">				else if( clk11 &lt; meter03)//后退</span><br><span class="line">				&#123;</span><br><span class="line">					printf("down\n");</span><br><span class="line">					d = meter03 - clk11;</span><br><span class="line">					duty1=0x1000, duty2=0x0000;</span><br><span class="line">					duty3=0x1000, duty4=0x0000;</span><br><span class="line">					tot1 += d;</span><br><span class="line">					tot = 0;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				else if(clk11 &gt; meter02)//前进,PID中P,I记录</span><br><span class="line">				&#123;</span><br><span class="line">					printf("up\n");</span><br><span class="line">					d = clk11 - meter02;</span><br><span class="line">					duty1=0x0000, duty2=0x1000;</span><br><span class="line">					duty3=0x0000, duty4=0x1000;</span><br><span class="line">					tot += d;</span><br><span class="line">					tot1 = 0;</span><br><span class="line">				&#125;</span><br><span class="line">				motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">				motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">				int rtime = (int)(d * k +  (tot + tot1) * j );//同上</span><br><span class="line">				if(rtime &lt;= 0) rtime = 0;</span><br><span class="line">				usleep(rtime);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;//只能前进,相对好控制一些</span><br><span class="line">			ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数</span><br><span class="line">			ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数</span><br><span class="line">			ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数</span><br><span class="line">			int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ;</span><br><span class="line">			printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000);</span><br><span class="line">			usleep(10000);</span><br><span class="line">			int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ;</span><br><span class="line">			printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000);</span><br><span class="line">			usleep(10000);</span><br><span class="line">			int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ;</span><br><span class="line">			printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000);</span><br><span class="line">			usleep(10000);</span><br><span class="line"></span><br><span class="line">			#define run for(p = 0;p &lt; 5;p++)</span><br><span class="line"></span><br><span class="line">			if (clk1 &lt;= clk &amp;&amp; clk1 &lt;= clk2)</span><br><span class="line">			&#123;</span><br><span class="line">				clk11 = clk1;</span><br><span class="line">			&#125;//don' rotate</span><br><span class="line">			else if(clk &lt;= clk1 &amp;&amp; clk &lt;= clk2)</span><br><span class="line">			&#123;</span><br><span class="line">				clk11 = clk;</span><br><span class="line">				run le();</span><br><span class="line">			&#125;//left rotate</span><br><span class="line">			else if(clk2 &lt;= clk &amp;&amp; clk2 &lt;= clk1)</span><br><span class="line">			&#123;</span><br><span class="line">				clk11 = clk2;</span><br><span class="line">				run ri();</span><br><span class="line">			&#125;//right rotate</span><br><span class="line">			//go go go</span><br><span class="line">			if(clk11 &gt; meter )</span><br><span class="line">			&#123;</span><br><span class="line">				tot = 0;</span><br><span class="line">				duty1=0x0000, duty2=0x0000;</span><br><span class="line">				duty3=0x0000, duty4=0x0000;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(clk11 &gt; meter02)</span><br><span class="line">			&#123;</span><br><span class="line">				printf("up\n");</span><br><span class="line">				d = clk11 - meter02;</span><br><span class="line">				duty1=0x0000, duty2=0x1000;</span><br><span class="line">				duty3=0x0000, duty4=0x1000;</span><br><span class="line">				tot += d;</span><br><span class="line">				tot1 = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			motor_setting(phase1,duty1,phase2,duty2,period,enable);</span><br><span class="line">			motor_setting1(phase3,duty3,phase4,duty4,period,enable);</span><br><span class="line">			int rtime = (int)(d * k +  tot  * j );</span><br><span class="line">			if(rtime &lt;= 0) rtime = 0;</span><br><span class="line">			usleep(rtime);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef task1 // hide somethingelse</span><br><span class="line">#define run for(p = 0;p &lt; 10;p++)</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数</span><br><span class="line">		ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数</span><br><span class="line">		int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ;</span><br><span class="line">		printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000);</span><br><span class="line">		usleep(10000);</span><br><span class="line">		int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ;</span><br><span class="line">		printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000);</span><br><span class="line">		usleep(10000);</span><br><span class="line">		int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ;</span><br><span class="line">		printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000);</span><br><span class="line">		usleep(10000);</span><br><span class="line"></span><br><span class="line">		//暴力枚举大法好= =(可惜忘了拍xiaoyi的列表...)</span><br><span class="line">		//每次做一件事就行..因为循环过来可以继续下一个任务.</span><br><span class="line">		if(ck(clk) &amp;&amp; ck(clk1) &amp;&amp; ck(clk2) )</span><br><span class="line">		&#123;</span><br><span class="line">			run up();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(ck(clk) &amp;&amp; ck(clk1) &amp;&amp; !ck(clk2))</span><br><span class="line">		&#123;</span><br><span class="line">			run le();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; ck(clk2))</span><br><span class="line">		&#123;</span><br><span class="line">			run down();</span><br><span class="line">			run ri();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; !ck(clk2))</span><br><span class="line">		&#123;</span><br><span class="line">			run le();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(!ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; !ck(clk2))</span><br><span class="line">		&#123;</span><br><span class="line">			run down();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(!ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; ck(clk2))</span><br><span class="line">		&#123;</span><br><span class="line">			run ri();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(!ck(clk) &amp;&amp; ck(clk1) &amp;&amp; !ck(clk2))</span><br><span class="line">		&#123;</span><br><span class="line">			run down();</span><br><span class="line">			run ri();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(!ck(clk) &amp;&amp; ck(clk1) &amp;&amp; ck(clk2))</span><br><span class="line">		&#123;</span><br><span class="line">			run ri();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		printf("%d\t %d\t %d\t %d\n",duty1,duty2,duty3,duty4);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void motor_setting(unsigned long phase1, unsigned long duty1,</span><br><span class="line">                   unsigned long phase2, unsigned long duty2,</span><br><span class="line">                   unsigned long period,unsigned long enable)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long * pwm_en= (unsigned long *)PWM_EN;</span><br><span class="line">    unsigned long * pwm_period=(unsigned long *)PWM_PERIOD;</span><br><span class="line">    unsigned long * pwm_phase1=(unsigned long *)PWM_PHASE1;</span><br><span class="line">    unsigned long * pwm_phase2=(unsigned long *)PWM_PHASE2;</span><br><span class="line">    unsigned long * pwm_duty1=(unsigned long *)PWM_DUTY1;</span><br><span class="line">    unsigned long * pwm_duty2=(unsigned long *)PWM_DUTY2;</span><br><span class="line"></span><br><span class="line">    * pwm_en=enable;</span><br><span class="line">    * pwm_period=period;</span><br><span class="line">    * pwm_phase1=phase1;</span><br><span class="line">    * pwm_phase2=phase2;</span><br><span class="line">    * pwm_duty1=duty1;</span><br><span class="line">    * pwm_duty2=duty2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void motor_setting1(unsigned long phase1, unsigned long duty1,</span><br><span class="line">                    unsigned long phase2, unsigned long duty2,</span><br><span class="line">                    unsigned long period,unsigned long enable)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long * pwm_en= (unsigned long *)PWM_EN1;</span><br><span class="line">    unsigned long * pwm_period=(unsigned long *)PWM_PERIOD1;</span><br><span class="line">    unsigned long * pwm_phase1=(unsigned long *)PWM_PHASE11;</span><br><span class="line">    unsigned long * pwm_phase2=(unsigned long *)PWM_PHASE21;</span><br><span class="line">    unsigned long * pwm_duty1=(unsigned long *)PWM_DUTY11;</span><br><span class="line">    unsigned long * pwm_duty2=(unsigned long *)PWM_DUTY21;</span><br><span class="line"></span><br><span class="line">    * pwm_en=enable;</span><br><span class="line">    * pwm_period=period;</span><br><span class="line">    * pwm_phase1=phase1;</span><br><span class="line">    * pwm_phase2=phase2;</span><br><span class="line">    * pwm_duty1=duty1;</span><br><span class="line">    * pwm_duty2=duty2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://radar-10050281.cos.myqcloud.com/img/run.gif" alt=""></p>
</div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GoodBye Big Algorithm Waterer]]></title>
      <url>http://renld.github.io/2016/07/03/Algor-Water/</url>
      <content type="html"><![CDATA[<p>有些东西,写下来或许才能放下</p>
<p>或才能重新拾起吧.</p>
<blockquote>
<p>一年匆匆入此坑</p>
<p>几经辉煌几近红</p>
<p>时去未能入校队</p>
<p>落得孤生水题多</p>
</blockquote>
<a id="more"></a>
<blockquote>
<blockquote>
<p>暑假看紫书白书算导来专题训练一下,弥补4+2的些许遗憾.</p>
<p>啊算导啊.那应该是我们算法界的圣经了.</p>
<p>许多人口中的渲染.似乎引起了对它的肃穆.</p>
</blockquote>
</blockquote>
<p>上了大学之后,才知道水题是那么的重要.比如有些学科好好刷掉一些题库之后,就很容易博得绩点满堂.以致于降低了大学绩点的吸引力.昨天和学妹吹水的时候.还在吹牛需要竞赛来维持一点智商.”吆喝”了一年的算法竞赛之路,似乎也在今天有了一个新的转角.4+2莫大的打击让我玩了几天html游戏设计(&lt;&lt;网页游戏开发秘笈&gt;&gt;,这是一本一章一个引擎教学的神书…..)然后今天水了一盘计蒜之道的复赛.看起来赚了一件衣服.于是又有点像记录一些东西,勉励之后的方向.</p>
<p>啊水题真的很重要.</p>
<h2 id="水题上百-手速不慢"><a href="#水题上百-手速不慢" class="headerlink" title="水题上百,手速不慢."></a>水题上百,手速不慢.</h2><p>上学期最开始的时候是郭老师上台宣讲”ACM算法竞赛”,抑或是晓铭老师说了一句”打的好可以去东校参加比赛”.当初就特别真诚的抱着去东校可以报销车费的美好欲望报名了ACM中珠集训队,当时还特别好奇这玩意为啥要宣传,福利挺棒的啊.</p>
<p>厚着老脸在上面一堆省赛一等奖的同学下面写上了自己的名字,每周二晚上与东校那边一起刷<code>vjudge</code>的SYSU系列.刘老师还一人送了一本书,我的是那本黑书.&lt;&lt;算法艺术与信息学竞赛&gt;&gt;书是好书.但是对于刚刚接触这方面的我而言,无异于葵花宝典.其实那一段时间的<code>vjudge</code>提高并不是很明显,因为跟着大腿的方向,并没有补题的习惯.而在算法讨论群里面的那些同学讨论着动归或数据结构,又想到一个TA对我说的话</p>
<blockquote>
<p>你最近还是先看一些容易的算法吧,动归以后再搞</p>
</blockquote>
<p>于是就没有补题的欲望,而对于那些计算几何之类”看起来听得懂”的题,就更没有补题的欲望了.这个不好的习惯囊括了之后的一次次短码之美月赛,考试等等.<strong>莫名自大</strong>的可怕,还是难以想象.</p>
<p>于是在短码之美的<a href="http://renld.github.io/2016/06/15/By-the-Year/">打击</a>下,(同时也是在<code>知乎</code>)的安利下,翻开了紫书.&lt;&lt;算法竞赛入门经典(第二版)&gt;&gt;,水了两三章之后这本书特别够意思的直接来<code>region</code>题,向TA问了几道题后,<strong>王芮浩</strong>师兄建议我先去看它的第一版.于是我转战第一版.其实更多的是看书,书看完了,UVA也才刷掉几道搜索的水题.</p>
<p>那个时候真的很拼啊.刷UVA的题动不动就四五个小时过去了.因为那儿的英文挺坑的,看过去少说一个小时过去了.而后理解题意之后宛如智障的瞎打一顿码,而后再去努力理解题解.最后看到一篇博客的一句话深有感触<strong>看题解是一个相对的事,如果实在很长时间做不出来,那么无妨一看</strong>(把这句或许得辩证的理解,但是我往往被坑去太多时间,以致于”事倍功半”).</p>
<p>当时特别励志的用这句话鼓舞自己</p>
<p>“刷题不过百,不是人傻就是懒”</p>
<p>第一个学期看着题解在UVA上敲了百题后就差不多到期末了.自大情绪又体现出来,于是水题很快很快(真的很快…)的刷完后,就被两道算法题卡住木讷到最后结束.不过也验证了这个小标题<strong>水题过百,手速不慢</strong>,然而由于vjudge里面过题太少.便没有赢得公费旅游的资格.但是这个阶段得到的最大教训却是另外一个.</p>
<p>因为装逼的需求.于是想要多学一些”算法知识”,于是从网上找了很多很多资料,买了良莠不齐的各种算法书,比如清华大学出版社的&lt;&lt;算法设计与分析&gt;&gt;教材.发现自己是多么稚嫩之外似乎大量的时间一无所获反而盲目满足.甚至有些书都未翻开过.不过最为可惜的莫过于在英语课和思修课上”学”算法,其实也不过看几道水题而已,反而糟蹋了老师的精心准备,愧对老师.</p>
<h2 id="高中起点-扬起新帆"><a href="#高中起点-扬起新帆" class="headerlink" title="高中起点,扬起新帆"></a>高中起点,扬起新帆</h2><p>寒假尝试了另外几条路之后就觉得<code>USACO</code>(美国高中的训练OJ)是一个不错的选择.有趣的一件事是上面总是CHI(中国)ip比美国多,于是其实这个学期刷题基本都在那上面,见证了一次次把自己以前刷的题归为水题的过程.略为可惜的是之后对于整理笔记的思考不足以体现其价值.而且到写这篇文章的时候也卡在了一道很难写的长程序上面.</p>
<p>开始写博客了之后记录也增多.相比上个学期,由于3月份开始比赛纷至沓来,这个学期其实更多的是去做题了.然而似乎算上比赛过的题也就是百来道,不过这些题的质量相对就高了一些,并不是盲目的模拟(虽然也很多题想了很久没想到算法..模拟过了的)刚开学的时候看(水)了数据结构与算法分析.它更大的用处在于解除我对很多”高级名词”的畏惧. &lt;&lt;数据结构与算法分析(C语言描述)&gt;&gt; 然而在4+2第一场赛后讨论中,被梓华提及的红黑树,以及他写的二叉+桶排给惊艳.于是明白了另一个道理</p>
<p>“没敲过代码的看书过程,意义实在有限”</p>
<p>三月份开始就是各种各样的比赛了,说实话就是一次又一次被惊艳.先是校赛预选赛,脑洞一开用hash优化了一个map的查询,(然而那时候还宣称map是hash结果天真的我..)给队伍贡献了一题.而后<a href="http://blog.csdn.net/qq_32209643/article/details/51476399" target="_blank" rel="external">百度之星</a>在初赛由于只过了水(相对而言)题于是无缘(拿)复(衣)赛(服),再然后省赛/校赛见识了脑洞对于算法的讲究.当时打浙江省赛木洪对于题目的直觉之间经验了我,特别是后来<a href="http://blog.csdn.net/qq_32209643/article/details/51347453" target="_blank" rel="external">省赛</a>两位队友脑洞强推公式简直可怕.于是那时候开始努力提高自己的脑洞水平.于是在<a href="http://blog.csdn.net/qq_32209643/article/details/51534684" target="_blank" rel="external">编程之美</a>里面很快的刷掉了两道脑洞题,当然不能掩饰被hack掉的事实.期末考试后便是4+2校队选拔赛.借了两本4+2的题解..简直打开了一个新的世界…….于是最开始的预期是很悲观的四场打铁,但是最后平均一场一题,也算不上过多遗憾,只能怪自己思维和视野的局限.再然后就是今天的计蒜之道复赛,认真刷好水题的我以倒数第三的位置进了复赛.顺便以倒数第三的拿衣服位置拿了衣服..</p>
<p>所以话说回来..水题还是很重要的.不过想要更上一层楼,得有更大的思考了.</p>
<h2 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h2><p>“别人口中”的水题,</p>
<p>建议搜索关键词有: <code>模拟</code>, <code>模板题</code>, <code>ACM数学题</code>  </p>
<h4 id="lt-lt-啊哈-算法-gt-gt"><a href="#lt-lt-啊哈-算法-gt-gt" class="headerlink" title="&lt;&lt;啊哈!算法&gt;&gt;"></a>&lt;&lt;啊哈!算法&gt;&gt;</h4><p>这本书应该才是真正的算法入门读物,网络上他的博客里面也有他对于基本算法的解释.当时搜排序搜到后就喜欢上了这种”幼儿园式”的教学方法.而且很期待第二版的出版.</p>
<p>建议搜索关键词有: <code>贪心</code>, <code>树状数组</code>, <code>并查集</code>  ,<code>高精度</code></p>
<p><strong>&lt;&lt;挑战程序设计&gt;&gt;/&lt;&lt;算法竞赛入门经典(第一版)&gt;&gt;/USACO题库</strong></p>
<p>这三个其实才算稍微入门了之后的一些选择,芮浩师兄借了我一本&lt;&lt;挑战程序设计&gt;&gt;,我翻了几页后自己买了一本,然而因为心分三用没有往后再扎实的看下去.&lt;&lt;入门经典&gt;&gt;第一版大概是我唯一看完的一本算法书吧.当时草草看完,因为看不懂的直接跳.现在看来其实也并没有那么难,只是一种莫名的畏惧或陌生吧..USACO题库我刷到最后一章暂停了下来,刷题的一些记录放在了<a href="http://blog.csdn.net/qq_32209643" target="_blank" rel="external">CSDN博客</a>上面.前面三章几乎都是些水题吧.因为重排了之后,后面几章便才开始讲基础的算法模板题.<a href="http://www.nocow.cn/index.php/USACO_Training" target="_blank" rel="external">nocow</a>上题解的帮助挺大的.因为简单题可以看到更漂亮的算法,难题可以明白大神的思维方式.</p>
<p>建议搜索关键词有: <code>网络流</code>, <code>动态规划</code>, <code>剪枝</code>    </p>
<p><strong>&lt; &lt; ACM国际大学生程序设计竞赛 &gt; &gt; 知识与入门 / 算法与实现</strong></p>
<p>第二本是常用的模板,在第一学期期中机考快速幂的时候知道的.但是这本模板给我最大的体验就是如果没练过,<code>相对坑度</code>比&lt;&lt;算法竞赛入门经典(训练指南)&gt;&gt;要大.另外缺少hash的函数处理模板.其实实际使用中若不是模板题这本书参考价值更多的是看个人,毕竟ACM允许纸质材料后,更多的考察抽象思维能力.&lt;&lt;知识与入门&gt;&gt;便是常见算法的讲解,讲的特别简明精要,优点是可以开拓眼界,缺点是没有证明部分,若没有基础看的会比较虚..相对难一些的比赛想要现学现用也是不大现实.<strong>另外其实安利自己从网上收集的模板,在<a href="http://renld.github.io/2016/06/19/%E8%BD%AF%E8%AE%BE%E4%B8%89%E5%A5%97%E5%8D%B7%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/">这篇文章</a>里面能找到</strong></p>
<p>建议搜索关键词有: <code>数据结构</code>, <code>图论</code> , <code>数论</code>    </p>
<p>大一结束,我大概也就停留在这个水平吧,之后也不好安利.或许小伙伴你愿意和我一起刷白书呢.</p>
<p>几近一年过去,160的车费补贴也算是实现了最初的梦想,当然离现在的理想还是有些许差距.</p>
<p>希望暑假加油完成专题训练.下学期算法比赛好好表现.不能再靠水题来混日子了.</p>
<h2 id="4-2感想-原4-2题解感想摘录"><a href="#4-2感想-原4-2题解感想摘录" class="headerlink" title="4+2感想(原4+2题解感想摘录)"></a>4+2感想(原4+2题解感想摘录)</h2><blockquote>
<p>伙食很好</p>
<p>讲题详细</p>
<p>难度迷人</p>
<p>补贴超多</p>
<p>公费旅游</p>
<p>五星好评</p>
</blockquote>
<h3 id="第一场打铁"><a href="#第一场打铁" class="headerlink" title="第一场打铁"></a>第一场打铁</h3><p>五个小时一题没有过的感觉还是很不好受的.</p>
<p>晚上思考了很久人生.觉得大一还是努力去见见世面吧.</p>
<p>但是大二的两个队友却都没空参赛了.sigh..真的有一些莫名的绝望.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>一段代码写烂一个小时后就得有重写的打算,不要老是”调”评测系统</li>
<li>一个代码超时如果尚有可回忆的方法,那么久一定要坚持复杂度.超时可能是写烂了而不是复杂度太高</li>
</ol>
<p>对于一个区间的动态维护首先应该想到线段树.</p>
<ul>
<li>线段树和优先队列的区别.</li>
<li>线段树是每次查询的时候更新,优先队列对于版本信息会较为混淆(不能及时剔除旧版本)</li>
</ul>
<h3 id="第二场迷之两题"><a href="#第二场迷之两题" class="headerlink" title="第二场迷之两题"></a>第二场迷之两题</h3><p>一上手看最后一题..写了半小时发现看错题了……..</p>
<p>但是还算是捡回了昨天的运气XD</p>
<ol>
<li>NIM博弈赢的方式是所有异或为0</li>
<li>统计四堆不如统计两堆.然后枚举后面两堆和前面两堆异或一样就可以了..</li>
</ol>
<p>BTW.今天晚霞挺美的.<br>生活还是要继续的:)</p>
<h3 id="第三场步入正轨"><a href="#第三场步入正轨" class="headerlink" title="第三场步入正轨"></a>第三场步入正轨</h3><p>今天来东校比赛..周围都是大腿光环:)</p>
<p>把两个实训队友落在珠海还是内心有一些愧疚的..不过下午看到做出来超级漂亮的板子.简直女神.</p>
<p>过了两题后学了两个小时算法..发现模板这种东西关键时刻还是比较鸡肋的.(顿时为期末模板写烂找好了借口).不过很有趣的是翻到了AC自动机的部分.然后认认真真看了一个小时(并没有看懂)恭喜少豪最后一秒钟提交通过233.</p>
<p>很开心的是郭老师过来说报销车费住宿费.公费旅游名不虚传233</p>
<p>话题步入正轨.这次比赛很难进校队了,但是从一定程度上已经扩宽了我的知识面.比如第三题AC自动机,第二题状态压缩以及第一场里面对于线段树的理解加深.也相对来说超过了最开始看4+2真题时候”可能打铁”的预期.与其说让我暑假放弃对于算法的训练,不如说方向更加明确了一些</p>
<h3 id="最后一场继续打铁"><a href="#最后一场继续打铁" class="headerlink" title="最后一场继续打铁"></a>最后一场继续打铁</h3><p>心还是很累..</p>
<p>今天完成第一次把电脑弄崩的成就…</p>
<p>毕竟我还是太嫩了..不过最为可惜的是,看到两个省赛队友都拒绝参赛,那大二的我也不知道会做出什么选择,或许移动大三的课比较水吧..</p>
<p>不过一题没过的最后一天,看到队友能把小车电焊部分做好,真是超级欣慰和感动</p>
<p>英语题..出题师兄越做越忍不住..不停加注释什么的终于破译了英语之谜</p>
<p><strong>论爆到英语大神重要性</strong> 来考考那么weed out是什么意思(微笑)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DP in Tree]]></title>
      <url>http://renld.github.io/2016/06/25/treeDP/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一开始学dfs的时候,觉得那就是递归了.</p>
<p>而后在第一学期期末机考的时候扑街在那道递归题目上,</p>
<p>寒假花了一个上午努力做出来,</p>
<p>兴奋之余并没有意识到其实那道题就有记忆化搜索的意味.</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>树形DP就是一个dfs+DP的特例,最开始想刷这个是源自于4+2参考书上一道题的完全没有看懂,于是觉得有必要去学一下,找到了下面这篇博客<a href="http://blog.csdn.net/woshi250hua/article/details/7644959" target="_blank" rel="external">刷题参考</a>然后埋头开刷, 大概期末考试断断续续一个星期, 刷了其中一些比较简单的题, 完全没有达到一开始4+2那题的难度.</p>
<p>东西都写在一个文档里面typora已经处理艰难,所以先将这篇文章发出来(刚刚发现是因为CF那道题的处理上发生了bug,删去了那段之后应该能愉快地继续使用了)</p>
<p>相对概括一些说,它需要找到一个节点和树上其它节点(或者边)之间的关系,然后进行一遍或者两边的搜索.</p>
<p>明天就是4+2了,与大家共勉</p>
</blockquote>
<h2 id="yali-漆子超论文笔记"><a href="#yali-漆子超论文笔记" class="headerlink" title="yali_漆子超论文笔记"></a>yali_漆子超论文笔记</h2><p>ps: 这里只有第一篇的题解.</p>
<ul>
<li><p>树的重心 <strong>删去后结点最多的树的个数最小</strong></p>
<ul>
<li><p>定理: 存在一个点使得分出来的子树的结点个数均不大于N/2</p>
</li>
<li><p>定理二: 如果一颗树中每个点的度<code>&lt;=D</code> 那么存在一条边使得分出来的两颗子树结点个数在$[\frac{N}{D+1},\frac{ND}{D+1}]$ =&gt; D为常数时基于边的分治递归最坏深度为<code>logN</code></p>
</li>
<li><blockquote>
<p>所谓重心，就是删掉此结点后，剩下的结点最多的树结点个数最小。</p>
<p>每次分治，我们首先算出重心，为了计算重心，需要进行两次dfs，第一次把以每个结点为根的子树大小求出来，第二次是从这些结点中找重心<br>其实POJ3107那里有重心的代码.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="poj-2342-Anniversary-party"><a href="#poj-2342-Anniversary-party" class="headerlink" title="poj 2342 Anniversary party"></a>poj 2342 Anniversary party</h2><p>不能选相邻的.记得<code>f[n][1] = max(f[m][0],f[m][1])</code>就可以</p>
<h2 id="poj2196-树上距离每个点最远距离"><a href="#poj2196-树上距离每个点最远距离" class="headerlink" title="poj2196 树上距离每个点最远距离"></a>poj2196 树上距离每个点最远距离</h2><p><strong>Input file contains multiple test cases</strong></p>
<ul>
<li><p><strong>核心思想(三种方法)</strong> : 两遍DFS</p>
</li>
<li><p>方法: 记录每棵树根往下最大和第二大,两遍dfs分别更新往下的max和往下的max</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> dep)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vis[v] = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[v][i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[u]) &#123;</span><br><span class="line">            dfs(u,dep+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> nt = dp[u][<span class="number">0</span>] + e[v][i].len;</span><br><span class="line">            <span class="keyword">if</span> (nt &gt; dp[v][<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[v][<span class="number">1</span>] = nt;</span><br><span class="line">                <span class="keyword">if</span> (nt &gt; dp[v][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[v][<span class="number">1</span>] = dp[v][<span class="number">0</span>];</span><br><span class="line">                    dp[v][<span class="number">0</span>] = nt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//保留最大和第二大的子树最远节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vis[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[v][i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[u]) &#123;</span><br><span class="line">        <span class="comment">//一个树上最远的节点,要么是两个最远的子树节点,要么是最远兄弟节点+1</span></span><br><span class="line">            <span class="keyword">if</span> (dp[v][<span class="number">0</span>] == dp[u][<span class="number">0</span>] + e[v][i].len) &#123;</span><br><span class="line">                dp[u][<span class="number">2</span>] = max(dp[v][<span class="number">2</span>], dp[v][<span class="number">1</span>]) + e[v][i].len;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                dp[u][<span class="number">2</span>] = max(dp[v][<span class="number">2</span>], dp[v][<span class="number">0</span>]) + e[v][i].len;</span><br><span class="line">            dfs1(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p><a href="http://www.cnblogs.com/wally/p/3311768.html" target="_blank" rel="external">方法2</a></p>
<blockquote>
<p>首先任意一次dfs求出树上最长直径的一个端点End,然后以该端点为起点再次dfs求出另一个端点，然后再次以求出的另一个端点为起点dfs,每次做dfs的时候都更新dist[]（dist[u]表示u到树上任意节点的最远距离），可以证明树上任意某个节点到树上任意节点的最远距离的端点一定会是树上直径的两个端点之一。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> fa,<span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; max_len) </span><br><span class="line">       End = v,max_len = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[v][i].to,w = len + e[v][i].len;</span><br><span class="line">        <span class="keyword">if</span> (nt != fa) &#123;</span><br><span class="line">            dfs(nt, v, w);</span><br><span class="line">            dp[nt] = max(dp[nt],w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//v是当前节点,len是到现在节点的距离,dp[nt]表示的是现在点最远的子树距离</span></span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);     <span class="comment">//第一遍随意扫一遍,知道一个直径端点</span></span><br><span class="line">dfs(End, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//第二遍从一个端点开始扫一遍,知道另一个端点</span></span><br><span class="line">dfs(End, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//用另一个端点更新每个点的最远距离(前面两次也有更新)</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>(A了,没注意多重数据)自己不能理解为啥错了(有可能是写崩了)的方法_留在这里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> dep)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    vis[v] = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[v][i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[u]) &#123;</span><br><span class="line">            dfs(u,dep+<span class="number">1</span>);</span><br><span class="line">            update(dp[v][<span class="number">0</span>],dp[u][<span class="number">0</span>] + e[v][i].len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//只记录往下的最大值  dp[i][0]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[v][i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[u] == vis[v] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> oth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; e[v].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = e[v][j].to;</span><br><span class="line">                <span class="keyword">if</span> (vis[p] == vis[u] &amp;&amp; p != u) &#123;</span><br><span class="line">                    update(oth, e[v][j].len + dp[p][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="number">1</span>)</span><br><span class="line">                update(oth, dp[v][<span class="number">1</span>]);</span><br><span class="line">            dp[u][<span class="number">1</span>] = oth + e[v][i].len;</span><br><span class="line">            dfs1(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//然后枚举     dp[i][1] = max(1.父节点向上 2.父到兄弟 + 兄向下) +到父亲距离</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>##CF219D 求根集</p>
<blockquote>
<p>题目是给一张边有向的树形图。要选出首都的点，首都要都能走到其他点，因此要反转一些边的方向。问可以选哪几个点作为首都，使它们所需反转边的数量最少。</p>
</blockquote>
<p><a href="http://www.cnblogs.com/WABoss/p/5267944.html" target="_blank" rel="external">O(n)两遍DFS</a></p>
<ul>
<li>将要翻转的边赋值为1,不需要的边赋值为0,就是统计了</li>
<li>一遍向下统计以该节点为根的变化量</li>
<li>一遍向上统计它往上走的变化量</li>
</ul>
<ul>
<li>最后求和</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs0(v,u);</span><br><span class="line">        d[<span class="number">0</span>][u]+=d[<span class="number">0</span>][v]+edge[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//by 题解博客</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;fr,<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[v][i];</span><br><span class="line">        <span class="keyword">if</span> (u != fr) &#123;</span><br><span class="line">            dp[u][<span class="number">1</span>] = dp[v][<span class="number">1</span>] + dp[v][<span class="number">0</span>] - dp[u][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">   		<span class="comment">//父节点向上 + 父节点向下 - 当前节点向下 + 当前边反向的差 </span></span><br><span class="line">            dfs1(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; re[v].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = re[v][i];</span><br><span class="line">        <span class="keyword">if</span> (u != fr) &#123;</span><br><span class="line">            dp[u][<span class="number">1</span>] = dp[v][<span class="number">1</span>] + dp[v][<span class="number">0</span>] - dp[u][<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            dfs1(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//向上DP</span></span><br></pre></td></tr></table></figure>
<p><strong>DP思想: 有向图两边同时展开,看利用情况</strong></p>
<h2 id="POJ1741"><a href="#POJ1741" class="headerlink" title="POJ1741"></a>POJ1741</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt; j) <span class="comment">//经典  </span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">while</span>(dis[i] + dis[j] &gt; k &amp;&amp; i &lt; j) j--;  </span><br><span class="line">        ret += j - i;  </span><br><span class="line">    i++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="期末附加题"><a href="#期末附加题" class="headerlink" title="期末附加题"></a>期末附加题</h2><ul>
<li>给一棵树,问能不能两两节点配对完</li>
</ul>
<ul>
<li>完整代码见<a href="http://renld.github.io/2016/06/19/%E8%BD%AF%E8%AE%BE%E4%B8%89%E5%A5%97%E5%8D%B7%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/">另一篇博客</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"><span class="keyword">int</span> paired[maxn];<span class="comment">//存储是否配对成功</span></span><br><span class="line"><span class="keyword">int</span> n,a,b,flag;<span class="comment">//个数,两个临时变量,YES</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> pos,<span class="keyword">const</span> <span class="keyword">int</span> fa)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//错误状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[pos].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[pos][i];</span><br><span class="line">        <span class="keyword">if</span> (nt != fa) &#123;</span><br><span class="line">            dfs(nt, pos);<span class="comment">//测试下一个配对情况</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (paired[pos] == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa &lt; <span class="number">0</span> || paired[fa] == <span class="number">1</span> ) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;<span class="comment">//已经被配对,出现错误状态</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            paired[fa] = paired[pos] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POJ1155-背包i-最多节点"><a href="#POJ1155-背包i-最多节点" class="headerlink" title="POJ1155 背包i 最多节点"></a>POJ1155 背包i 最多节点</h2><p>给一颗树,叶节点是客户,其它所有是中转站,求不亏损的情况下的最多客户</p>
<p><a href="http://blog.csdn.net/libin56842/article/details/9908199" target="_blank" rel="external">第一个树形背包参考</a></p>
<p>对于每一个节点的子节点向上进行优化</p>
<p>这道题而言,就是每完成一次对于子节点的递归之后就回来优化根节点的状态</p>
<ol>
<li>状态定义为dp[i][j]表示第i个节点得到j个顾客的时候的最大获益</li>
<li>num数组优化剪枝</li>
<li>防错temp数组(存前)</li>
<li>初始化的时候因为有负数,将<ol>
<li>dp[i][0] = 0</li>
<li>dp[i][1] = (i &gt; n + m)?val : -inf (因为后面的是有价值节点)</li>
<li>dp[i][oth] = -inf</li>
<li>num[i] = 0</li>
</ol>
</li>
</ol>
<ul>
<li>关键代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[pos].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[pos][i].t,ct = e[pos][i].w;<span class="comment">//下一个节点以及花费</span></span><br><span class="line">        dfs(nt);</span><br><span class="line">        <span class="built_in">memcpy</span>(temp, dp[pos], <span class="keyword">sizeof</span>(dp[pos]));<span class="comment">//保存当前的值,防止背包使用更改的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nums[pos] ; j++) &#123;<span class="comment">//父节点已有情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= nums[nt]; k++) &#123;<span class="comment">//子节点已有情况</span></span><br><span class="line">                update(dp[pos][k+j],</span><br><span class="line">                       temp[j] + dp[nt][k] - ct);<span class="comment">//背包,看子节点的k个顾客能否优化父节点sum-k=j个的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[pos] += nums[nt];<span class="comment">//优化搜索空间,保存当前最多搜索的东西</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="comment">//最后输出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i&gt;=<span class="number">0</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">1</span>][i] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-1011-1561-背包ii-取父才取子"><a href="#HDU-1011-1561-背包ii-取父才取子" class="headerlink" title="HDU 1011_1561 背包ii 取父才取子"></a>HDU 1011_1561 背包ii 取父才取子</h2><p>1011给一颗树,每个节点都有花费和获得</p>
<p>想要拿子节点的东西必须先拿父节点的</p>
<p>1561较难抽象成树,但更好解决 (是1011的一个cost == 1特例)</p>
<ul>
<li><p>注意在m=0的时候输出0,不然会挂?==</p>
</li>
<li><p>关键代码分析(1011)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">const</span> <span class="keyword">int</span> fa)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">//这里dp的状态是,不少于i个的时候能获得的量,那么初始化就是把cost后的都赋值为earn</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = bugs[pos]; j &lt;= m; j++)</span><br><span class="line">        dp[pos][j] = posi[pos];<span class="comment">//posi[pos]就是当前节点能获得的量(下面就不用搜以上了)</span></span><br><span class="line">  <span class="comment">//利用子树进行背包优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[pos].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[pos][i];</span><br><span class="line">        <span class="keyword">if</span>(nt == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(nt, pos);</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//从大到小背包,防止重复(因为是往上dp所以这样不会) </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= bugs[pos]; j--)</span><br><span class="line">          	<span class="comment">//父节点花费(bugs[pos],而且已经获得了posi[pos](最开始的赋值..))</span></span><br><span class="line">          	<span class="comment">//所以不能取到 j - bugs[pos] 以上,  	</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j - bugs[pos]; k++) </span><br><span class="line">              	update(dp[pos][j],dp[nt][k] + dp[pos][j-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="POJ1974-背包iii"><a href="#POJ1974-背包iii" class="headerlink" title="POJ1974 背包iii"></a>POJ1974 背包iii</h2><p>给一颗树,求最少删去多少条边能得到大小为p的子树</p>
<p>一开始思路不知道挂在哪里了,三遍dfs把自己搞晕</p>
<p><a href="http://www.2cto.com/kf/201503/381184.html" target="_blank" rel="external">参考</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn][maxn];<span class="comment">//以a为根size为b的最小子树删边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;chi[maxn],fa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*只遍历一次,因为是一棵树,所以对于每个节点的处理只有一次</span><br><span class="line">	1. 初始化,对于每个节点所有size都是不可以到达的,inf</span><br><span class="line">	2. size为1是子树本身,0</span><br><span class="line">	3. 对于每一个子树节点,有两种选择</span><br><span class="line">		a. 割去子树节点,也就是 b == 0 当前 = dp[p][a] + 1;</span><br><span class="line">		b. 不割去子树,用子树size更新 也就是 b != 0 的时候,用dp[p][a-b] + dp[nt][b]更新dp[p][a]</span><br><span class="line">	4. 由于对当前dp没有后效性,所以不需要temp数组</span><br><span class="line">	5. 然后最后在dfs外层扫一遍所有的P节点删去数,如果不是根节点,需要+1(因为删上面)</span><br><span class="line">	6. 好像发现自己懵逼在哪了......因为它只能保留子树,所以兄弟似乎不影响...往下看就行</span><br><span class="line">	*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  	fill(dp[p], dp[p] + maxn, inf);</span><br><span class="line">    dp[p][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chi[p].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = chi[p][i];</span><br><span class="line">        solve(nt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = N; a &gt;= <span class="number">1</span>; a--) <span class="comment">//被更新的size</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; a; b++) <span class="comment">//子树size</span></span><br><span class="line">                <span class="keyword">if</span> (b) </span><br><span class="line">                    update(dp[p][a], dp[p][a-b] + dp[nt][b]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[p][a] = dp[p][a] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU3586-切断根与叶子最小边权"><a href="#HDU3586-切断根与叶子最小边权" class="headerlink" title="HDU3586,切断根与叶子最小边权"></a>HDU3586,切断根与叶子最小边权</h2><p>给每一条边边权,求切断根和所有叶子的最小花费</p>
<p>哦对了,所有删去边权的和&lt;m</p>
<p>.</p>
<h3 id="为啥DP"><a href="#为啥DP" class="headerlink" title="为啥DP"></a>为啥DP</h3><p>一开始瞄了一眼别人题解..想了很久都没明白一些人题解里面干嘛要背包……</p>
<p>然后就直接二分强行做dfs了..WA了几发之后发现弄混淆了两个概念</p>
<ol>
<li>删去该节点的和</li>
<li>删去该节点的最小边权</li>
</ol>
<p>于是折腾了一会后发现,只有记忆化搜索才能优化</p>
<p>但是记忆化太麻烦了,不如开一个dp数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> mp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e[pos].empty()) dp[pos] = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[pos].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[pos][i].to,ct = e[pos][i].ct;</span><br><span class="line">        dfs(nt, mp);</span><br><span class="line">        <span class="keyword">if</span> (ct &gt; mp) &#123;</span><br><span class="line">            dp[pos] += dp[nt];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            dp[pos] += min(dp[nt],ct);<span class="comment">//当前边权可以与子树边权共同优化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//dp[i]是i为根cost</span></span><br></pre></td></tr></table></figure>
<h3 id="为啥二分"><a href="#为啥二分" class="headerlink" title="为啥二分"></a>为啥二分</h3><p>二分的原因是,这玩意是一个&lt;m存在性问题,那么符合单调性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">         <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">         <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));  </span><br><span class="line">         dfs(<span class="number">1</span>, mid);</span><br><span class="line">         <span class="keyword">if</span> (dp[<span class="number">1</span>] &lt;= m) &#123;</span><br><span class="line">             ans = mid;</span><br><span class="line">             r = mid - <span class="number">1</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span></span><br><span class="line">             l = mid + <span class="number">1</span>;</span><br><span class="line">     &#125;<span class="comment">//对于整数的二分模板.</span></span><br></pre></td></tr></table></figure>
<h2 id="POJ3107-树的重心"><a href="#POJ3107-树的重心" class="headerlink" title="POJ3107 树的重心"></a>POJ3107 树的重心</h2><p>重心就是使得 (最大的子树) 最小的根</p>
<p>O(n)的算法是假设第一个点为根<br>dfs统计每棵树的子树大小.</p>
<p>然后那个点最大的子树就是$max(n - sub - 1,max(sub))$<br>这道题挺无聊的在于..坑vector/deque,<br>参考网上代码发现,得写邻接表才能避免TLE</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,mt;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn],tot[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> edge&#123;</span><br><span class="line">    <span class="keyword">int</span> to,nt;</span><br><span class="line">&#125;e[maxn * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>,head[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn],pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update1</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &lt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    e[size].to = v;</span><br><span class="line">    e[size].nt = head[u];</span><br><span class="line">    head[u] = size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p,<span class="keyword">const</span> <span class="keyword">int</span> &amp;fa)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    tot[p] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[p]; i != <span class="number">-1</span>; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(nt == fa) <span class="keyword">continue</span>;</span><br><span class="line">        tot[p] += dfs(nt, p);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] = n - tot[p];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[p]; i != <span class="number">-1</span>; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[i].to;</span><br><span class="line">        update(cnt[p], tot[nt]);</span><br><span class="line">    &#125;</span><br><span class="line">    update1(mt, cnt[p]);</span><br><span class="line">    <span class="keyword">return</span> tot[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[EEreview]]></title>
      <url>http://renld.github.io/2016/06/25/EEreview/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这大抵是学过第一门,让我觉得大学不那么水的课吧.</p>
<p>​                      — 在四级作文里面这般描述</p>
</blockquote>
<a id="more"></a>
<p>来移动的第一个学期,最直观的感觉是绩点特别容易刷高(第二学期专业4.6),而后课相对较”水”,于是开始盘算转院的想法.因为对于IT人而言,最难受的,莫过于发现自己没有学到很扎实的东西吧.相比软工的模拟卷,我们的卷子总会简单一个层次,相比他们的教学内容,我们也总会显得”现代化”一些,但也相对似乎学到的东西少了那么一些.只能以”反正这些基础知识抓牢最重要”的想法,认可我们院的培养方案.</p>
<p>然而这一想法,是在遇见&lt;&lt;电子与电路技术&gt;&gt;这门课之前.</p>
<p>第一节课保老师就跟我们说,上一届师兄师姐很不争气的在期末考试没有得到漂亮的成绩,问师姐也是”TA努力找分然而还是无可奈何”,直到考试前我也觉得我们院的卷子应该比考前刷过的那几套软院的卷子简单的不可置否心理,然而考卷出来后发现并不如之前所想.这大概是电工带来的一些惊喜吧.毕竟总要有一些东西来拿来”炫耀”XD.</p>
<p>说实在的,这学期电工学的很努力,却显得很费力.周四电工课在一节外教课之后,难免犯困,周五也临近周末,难免有所轻松情绪.每节课与老师有很长时间的眼神交流,依旧会走神.而在电工课上走神的效果,大概可以类比那个”为什么学不好数学,是因为小学上数学课橡皮掉了”的笑话.最重要的是发现,前面几章扫了一遍PPT后,课上走神的那几分钟能补回来.但是最后几章做作业的时候,都是在套公式,”照葫芦画瓢”,终于在最后一章里面的作业上把作业”挂”了.</p>
<p>当时TA特别恳切地写下了这样一段话,我拍照留了下来</p>
<blockquote>
<p>平时都很不错,怎么这次这样,是不是自己没有理解清楚?</p>
<p>回去参考同学或PPT的吧.</p>
</blockquote>
<p>当时真的面色绯红地对自己有些沮丧.因为真的很努力去学了,却只有事倍功半的结果.(后来检查这章作业是因为莫名其妙的分析错误.)于是时间也快到考试周了,于是开始查漏补缺,但对套了一个月公式的我而言更像是开天辟地.不愿意在死坑在英文里面于是翻开了中文教材,尽管里面有很多细节错误,但是瑕不掩瑜的为我展开了一个新的世界.期末复习的时候每一章中文对应着记录英文笔记,相对”高效”的得到了其中的”奥义”.于是在考试周开始前整理完试卷,准备好了迎接.尽管周四前发现笔记又经历了一遍忘却,但是对于电工的重新学习是功不可没的,想起保老师曾经说的一句话:</p>
<blockquote>
<p>电工还是很重要的,不要因为英文而学不好电工.</p>
</blockquote>
<p>电子技术的另一方面是电工实验,因为对于高中物理实验”对实验结果与预期符合”的苛求,曾有一些心理阴影.这个学期跟电工实验也算是较上了劲.保老师曾经一句”课前两小时,课中两小时,课后两小时”曾把我们一惊,但是实际我一个学期的电工实验却是基本每次都要重新再来一次实验室完成实验,课后的总结也至少四五个小时.以致于把它称作了”电工project”.当然这样也得到了TA的肯定,期末将我报告收去.也算是一些惊喜.如此”费力”的电工实验中,当仁不让地学会了proteus对电路的模拟,而后对实际实验进行对比分析,学会了matlab/excel对于数据的处理,做出相对漂亮的图像和拟合分析.这是高中顽固的理论所不能及的.</p>
<p>开学写的电工预期文藻很漂亮,而这篇报告是在凌晨四点一个嘈杂环境下写下.但是还想在最后反思一下为什么学的那么”吃力”.(希望能因此收获别人所不能收获的收获吧).尽管我们没有师弟师妹了,但是对于自己的大二的硬件方面学习应该有参考意义.</p>
<ol>
<li>课前缺乏预习,导致课上”难免的”走神打击是致命性的.而后就”两眼懵逼”地上过一节课.其实大多数时候都是在上课弄清楚了老师到底讲了一些什么,但是不消半个星期忘却的结局,还是挺令人郁闷的.归根结底其实是因为自己没有理解,或者说没有弄清关系式是怎么来的,跟着老师走了一遍,自己<strong>就像</strong>会推了一般.</li>
<li>仍然习惯于凭借自己智商和搜索引擎解决问题的思维习惯,然而在电子技术上,教材才是王道.教材所对知识点的讲解归纳是搜索引擎所无法媲美的.而这样思维习惯最直接的后果是,看起来学会了,但是并没有构架起真正对于思维的理解.这也是软工和电工之间的区别,软工的直接目的便是直接使用,很多时候搜索引擎能直接高效的解决问题,但是电工是一门专业性极强的学科,很多时候难以凭借”民科”解决问题.</li>
<li>没有正确的使用教材.因为这学期分配给算法的时间较多,于是电工的英文教材看看停停,但是对于外文教材看看停停大抵是大忌.因为很多单词一开始看了后面就忘了,而对于阅读中的”似曾相识”的单词往往会糊弄过去.以致于期末复习前对于整本教材是一知半解.</li>
<li>电工毕竟是一门理工科,而不是通过”套公式”糊弄过去的学科.所以电工其实培养的是一种理性思维,一个较为有逻辑的思维体系.做期末考试题的时候,觉得有一些像高中物理的竞赛题,但是只要”强行” 用KCL, KVL推理,还是可以解决的问题.毕竟理科更多的是对于扎实逻辑思维掌握运用的考察,而不是对于”跳跃思维”,也就是”套公式”记忆力的评判.</li>
<li>这一点不算教训吧.就是对于电工实验以及以后很多的实验课,还是要踏实而且”创新”地去尝试,去做好,就像保老师所说,万一那异常数据,成了以后重大的实验发现呢.其实另一方面我觉得更重要的是,这样的学习下,大概能成为一个理工男,扎实诚恳的精神面貌,或许就是这些扎实科目的练习下,能培养的能力吧.</li>
<li><p>最后一节实验课,保老师指出”两个10kΩ不一样,你是可以用下面的100Ω的滑动变阻器补偿成一样”的思维方式,毕竟我们上大学,不应该只是走一套套模板,过一场场考试,毕竟我们的方向,不仅是把实验做成功,更是用自己的力量,努力把事情做得更加漂亮.</p>
<p><img src="/img/ee.jpg" alt=""></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[块状链表]]></title>
      <url>http://renld.github.io/2016/06/20/part_list/</url>
      <content type="html"><![CDATA[<blockquote>
<p>用途是用$O(\sqrt{n})$的方式线段计算(线段树是二分$O(logN)$)</p>
<p>是不是和莫队很像2333</p>
</blockquote>
<a id="more"></a>
<ul>
<li>相当于(数组+链表)</li>
</ul>
<ul>
<li>网站part</li>
</ul>
<blockquote>
<p><strong>基本操作</strong>：</p>
<p>（1）定位：先定位元素所在的链表节点，然后再定位该元素在数组中的位置。</p>
<p>（2）分裂：将某个链表节点分裂成两个节点。</p>
<p>（3）插入：首先定位要插入的位置，然后将所在节点分裂成两个节点，并将数据放到第一个节点的末尾。 如果要插入的是一大块数据，首先要将数据切成多个block（每个block对应一个块状链表的一个节点）并将这些block链起来，然后将它们插入那两个节点之间。</p>
<p><strong>关键点和复杂度分析</strong></p>
<p>该算法的核心是确定链表长度和每个节点的数组长度，以及怎么保证这个长度值？设块状链表中元素总个数为X，链表长度为n，每个节点中数据长度为m，则当m=n=sqrt(X)时，可保证m和n同时最小，此时各种操作的时间复杂度最低。在实际应用时，需维持块状链表的每个节点大小在[sqrt(n)/2, 2*sqrt(n)]，否则，块状链表会退化。维护方法是，适当的时候，对节点进行合并与分裂（维护本身不会使复杂度增加）</p>
</blockquote>
<ul>
<li>论文part</li>
</ul>
<blockquote>
<p>而且块状链表非常好扩展，只要是序列操作，比如：统一赋值，翻转，求和，维护最小值等等，都可以使用块状链表得到<img src="file://localhost/Users/macbook/Library/Group%20Containers/UBF8T346G9.Office/msoclip1/01/clip_image002.gif" alt="img">的复杂度，而如果将整个块状链表维护成有序的，它甚至可以实现平衡树的一些操作<a href="#_ftn1">[1]</a>，毕竟平衡树也可以看作是一种维护序列的方法。</p>
<p>又因为块状链表只在每个分块记录一些额外信息，它的空间利用率很高，而同是模拟方法的Splay需要在每个节点上维护全部额外信息，虽然速度比较快，却占用大量内存<a href="#_ftn2">[2]</a>。</p>
<p>其实，在日常生活中我们经常会用到块状链表：传统的FAT文件系统就是将磁盘扇区分簇，然后用FAT表(FileAllocation Table 文件分配表)来记录每一个簇的状态：是否损坏，是否被使用，如果被使用那么它的下一个簇是哪一个簇。可见，FAT文件系统的思想和块状链表是一致的。</p>
<p>而且因为块状链表空间利用率很高，分块的结构又能很方便的和缓冲区结合使用，Vim<a href="#_ftn3">[3]</a>也使用了块状链表，在内存的存储和在磁盘上的缓冲都使用了类似块状链表的结构<a href="#_ftn4">[4]</a>。试想如果用Splay去写一个文本编辑器会是多么复杂而抽象，它又如何方便地利用缓冲区，一旦发生崩溃、断电等意外事件，又如何从磁盘缓冲中重构树结构、恢复数据？</p>
<p>另外，已经有人在g++的<ext rope="">库中写了一个基本的块状链表模板：__gnu_cxx::rope<t, alloc="">，也就是说，使用C++的同学可以很方便的得到一个现成的块状链表<a href="#_ftn5">[5]</a>。</t,></ext></p>
<hr>
<p><a href="#_ftnref1">[1]</a> 我用块状链表做NOI2006happybirthday，略微比我写的SBT短一些，可以过8个点（第8个点接近时限）。</p>
<p><a href="#_ftnref2">[2]</a> 利用Splay可以把模拟操作的复杂度降到<img src="file://localhost/Users/macbook/Library/Group%20Containers/UBF8T346G9.Office/msoclip1/01/clip_image004.gif" alt="img">（其实这也是空间换时间的例子：线段树、Splay维护的额外信息多，空间占用大，但是速度也快），关于Splay的讨论可以参考2007年余江伟的集训队论文《如何解决好动态统计问题》，2004年杨思雨的集训队论文《伸展树的基本操作与应用》。</p>
<p><a href="#_ftnref3">[3]</a> Vi IMproved，应该算是很有名了吧。</p>
<p><a href="#_ftnref4">[4]</a> 就像BramMoolenaar所说：A texteditor is used all day by many people; it is worth investing time and effort inmaking it work well. Vim使用的数据结构很复杂，但是原理和块状链表是相似的。</p>
<p><a href="#_ftnref5">[5]</a> <a href="http://www.sgi.com/tech/stl/Rope.html" target="_blank" rel="external">http://www.sgi.com/tech/stl/Rope.html</a>上有一份rope<t, alloc="">的文档。</t,></p>
</blockquote>
<h2 id="例程-4-2-07"><a href="#例程-4-2-07" class="headerlink" title="例程 4+2   07"></a>例程 <em>4+2</em>   07</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxc 1000000		<span class="comment">//数列的最大长度</span></span></span><br><span class="line"><span class="keyword">int</span> C;						<span class="comment">//数列的长度</span></span><br><span class="line"><span class="keyword">int</span> val[maxc];				<span class="comment">//数列中的每个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> NODE &#123;				<span class="comment">//每个元素为链表中的一个节点</span></span><br><span class="line">	<span class="keyword">int</span> next;				<span class="comment">//链表的下一节点</span></span><br><span class="line">	<span class="keyword">int</span> jump;				<span class="comment">//链表的下sqrt(N)个节点</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> sum;			<span class="comment">//链表中以这个节点开始的连续sqrt(N)个节点的和</span></span><br><span class="line">&#125;;</span><br><span class="line">NODE <span class="built_in">list</span>[maxc];				<span class="comment">//链表的每个节点</span></span><br><span class="line"><span class="keyword">struct</span> LIST &#123;					<span class="comment">//连续段</span></span><br><span class="line">	<span class="keyword">int</span> head;					<span class="comment">//连续段的起点</span></span><br><span class="line">	<span class="keyword">int</span> len;					<span class="comment">//连续段的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> J;							<span class="comment">//保存sqrt(N)的值</span></span><br><span class="line">LIST l;							<span class="comment">//整个链表看作一个连续段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;					<span class="comment">//初始化函数</span></span><br><span class="line">	J = <span class="built_in">sqrt</span>(C);				<span class="comment">//计算sqrt(N)的值</span></span><br><span class="line">	<span class="keyword">if</span> (J&lt;<span class="number">1</span>) J=<span class="number">1</span>;				<span class="comment">//最少为1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;C;i++)&#123;			<span class="comment">//初始化链表</span></span><br><span class="line">		<span class="comment">//链表的下一元素指针</span></span><br><span class="line">		<span class="keyword">if</span>(i&lt;C<span class="number">-1</span>) <span class="built_in">list</span>[i].next=i+<span class="number">1</span>; <span class="keyword">else</span> <span class="built_in">list</span>[i].next=<span class="number">-1</span>;</span><br><span class="line">		<span class="comment">//链表的下J元素指针	</span></span><br><span class="line">		<span class="keyword">if</span>(i&lt;=C-J) <span class="built_in">list</span>[i].jump=i+J; <span class="keyword">else</span> <span class="built_in">list</span>[i].jump=<span class="number">-1</span>; </span><br><span class="line">		<span class="built_in">list</span>[i].sum = <span class="number">0</span>;		<span class="comment">//清空和为0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>,k=<span class="number">0</span>;i&lt;J;i++)k+=val[i];	<span class="comment">//计算前J项和</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;C-J;i++)&#123;				<span class="comment">//计算每个数之后的连续J项和</span></span><br><span class="line">		<span class="built_in">list</span>[i].sum = k;</span><br><span class="line">		<span class="comment">//从前一个连续J项和，减去第一项，加上最后一项，得到新的连续J项和</span></span><br><span class="line">		k = k - val[i] + val[i+J];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>[i].sum = k;</span><br><span class="line"></span><br><span class="line">	l.head = <span class="number">0</span>;						<span class="comment">//初始连续段的起点</span></span><br><span class="line">	l.len = C;						<span class="comment">//初始连续段的长段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlocate</span><span class="params">(LIST l, <span class="keyword">int</span> t)</span> 		<span class="comment">//求连续段的第t个元素的位置</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;<span class="number">0</span> || t&gt;=l.len) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//输入位置不合法</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	i = l.head;</span><br><span class="line">	<span class="keyword">while</span>(t&gt;=J)&#123;					<span class="comment">//还有超过J个元素</span></span><br><span class="line">		i = <span class="built_in">list</span>[i].jump;			<span class="comment">//直接跳过J个元素</span></span><br><span class="line">		t -= J;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;						<span class="comment">//不超过J个元素</span></span><br><span class="line">		i = <span class="built_in">list</span>[i].next;			<span class="comment">//超过1个元素</span></span><br><span class="line">		t --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;						<span class="comment">//返加元素所在位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LIST <span class="title">merge</span><span class="params">(LIST a, LIST b)</span></span>&#123;			<span class="comment">//数列合并</span></span><br><span class="line">	<span class="keyword">if</span>(a.len==<span class="number">0</span>) <span class="keyword">return</span> b;			<span class="comment">//a数列为空时返回b数列</span></span><br><span class="line">	<span class="keyword">if</span>(b.len==<span class="number">0</span>) <span class="keyword">return</span> a;			<span class="comment">//b数列为空时返回a数列</span></span><br><span class="line">	<span class="keyword">int</span> ha, hb, ia, ib, i,j;</span><br><span class="line"></span><br><span class="line">	i = getlocate(a, a.len<span class="number">-1</span>);		<span class="comment">//找到a数列最后一个元素</span></span><br><span class="line">	<span class="built_in">list</span>[i].next = b.head;			<span class="comment">//指向b数列的第一个元素</span></span><br><span class="line">	LIST re;re.head=a.head, re.len=a.len+b.len;	<span class="comment">//合并后的数列</span></span><br><span class="line">	<span class="keyword">if</span>(re.len&lt;J) <span class="keyword">return</span> re;			<span class="comment">//数列长度小于J，则不需要改变指针和连续段和</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(a.len&lt;J)&#123;					<span class="comment">//a的长度小于J，则改变指针要从a的第一个元素开始</span></span><br><span class="line">		ia = <span class="number">0</span>;						<span class="comment">//a的第一个元素</span></span><br><span class="line">		ib = J-a.len;				<span class="comment">//对应的J个元素后所在的位置</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">//a的长度不小于J</span></span><br><span class="line">		ia = a.len - J;				<span class="comment">//从a的倒数第J个元素开始</span></span><br><span class="line">		ib = <span class="number">0</span>;						<span class="comment">//从b的第一个元素开始</span></span><br><span class="line">	&#125;</span><br><span class="line">	ha = getlocate(a, ia);			<span class="comment">//求出第一个元素所在位置</span></span><br><span class="line">	hb = getlocate(b, ib);			<span class="comment">//求出最后一个元素所在位置</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">									<span class="comment">//连续J个元素的和</span></span><br><span class="line">	<span class="keyword">for</span>(i=k=<span class="number">0</span>,j=ha;i&lt;J;i++,j=<span class="built_in">list</span>[j].next) k+=val[j]; </span><br><span class="line">	<span class="keyword">while</span>(ia&lt;a.len &amp;&amp; ib&lt;=b.len)&#123;	<span class="comment">//枚举所有需要改变的节点</span></span><br><span class="line">		<span class="built_in">list</span>[ha].jump = hb;			<span class="comment">//修改跳过J个元素的指针</span></span><br><span class="line">		<span class="built_in">list</span>[ha].sum = k;			<span class="comment">//修改连续J个元素的和</span></span><br><span class="line">		k -= val[ha];				<span class="comment">//减去第一个元素</span></span><br><span class="line">		<span class="keyword">if</span>(hb!=<span class="number">-1</span>) k += val[hb];	<span class="comment">//加上最后一个元素</span></span><br><span class="line">		ha = <span class="built_in">list</span>[ha].next;			<span class="comment">//第一个元素的下一节点</span></span><br><span class="line">		hb = <span class="built_in">list</span>[hb].next;			<span class="comment">//最后一个元素的下一节点</span></span><br><span class="line">		ia++, ib++;					<span class="comment">//下一个连续J个元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> re;						<span class="comment">//返回合并后的数列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> sa, <span class="keyword">int</span> sb, <span class="keyword">int</span> np)</span></span>&#123;	<span class="comment">//移动一段连续数列</span></span><br><span class="line">	<span class="keyword">int</span> leftpartlen;				<span class="comment">//左边部分的元素个数</span></span><br><span class="line">	<span class="keyword">if</span>(np&lt;sa)leftpartlen=np+<span class="number">1</span>;		<span class="comment">//移动段在插入位置的右边</span></span><br><span class="line">	<span class="keyword">else</span> leftpartlen=np+<span class="number">1</span>-(sb-sa+<span class="number">1</span>);<span class="comment">//移动段在插入位置的左边</span></span><br><span class="line"></span><br><span class="line">	LIST left, mid, right;			<span class="comment">//初始段分成三段</span></span><br><span class="line">	left.head = l.head;				<span class="comment">//左段的起始位置</span></span><br><span class="line">	left.len = sa;					<span class="comment">//左段的长度</span></span><br><span class="line">	mid.head = getlocate(l, sa);	<span class="comment">//中段的起始位置</span></span><br><span class="line">	mid.len = sb-sa+<span class="number">1</span>;				<span class="comment">//中段的长度</span></span><br><span class="line">	right.head = getlocate(l, sb+<span class="number">1</span>);<span class="comment">//右段的起始位置</span></span><br><span class="line">	right.len = C-sb<span class="number">-1</span>;				<span class="comment">//右段的长度</span></span><br><span class="line">	l = merge(left, right);			<span class="comment">//合并左右段</span></span><br><span class="line">	<span class="comment">//在插入位置分成两段</span></span><br><span class="line">	left.head = l.head;				<span class="comment">//左段起始位置</span></span><br><span class="line">	left.len = leftpartlen;			<span class="comment">//左段长度</span></span><br><span class="line">	right.head = getlocate(l, leftpartlen);<span class="comment">//右段起始位置</span></span><br><span class="line">	right.len = l.len - leftpartlen;<span class="comment">//右段长度</span></span><br><span class="line">	l = merge(left, mid);			<span class="comment">//合并左段和中段</span></span><br><span class="line">	l = merge(l, right);			<span class="comment">//合并右段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> sa, <span class="keyword">int</span> sb)</span></span>&#123;			<span class="comment">//求连续段的和</span></span><br><span class="line">	<span class="keyword">int</span> i,t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;				<span class="comment">//初始化和为0</span></span><br><span class="line">	i = getlocate(l,sa);			<span class="comment">//起始元素位置</span></span><br><span class="line">	t = sb-sa+<span class="number">1</span>;					<span class="comment">//连续段长度</span></span><br><span class="line">	<span class="keyword">while</span>(t&gt;=J)&#123;					<span class="comment">//超过J个元素</span></span><br><span class="line">		ans += <span class="built_in">list</span>[i].sum;			<span class="comment">//一次累加连续J个元素的和</span></span><br><span class="line">		i = <span class="built_in">list</span>[i].jump;			<span class="comment">//跳过J个元素</span></span><br><span class="line">		t -= J;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;						<span class="comment">//不足J个元素</span></span><br><span class="line">		ans += val[i];				<span class="comment">//累加一个元素</span></span><br><span class="line">		i = <span class="built_in">list</span>[i].next;			<span class="comment">//跳过一个元素</span></span><br><span class="line">		t --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);			<span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cs;	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cs);				<span class="comment">//输入数据组数</span></span><br><span class="line">	<span class="keyword">while</span>(cs--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;C);				<span class="comment">//输入数列长度</span></span><br><span class="line">		<span class="keyword">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;C;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);	<span class="comment">//输入每个元素</span></span><br><span class="line">		init();						<span class="comment">//初始化</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> S, sa, sb, np;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;S);				<span class="comment">//输入操作数</span></span><br><span class="line">		<span class="keyword">char</span> st[<span class="number">30</span>];</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;S;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,st);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(st,<span class="string">"Move"</span>)==<span class="number">0</span>)&#123;<span class="comment">//如果是移动操作</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;sa,&amp;sb,&amp;np);</span><br><span class="line">				sa--,sb--,np--;</span><br><span class="line">				move(sa,sb,np);		<span class="comment">//调用移动操作函数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(st,<span class="string">"Sum"</span>)==<span class="number">0</span>)&#123;<span class="comment">//如果是求和操作</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;sa,&amp;sb);</span><br><span class="line">				sa--,sb--;</span><br><span class="line">				sum(sa,sb);			<span class="comment">//调用求和操作函数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料</p>
<ul>
<li>中山大学程序设计竞赛(中山大学内部选拔赛) 真题解(一)</li>
</ul>
<ul>
<li><strong>对块状链表的一点研究</strong>  <em>苏煜</em></li>
</ul>
<ul>
<li><a href="http://dongxicheng.org/structure/blocklink/" target="_blank" rel="external">网上的资料</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SDII_FUN]]></title>
      <url>http://renld.github.io/2016/06/19/sdii/</url>
      <content type="html"><![CDATA[<ul>
<li>期末三套卷部分题解</li>
<li>sdii 模板</li>
<li>期末<ul>
<li>机考附加题(图论算法/贪心)</li>
<li>笔试笔记</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="期末考试三套模拟卷"><a href="#期末考试三套模拟卷" class="headerlink" title="期末考试三套模拟卷"></a>期末考试三套模拟卷</h1><ul>
<li>12计科T2,9,14,error</li>
<li>09软工T4,T7</li>
<li>10软工T3,T6</li>
</ul>
<ul>
<li>记不清题号的笔记</li>
<li>顺便作<strong>答疑帖</strong>0.0有问题可以在下方留言</li>
</ul>
<h3 id="12计科"><a href="#12计科" class="headerlink" title="12计科"></a>12计科</h3><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><blockquote>
<p>Which of the following about constructor is not correct?</p>
<p>B) Copy constructor will not be created by the compiler if a default constructor is defined.</p>
<p>D) A class has at least two constructors.</p>
</blockquote>
<p>参考资料: <a href="http://stackoverflow.com/questions/15590832/conditions-under-which-compiler-will-not-define-implicits-constructor-destruct" target="_blank" rel="external">(B)</a>(又如拷贝构造函数会覆盖默认,认为D也正确)</p>
<p><strong>复杂理论</strong></p>
<p> <a href="http://en.cppreference.com/w/cpp/language/copy_constructor" target="_blank" rel="external"><strong>The Copy Constructor</strong></a> will not be implicitly generated if</p>
<ul>
<li>you have explicitly <em>declared</em> a copy constructor (for class <code>X</code> a constructor taking <code>X</code>, <code>X&amp;</code> or <code>const X&amp;</code> )</li>
<li>there is a member in your class that is not copy-constructible <strong>(such as a class with no or inaccessible copy constructor)</strong></li>
<li>(C++11) you have explicitly told the compiler to not generate one using <code>A(const A&amp;) = delete;</code></li>
</ul>
<p><a href="http://en.cppreference.com/w/cpp/language/default_constructor" target="_blank" rel="external"><strong>The Default Constuctor</strong></a> will not be implicitly generated if</p>
<ul>
<li>you have explicitly <em>declared</em> any constructor at all</li>
<li>There is a member in your class that is not default-constructible <strong>(such as a reference, a const object, or a class with no or inaccessible default constructor)</strong></li>
<li>(C++11) you have explicitly told the compiler to not generate one using <code>A() = delete;</code></li>
</ul>
<ul>
<li>B: 因为定义了一个默认构造,如果不是 taking <code>X</code>, <code>X&amp;</code> or <code>const X&amp;</code> 那么编译器还是会隐式实现</li>
<li>D: 尽管按照上面讲的不能被隐式实现,但还是要求被显式实现</li>
<li>另外这是12年的卷子= = 应该不包括C++11特性</li>
</ul>
<p><strong>简明题解</strong> : 就是反正compiler会给搞一个default constructor 一个copy constructor</p>
<h4 id="T9"><a href="#T9" class="headerlink" title="T9"></a>T9</h4><blockquote>
<p>With the base class and its inherited class, which of the following statement has a compilation error? </p>
<p>A) Base * base = Inherited();</p>
<p>C) Base base = Inherited();</p>
</blockquote>
<ul>
<li>A <strong>对象不能初始化指针</strong></li>
<li>另外 <code>Base * base = &amp;Inherited();</code>也是错的,因为不能把<code>const</code>强转成<code>非const</code><ul>
<li>也就是说<code>类名(参数)</code>这样直接声明的对象是<code>const</code></li>
</ul>
</li>
</ul>
<h4 id="T14"><a href="#T14" class="headerlink" title="T14"></a>T14</h4><p>C++中，通过<a href="http://baike.baidu.com/subview/535539/535539.htm" target="_blank" rel="external">基类</a>的引用或指针调用<a href="http://baike.baidu.com/subview/161302/161302.htm" target="_blank" rel="external">虚函数</a>时，发生动态绑定。</p>
<h4 id="Error-Find"><a href="#Error-Find" class="headerlink" title="Error Find"></a>Error Find</h4><ol>
<li><p>普通对象也可以调用<code>static</code>函数</p>
</li>
<li><p><code>variable</code>, <code>static function</code> cannot be virtual</p>
</li>
<li><p><code>static function</code> cannot be const</p>
</li>
<li><p>类声明完成后需要加’;’</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>delete</code>不是new 出来的空间会<code>RE</code>,</p>
</li>
<li><p><code>=0</code>纯虚不能被<code>=false</code>代替</p>
</li>
<li><p>抽象类不能被实例化<strong>(在子类里面)不能 声明一个虚基类对象 Base(1)</strong></p>
</li>
<li><p>不能<code>delete</code>reference</p>
</li>
<li><p>不是<code>static</code> 不能在类外 <code>class::fun()</code>调用</p>
</li>
<li><p>add完<code>char[]</code>后最后一位补<code>0</code></p>
</li>
<li><p>重载了<code>(char *)</code>≠重载<code>(const char *)</code></p>
</li>
</ol>
<h3 id="09软工"><a href="#09软工" class="headerlink" title="09软工"></a>09软工</h3><p>(观察代码题)</p>
<h4 id="T4虚继承"><a href="#T4虚继承" class="headerlink" title="T4虚继承"></a>T4虚继承</h4><ul>
<li>这道题中是虚继承,所以只生成一次A的拷贝</li>
</ul>
<p>(下面解析代码来自wiki)</p>
<blockquote>
<p>假如类<em>A</em>和类<em>B</em>各自从类<em>X</em>派生（非虚继承且假设类X包含一些数据成员），且类<em>C</em>同时<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" target="_blank" rel="external">多继承</a>自类<em>A</em>和<em>B</em>，那么<em>C</em>的对象就会拥有两套<em>X</em>的实例数据（可分别独立访问，一般要用适当的消歧义限定符）。但是如果类<em>A</em>与<em>B**</em>各自<em>*虚继承了类</em>X<em>，那么</em>C<em>的对象就只包含一套类</em>X*的实例数据。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Mammal : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WingedAnimal : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bat is a winged mammal</span></span><br><span class="line"><span class="keyword">class</span> Bat : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> WingedAnimal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//爷爷类指针调用</span></span><br><span class="line">Bat b;</span><br><span class="line">Animal &amp;mammal = <span class="keyword">static_cast</span>&lt;Mammal&amp;&gt; (b); </span><br><span class="line">Animal &amp;winged = <span class="keyword">static_cast</span>&lt;WingedAnimal&amp;&gt; (b);</span><br></pre></td></tr></table></figure>
<p>为了正确的调用<code>eat()</code>，还需要相同的可以消歧义的语句：<code>static_cast(bat).eat()</code>或<code>static_cast(bat).eat()</code>.</p>
<h4 id="T7注意是每次插入起始位置"><a href="#T7注意是每次插入起始位置" class="headerlink" title="T7注意是每次插入起始位置"></a>T7注意是每次插入起始位置</h4><h3 id="10软工"><a href="#10软工" class="headerlink" title="10软工"></a>10软工</h3><h4 id="T3-reference"><a href="#T3-reference" class="headerlink" title="T3 reference"></a>T3 reference</h4><p><a href="https://en.wikipedia.org/wiki/Reference_(C%2B%2B" target="_blank" rel="external">维基百科说的很清楚</a>),大意是reference是一个封装的更加安全(指针派生)的pointer</p>
<h4 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h4><p><code>sizeof(classname)</code>不包括<code>static</code>大小</p>
<h4 id="电脑没电后的笔记"><a href="#电脑没电后的笔记" class="headerlink" title="电脑没电后的笔记"></a>电脑没电后的笔记</h4><ol>
<li><p>调用一堆初始化函数后初始化时从右到左</p>
</li>
<li><p>static函数是父类和子类共用的</p>
</li>
<li><p><a href="https://alau.top/blog/index.php/2016/06/19/pointer-of-devived-class-base-class/" target="_blank" rel="external">三金关于01010的博客</a></p>
<ol>
<li><p>主要思想是因为是base指针,它++的步长也就是base的大小</p>
</li>
<li><p>另外Post-increment (<code>++</code>) has higher precedence than dereference (<code>*</code>).</p>
<blockquote>
<p>When you increment a <code>T*</code>, it moves <code>sizeof(T)</code> bytes.† This is because it doesn’t make sense to move any other value: if I’m pointing at an <code>int</code> that’s 4 bytes in size, for example, what would incrementing less than 4 leave me with? A partial <code>int</code> mixed with some other data: nonsensical.</p>
<p>–<a href="http://stackoverflow.com/questions/5610298/why-does-int-pointer-increment-by-4-rather-than-1" target="_blank" rel="external">stackoverflow</a></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h1 id="软件设计II模板"><a href="#软件设计II模板" class="headerlink" title="软件设计II模板"></a>软件设计II模板</h1><blockquote>
<p><a href="https://github.com/renld/SMIE_Software-Design-II/archive/master.zip" target="_blank" rel="external">点击这里下载压缩包</a></p>
<p>文件说明:</p>
<p><strong>6.11</strong>为软设模板,基本能符合类的设计需要</p>
<p><strong>STL学习笔记</strong>为下一篇日志的pdf可打印版本,里面是对STL重要容器算法的模板</p>
<p><strong>ACM模板</strong>是我花了一定精力从网上收集的很多算法模板,应大家需求共享出来</p>
<p>(不过这样会增加一定的流量费用)</p>
<p><strong>sdii/CPP文件夹</strong>内有一些函数库的cplusplus主页和软设模板的md源文件,可以自行修改</p>
<p><a href="https://github.com/renld/SMIE_Software-Design-II" target="_blank" rel="external">点击这里进入项目主页</a>愿意为我star的当然欢迎XDD<br>有疑问和建议联系这个邮箱<br>leidar100@gmail.com</p>
</blockquote>
<h1 id="期末"><a href="#期末" class="headerlink" title="期末"></a>期末</h1><h2 id="期末附加题"><a href="#期末附加题" class="headerlink" title="期末附加题"></a>期末附加题</h2><ul>
<li>给一棵树,问能不能两两节点配对完</li>
<li><a href="http://soj.sysu.edu.cn/show_problem.php?pid=1003&amp;cid=2342" target="_blank" rel="external">链接</a>,题号18381,直接主页submit</li>
</ul>
<h3 id="AC的方法"><a href="#AC的方法" class="headerlink" title="AC的方法"></a>AC的方法</h3><ul>
<li>优先队列-镓伟</li>
<li>n是奇数 non是偶数 原来的树如果有一个点连着多于1个1度点 no否则 yes —颂恒</li>
<li>直接bfs..不需要堆优化-诗源</li>
<li>dfs -leida</li>
</ul>
<ul>
<li>考试的时候最后三分钟才意识到树形DP…</li>
<li>下面这段代码不一定能过=_=理论AC吧XD(已经AC)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"><span class="keyword">int</span> paired[maxn];<span class="comment">//存储是否配对成功</span></span><br><span class="line"><span class="keyword">int</span> n,a,b,flag;<span class="comment">//个数,两个临时变量,YES</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> pos,<span class="keyword">const</span> <span class="keyword">int</span> fa)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//错误状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[pos].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nt = e[pos][i];</span><br><span class="line">        <span class="keyword">if</span> (nt != fa) &#123;</span><br><span class="line">            dfs(nt, pos);<span class="comment">//测试下一个配对情况</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (paired[pos] == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa &lt; <span class="number">0</span> || paired[fa] == <span class="number">1</span> ) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;<span class="comment">//已经被配对</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            paired[fa] = paired[pos] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//没有被子树的节点需要配对</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            e[i].clear();</span><br><span class="line">            paired[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">            e[a].push_back(b);</span><br><span class="line">            e[b].push_back(a);</span><br><span class="line">        &#125;<span class="comment">//加入边</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;<span class="comment">//剪枝</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">-1</span>);<span class="comment">//树</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><ul>
<li>这次的难度相比上次真的体现出我大移动的光彩(其实也发现了电工理论是要做题,但是软设理论却除了考试外从未做过题的缺憾.)</li>
</ul>
<ol>
<li><p>最后的选择题</p>
<blockquote>
<p>交换的是指针,i和j并没有变化</p>
<p>然后这个不是传引用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A &amp; a,A &amp; b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    A temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>,y = <span class="number">2</span>;</span><br><span class="line">    A a,b;</span><br><span class="line">    a.m = &amp;x,b.m = &amp;y;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a.m &lt;&lt; <span class="string">" "</span> &lt;&lt; *b.m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//希望考试时候不要弄反顺序了= =</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>vector的erase</p>
<p>erase一个迭代器的时候是删除临时副本,迭代器后移</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    vec.push_back(<span class="number">1</span>);</span><br><span class="line">    vec.push_back(<span class="number">2</span>);</span><br><span class="line">    vec.push_back(<span class="number">2</span>);</span><br><span class="line">    vec.push_back(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vec.begin(); it != vec.end(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">            vec.erase(it);</span><br><span class="line">            it--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>异常类的析构顺序</p>
<p><code>xcode</code>的显示是<code>++--!—</code>(有毒,希望看到这里的小伙伴能run一下)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"+"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B kk;</span><br><span class="line">    <span class="keyword">throw</span> kk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        B k;</span><br><span class="line">        func();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"!"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后题意莫名的<code>:</code></p>
<p>不要提前交卷!!!!!!否则<code>真·眼瞎</code>还是很可怕的!!!!!!!!</p>
</li>
<li><p>总结:</p>
<p>这次考的并不是很难,<code>virtual</code>还有<code>hint</code>,主要是没有摸索出一套科学的<code>学习</code>方法,而是在用<code>工程</code>的思想去学习,这也无可厚非吧.</p>
<p>另外考完后不要打开软设群,不要刷朋友圈,有毒:)</p>
<p>​</p>
</li>
</ol>
<h1 id="三金留下的足迹"><a href="#三金留下的足迹" class="headerlink" title="三金留下的足迹"></a>三金留下的足迹</h1><ul>
<li>前面几篇文章中三金都写下了或多或少的一些文字,很是感激</li>
<li>但因为整理缘故只能在renld.duoshuo.com看到.现在记录在下面</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">因为https的原因有些资源换访问错误</span><br><span class="line"></span><br><span class="line">建议吧所有连接包括http://...和https://...都改成//...</span><br><span class="line"></span><br><span class="line">多说居然会吞掉带有代码的评论</span><br><span class="line"></span><br><span class="line">此评论用户状态为：【一般用户】；ip地址：【<span class="number">58.67</span><span class="number">.136</span><span class="number">.214</span>】；用户uid为：【<span class="number">6294806818413609730</span>】</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>月<span class="number">19</span>日 发表于 期末机考最后一题 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mixed Content: The page at <span class="string">'https://renld.github.io/2016/06/13/STL-LEARN/#more'</span> was loaded over HTTPS, but requested an insecure script <span class="string">'http://v3.jiathis.com/code/jia.js?uid=1405949716054953'</span>. This request has been blocked; the content must be served over HTTPS.</span><br><span class="line"></span><br><span class="line">/<span class="number">2016</span>/<span class="number">06</span>/<span class="number">13</span>/STL-LEARN/<span class="comment">#more:1 Mixed Content: The page at 'https://renld.github.io/2016/06/13/STL-LEARN/#more' was loaded over HTTPS, but requested an insecure script 'http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js'. This request has been blocked; the content must be served over HTTPS.</span></span><br><span class="line"></span><br><span class="line">main.js:<span class="number">1</span> Uncaught ReferenceError: require <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line">/<span class="number">2016</span>/<span class="number">06</span>/<span class="number">13</span>/STL-LEARN/<span class="comment">#more:1 Mixed Content: The page at 'https://renld.github.io/2016/06/13/STL-LEARN/#more' was loaded over HTTPS, but requested an insecure script 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'. This request has been blocked; the content must be served over HTTPS.</span></span><br><span class="line"></span><br><span class="line">出错了，github默认支持https，的把那些资源url全都改成自动识别协议吧</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line"></span><br><span class="line">http://a.com</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">https://a.com</span><br><span class="line"></span><br><span class="line">都改成</span><br><span class="line"></span><br><span class="line">//a.com</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>月<span class="number">19</span>日 发表于 期末机考最后一题</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[By The Year]]></title>
      <url>http://renld.github.io/2016/06/15/By-the-Year/</url>
      <content type="html"><![CDATA[<blockquote>
<p>大一的尾声.</p>
<p>不知少年少女,你们可过的还好吗.</p>
<p>大抵曾经那个诗歌相衬的少年,已经在这一年变了模样.</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    大抵这是高考过后一个星期,去年这时的少年,应该是最怅然若失的吧.幸好当时还是班长,幸好当时还有很多事情要收拾.看着一摞摞书或是捐给了学弟学妹,或是当做了几十块钱卖给收废品的老妪.也没有什么怅然,选了几本看起来最值得怀念的书留在家中.然而也就留在那了.</p>
<p>​    高三似乎过得挺有趣的,大抵那时候开始把人生目标设为努力去变成一个有趣的人.好像买了很多很多的书,然后翻的多一些看的少一些吧.这个习惯到大一上学期依旧维持着.高三和邓合租在学校算是一个有趣的point吧.来这边后发现广东的学生都没有租房子的现象.突然想起易老板曾猜测的一句话</p>
<blockquote>
<p>雅礼这么好的成绩,或许是补课补出来的</p>
</blockquote>
<p>​    或许是公立学制之外的努力,才把一所所名校变得这么强大的.然而高三的我终于结束了四年的补习班生涯,混了那么久,耳濡目染之下跟同学讲题也像要板有眼的了.似乎很有趣,也似乎很伤感.到大学之后发现大家一段段精彩的课余生活能力,有的少年会弹吉他,琴弦一拨气质就上来了.于是寒假本来准备学一点琴弦的.但是不知为何作罢.就像大一刚刚开学还跟小航学了一点舞蹈一样,不了了之.</p>
<p>​    想想最后可能让他失望了吧.高三第二个学期的伊始,他”严肃”地更我说.你要努力考上清华北大啊.我当时也只是笑了一笑.到最后估分<code>640</code>是把理综估到<code>270</code>的水准.然而因为物理的最后一题脑洞开大了一点.老师也似乎一分都没给.数学练了一年的压轴题因为考前情绪的突然激动.一道接着一道的扑街.</p>
<p>​    上了大学之后不知道为何和别人聊着聊着就会聊回高考.大抵还只记得那是一段<code>金戈岁月</code>.五天前学弟学妹高考,也不知道考得怎样.但是希望他们过完这一站之后,能变得更加成熟地向前追求吧.回忆起当年考作文的时候,    拿起笔写起了高三一年未动过的文言,用时超出了自己的意料,慌张之中还用白话写了一句对仗,试后发现有些追悔莫及.但无论如何,语文救了我一把,把我捧上了中大这个舞台.</p>
<p>​    出分数前当时和伙伴去四川玩了一圈.那时候开始接触”冒菜”这个名词,开始知道抄手和水饺.开始呼吸一个地方的文化空气.来珠海后,吃了很多冒菜,也去过几次餐馆.味道比那儿清淡太多.就像<code>去国还乡</code>的情怀,离开了楚地之后,才开始炫耀那儿的香辣.</p>
<p>​    </p>
<p>​    高三暑假的印象,似乎有那么一些重要的人和事.大可组织了别墅party真是辛苦她了.好像当时从高考的碌碌中爬出来,我又陷入了选专业的碌碌.水了很久知乎买了一本书.看着大家你一眼我一语的评论.当时也没有朱彦樵做的<a href="http://yali.sxkdz.org/" target="_blank" rel="external">YaliUp</a>于是也就大致明白了自己以后不会做什么.又或许是高考后的空虚,觉得哪门专业的事儿多哪门就有趣.似乎现在也算如愿以偿.只记得当时看果壳的时候一句话很动容我,记在这儿</p>
<blockquote>
<p>​    总之，泼了一大堆凉水，说了一大堆生物专业如何如何悲剧，目的主要是给那些对生物专业充满了不切实际幻想的热血青年当头棒喝。但是，如果你一开始就知道这些还选了生物的话，那么我想你将和我一样永不后悔，和各种瓶瓶罐罐植物动物微生物打交道的乐趣，你试过才知道。May the force be with you，buddy.</p>
</blockquote>
<p>​    所以在志愿咨询会的时候,问老师,会不会被调剂到”生物专业”的志愿.当时只有中大的老师回了我一句,”中大的生物可好了”.不过这也不是当时报中大的理由吧.来中大,来移动其实更多的只是一场邂逅而已.当初甚至不知道中大有四个校区.甚至不知道有珠海.大概这个地名本随着高二的学考地理离我远去了吧.只是画画一般,在北上广各画了一所学校,画画一般,在中大随机圈定了几个专业.</p>
<blockquote>
<p>各种落榜或许是机缘巧合</p>
<p>或许是一阵忧伤中的另一次邂逅</p>
</blockquote>
<p>​    在健身房收到父亲的短信,几天后看到自己志愿落在了中大,被移动录取,发现移动在珠海.然后就匆匆的,开始准备行程,顺便努力去做暑假作业= =毕竟,当年的中大,可是有小学期的呐.与挚友再次一聚,当做给最先去上学的少年的送别宴吧.那次也算是第一次看橘子洲头的烟花,可美了.</p>
<p>​    中珠,旅游景点一般.深居唐家小镇,每次进程都是半小时以上的公交.对于一些闲适的学院而言,或许倍感无聊吧.然而这一年,一个初入CS行当的少年而言.应该算是充实了罢.当时站在门外时,道听途说的可能只有”C语言”了罢.于是暑假就似乎看了几集<code>java</code>,就像寒假看的<code>Python</code>没有再用过,当然也就忘得比学的还快.所以现在也不急着去学那些高大上的语言.或许也是因为井底之蛙的实现,看不到更大向前的方向吧.</p>
<p>​    军训而后就开始专业学习的生涯.似乎大一上学期比高三还要忙碌和刻苦,似乎成了古南永口中的”想把大学当做职业技术培训学校大有人在”的人了.军训把C语言看完了之后自信满满的参加了当时的<code>短码之美</code>,立刻被各路OIer们当头棒喝,自那开始发现了原来还有一个名词叫<code>算法</code>.于是买了紫书白书黑书,查了知乎百度谷歌,搜了无数资料下在本地之后,踌躇满志的…刷起了水题.把紫书水题刷的差不多后.和当时的TA师兄聊天,他说</p>
<blockquote>
<p>不能老是沉迷在刷水题的快感之中.</p>
</blockquote>
<p>​    所以知道期末考试,都不知道自己当时其实有多水.其中和章鱼,任萌一起参加了新手赛,作为移动大一第一的罚时拿了一个二等奖后,就更加自我膨胀了,于是期末那个星期居然就没碰过代码..期末快速的水完了所有水题之后,就对剩下两道算法题一筹莫展了.于是rk也一直下掉.能留下编程之美的参赛权,大概也是一种幸运吧.</p>
<p>​    大一上学期的自我膨胀,真是可怕至极.觉得努力了一定要有收获,就为了<code>虚荣</code>而去努力,甚至放下了很多有意思的东西.参加了集训队了之后.发现那些大牛们都没有赛后改题的习惯,居然自己也草草了之.就像跟很多人聊的那样<code>我刷UVA的时候,都是看一个小时题,懵逼一个小时</code>然后再去看别人代码.当时看了别人代码又没有学习下来.跟着大牛一起装逼.以致于<strong>事倍功半</strong>.大抵是上天眷顾了一下我的运气,最后一次<code>短码之美</code>的月赛,拿了两本书离去,也不算太过遗憾.</p>
<p>​    </p>
<blockquote>
<p>那段日子,可真是刻苦啊</p>
<p>每天沉浸在图书馆中,迎接第一缕晨曦与最后一道送别铃声</p>
</blockquote>
<p>​    大一上学期学院的主要目标大概是想培养我们专业的一种情怀吧.当初不知线代的重要居然一题没有刷就节课了,苏宁大大还给了一个特别漂亮的成绩.单片机玩的时候那可是装逼啊,买了锯子电焊铁各种各样的模块后,各种拍照发朋友圈,<strong>“好像真的变成了一个工程师”</strong>一样.最后做了一个闹钟出来,似乎还是有一点点遗憾.不过TA给了满分,还是倍感荣幸.</p>
<p>​    寒假去sicily把lxm老师布置的编程题刷了几十道后,便开始了USACO的路途.不过到了下学期,人就似乎变得更加浮躁.也似乎变得突然有了方向.去YouTube看完了<code>40min学会java</code>,<code>70min学会c++</code>,<code>30min学会java</code>,<code>15min学会html</code>系列,发现这种一个小时学的东西,最多也就两个小时,可以忘掉一干二净.立下flag这学期好好学大英,不过这个flag也是一拖再拖.直到上个星期,聊到一半突然被鼓励了一下下,终于拿起暑假买的四级书.开始刷起了听力.</p>
<p>​    </p>
<p>​    不过大一下学期和上学期最大的不同大概就是心态了吧.</p>
<p>​    上学期<strong>像是</strong>把自己全身心投入算法中区,思修课看算法,大英课看算法.其实也没学到什么真材实料,反而相对而言错过了上学期最为认真的两位老师.遗憾之余这个学期每一节近代史都特别认真的去听沈成飞讲故事,大英也尝试坐在前排,放下手机了.</p>
<p>​    四月初算是度过了第一个春天.真的,长沙根本体会不到春风十里的舒畅.春风拂面的怡人.</p>
<p>​    五月因为省赛去了几次广州,看到了回迁之后的一些展望,也和朋友浪了一圈…中大= =.</p>
<p>​    上学期因为自我膨胀.每节课坐着最后一排.不过大家都知道,做最后一排难免会打开手机.而这学期努力坐在第一排,尽管电工课做第一排和老师保持1/3时间眼神交流还是能走神.</p>
<p>​    说起电工,保老师可以说是大学到现在为止最为认真的一个老师了吧.也大概让我觉得,第一次开始觉得,或许我也还是需要那种有一点点闲适的心情.他第一节课除了自我介绍,得知他和我爸居然是一个专业毕业的之外,还记得去年师兄师姐三成及格率的难度,于是便立志学好电工</p>
<p>​    再而后记得他讲了一些期许.而后便是充实的电工课了.因为前半个学期一直读的英文教材,对于知识点也是磕磕碰碰的仿照例题过去.不过除了理论之外,更有趣的应该是电工实验了吧…而我应该也让TA和实验室老师留下了印象.因为总是需要下周一再来补全漏下的实验部分.而后话很大力气完成实验报告.</p>
<blockquote>
<p>同学们的实验,应该课前两个小时的预习,课中做两个小时,课后至少花两个小时整理</p>
</blockquote>
<p>​    似乎很长的预期,然而对我而言总是要花两三倍,甚至四五倍的时间,才能实现保老师的实验要求.不过上个星期得知自己的实验报告,被选出来存档,也的确有一些小确幸.</p>
<p>​    四月校赛吧,当时被硕轩和向峰两条大腿拉去,很幸运地又拿了专业年级排名靠前的罚时.然而却因为我提交次数太多,罚时与省赛无缘.但更幸运一些的是被木洪和佳录的队伍拖去省赛开眼界.四月底第一次集训的时候发现,脑洞是有多么的重要,然而之后却和舍友开始”享受了一段人生”,把各种休闲游戏玩了一圈后,省赛也快到了,于是再次出发去广州,和两个超级棒的队友在省赛玩了一天..自那开始思念起了东校的M记</p>
<p>​    说起M记大概又想起了期中高数考试前和培楠通宵的夜晚,拖他去KTV唱了很晚之后,贝岗已然爆满,问了几个东校的同学告诉我<strong>“M记是你家”</strong>…于是我们在那儿看了一集<strong>越策越开心</strong>和几集老友记..把被KTV拒之门外的零食吃的差不多了之后..就开始在大学城中环游荡了..培楠还顺便讲了一讲孤岛上的鬼故事和抢人案.<strong>不过说真的,他上了大学之后,真的变帅了</strong>,然后我们溜达到了华工后看了那天的日出.还因为穿着雅礼校服被十一中的妹子认出,打了好多次照面= =</p>
<p>​    五月中旬戒掉了<strong>泡泡堂</strong>之类的休闲游戏吧.继续刷起了USACO,从那时候开始我大抵真正的看到了算法大门的一角,看到了所谓的网络流,剪枝.hash,才知道之前的自己是有多么幼稚.前两天放下之前,以一种谜一样的速度刷了几章之后,写题解CSDN的博客也充实了很多.访问量过万后,便开始尝试用更好的框架搭起了这个博客.</p>
<p>​    觉得前端的东西总是能给人很多很多的成就感,当然要在做出来的前提下.下学期选了HTML后做了一个中珠打砖块,过一阵有时间后探索一下能不能放上这个博客.那天搭了一晚上这个博客因为没备份的修改自动毁了三次后,简直成就感爆棚.(好像又开始自我膨胀了XD).觉得挺有意思,于是从图书馆借了一本游戏开发的书,摆在了书架上.</p>
<p>​    以前总是羡慕大学有多自由,可以学特别多的知识.其实现在像是越来越功利化了吧,也像古南永所说<strong>一个膨胀的灵魂</strong>看太多看太快贪心不住蛇吞象,现在也对<strong>看起来很棒其实自己兴趣淡然</strong>的学科渐渐疏远起来.也不再是高中那个看普通物理学普通化学的少年了,走上了CS这条大道之后,路还是真的很长,但是又像黑夜明灯常亮,总是有很多前行的方向,有很多值得努力的地方.</p>
<p>​    </p>
<p>​    邂逅过一些OI大神的博客,其中对这段话特别有感触.别人口中最棒的地方,也因为有了选择的余地,可以用道德与理想相较之度量.感慨太深,于是也把这篇日志的题目设为此.</p>
<blockquote>
<p>​    我是2012年5月2日入职的，到今天整整是三个月。这是我首次在产业界的公司实习，与之前在微软亚洲研究院的实习有很大不同。之前在微软做的是「研究」，听起来好像是很厉害的样子，其实有时候做的东西简直是浪费时间。因为我从一开始就清楚，在研究院做的东西只是为了在特定领域有一个突破，至于这个成果会不会造福人类，那可不好说。运气好的话会被微软产品组看中，做成产品，算是为人类做贡献了。大多数时候你的成果还是被打入冷宫，永远无人问津。更普遍的情况是进入了微软的专利库，别人想做成产品都不行，这简直是阻碍人类社会进步了。我在微软亚洲研究院长达十个月的实习给我最大的收获就是让我决定了将来一定不会去读博士。</p>
</blockquote>
<p>—<a href="https://www.byvoid.com/blog/recent-one-year" target="_blank" rel="external">byvoid</a></p>
<p>​    另外大一的少年,总是会眷念刚过去不久的金戈铁马吧.骄傲的雅礼er,你们可都在自己的地方卓尔不群吧.去年年底做了<a href="http://v.youku.com/v_show/id_XMTQxNDUwNjAxNg==.html?from=s1.8-1-1.2" target="_blank" rel="external">班节视频</a>快到暑假了,大家不是约好了别墅再聚,球场峥嵘吗XD,任磊达这个学期可是学了足球呢(才不告诉你们就是因为这个就不追求体育绩点了…).</p>
<p>​    太久没说过话写过字了,上次还是去做那个<a href="https://www.zhihu.com/question/21496088/answer/76210364?from=profile_answer_card" target="_blank" rel="external">回答</a>.这次留一句话给还在纠结志愿的学弟学妹们吧</p>
<p>​    <strong>长得漂亮就来中大</strong></p>
<p>​    </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Notes for STL]]></title>
      <url>http://renld.github.io/2016/06/13/STL-LEARN/</url>
      <content type="html"><![CDATA[<p>  C++大学教程第22章.<br>  算法参考<code>cplusplus.com</code><br><a id="more"></a></p>
<ul>
<li>标准数组可以作为容器,只要把指针当做迭代器就好</li>
</ul>
<h2 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h2><ul>
<li><p>序列容器</p>
<p><code>vector</code>    <code>deque</code>    <code>list</code></p>
</li>
<li><p>关联容器(重载<code>&lt;</code>运算符,有些需要<code>==</code>)</p>
<p><code>set``multiset</code> <strong>允许重复</strong>    <code>map</code>        <code>multimap</code></p>
</li>
<li><p>容器适配器</p>
<p><code>stack``queue</code>  <code>priority_queue</code></p>
</li>
</ul>
<h2 id="基本操作-记得加括号"><a href="#基本操作-记得加括号" class="headerlink" title="基本操作(记得加括号)"></a>基本操作(记得加括号)</h2><ul>
<li>构造,拷贝构造,析构</li>
<li><code>empty</code>,   <code>insert</code>  <code>size</code>  </li>
<li>运算符重载(大小关系比较)</li>
<li>位置: <code>max_size</code>, <code>begin</code> <code>end</code>  <code>rbegin</code>  <code>rend</code>  <code>erase</code>  <code>clear</code></li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li><p>正向 <code>iterator</code></p>
<ul>
<li>随机访问<code>p[i]</code>表示和迭代器位置差p个元素的元素</li>
</ul>
</li>
<li><p>反向 <code>reverse_iterator</code> <strong>对应rbegin和rend</strong></p>
</li>
<li><p><code>istream_iterator&lt;type&gt;</code>和<code>ostream_iterator&lt;type&gt;</code></p>
<ul>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; output(<span class="built_in">cout</span>,<span class="string">" "</span>);</span><br><span class="line">copy(vec.begin(),vec.end(),output)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>const_iterator</code></p>
</li>
<li><p>尽量使用前缀++</p>
</li>
</ul>
<h2 id="重要容器"><a href="#重要容器" class="headerlink" title="重要容器"></a>重要容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul>
<li><code>insert(pos,num)</code>,在原来<code>pos</code>和<code>pos-1</code>之间插入<code>num</code>;</li>
<li>容器必须是非空的,不然<code>front</code>,<code>end</code>没有意义</li>
<li><code>front</code>,<code>back</code>是引用,<code>begin</code>,<code>back</code>是迭代器</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul>
<li><p>对于中间元素的插入删除(对于首尾的使用<code>deque</code>)</p>
</li>
<li><p>splice</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// set some initial values:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; ++i)</span><br><span class="line">     mylist1.push_back(i);      <span class="comment">// mylist1: 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; ++i)</span><br><span class="line">     mylist2.push_back(i*<span class="number">10</span>);   <span class="comment">// mylist2: 10 20 30</span></span><br><span class="line"></span><br><span class="line">  it = mylist1.begin();</span><br><span class="line">  ++it;                         <span class="comment">// points to 2</span></span><br><span class="line"><span class="comment">//剪切到第一个迭代器位置(全部)</span></span><br><span class="line">  mylist1.splice (it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                <span class="comment">// mylist2 (empty)</span></span><br><span class="line">                                <span class="comment">// "it" still points to 2 (the 5th element)</span></span><br><span class="line"><span class="comment">//剪切到第一个迭代器位置(之间)                                    </span></span><br><span class="line">  mylist2.splice (mylist2.begin(),mylist1, it);</span><br><span class="line">                                <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                <span class="comment">// mylist2: 2</span></span><br><span class="line">                                <span class="comment">// "it" is now invalid.</span></span><br><span class="line">  it = mylist1.begin();</span><br><span class="line">  <span class="built_in">std</span>::advance(it,<span class="number">3</span>);           <span class="comment">// "it" points now to 30</span></span><br><span class="line"></span><br><span class="line">  mylist1.splice ( mylist1.begin(), mylist1, it, mylist1.end());</span><br><span class="line">                                <span class="comment">// mylist1: 30 3 4 1 10 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.sort()</code>排序,<code>.unique()</code>排重<code>.merge(ano)</code>和ano依次合并112233…</p>
</li>
<li><p><code>.assign(beg,end);</code>把beg,end连个迭代器之间的赋值给本身</p>
</li>
<li><p><code>.remove(val)</code>删除所有这个值</p>
</li>
</ul>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><ul>
<li><p>查询是否包含这个元素</p>
<ul>
<li><code>.count(a) == 0</code></li>
<li><code>.find(a) == sl.end()</code></li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li><code>insert(make_pair( ) )</code></li>
<li><code>Map[a] = b</code></li>
</ul>
</li>
<li><p><code>set</code>相关函数</p>
<ul>
<li><p><code>it=std::set_union (first, first+5, second, second+5, v.begin());</code></p>
</li>
<li><p><code>it=std::set_difference (first, first+5, second, second+5, v.begin());</code></p>
</li>
<li><p><code>it=std::set_intersection (first, first+5, second, second+5, v.begin());</code></p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_union(</span><br><span class="line">   setA.begin(), setA.end(),</span><br><span class="line">   setB.begin(), setB.end(),</span><br><span class="line">   insert_iterator&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt;(ans,ans.begin()));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><ul>
<li>不支持迭代器</li>
</ul>
<ul>
<li><p>小顶堆<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cmp &#123;</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span></span><br><span class="line">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node, <span class="built_in">vector</span>&lt;node&gt;, cmp&gt; p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="STL算法-lt-algorithm-gt"><a href="#STL算法-lt-algorithm-gt" class="headerlink" title="STL算法&lt; algorithm&gt;"></a>STL算法&lt; algorithm&gt;</h2><h3 id="变序算法"><a href="#变序算法" class="headerlink" title="变序算法"></a>变序算法</h3><ul>
<li><p><code>copy</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::copy ( myints, myints+7, myvector.begin() );</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator&gt;</span><br><span class="line">  <span class="function">OutputIterator <span class="title">copy</span> <span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    *result = *first;</span><br><span class="line">    ++result; ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fill</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::fill (myvector.begin(),myvector.begin()+<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">// myvector: 5 5 5 5 0 0 0 0</span></span><br><span class="line">fill_n(beg,num,val);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="keyword">const</span> T&amp; val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    *first = val;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>generate</code>     <em>Assigns the value returned by successive calls to gen to the elements in the range <code>[first,last)</code>.</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span>        <span class="comment">// std::time</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>      <span class="comment">// std::rand, std::srand</span></span></span><br><span class="line"><span class="built_in">std</span>::srand ( <span class="keyword">unsigned</span> ( <span class="built_in">std</span>::time(<span class="number">0</span>) ) );</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomNumber</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">std</span>::rand()%<span class="number">100</span>); &#125;</span><br><span class="line"><span class="built_in">std</span>::generate (myvector.begin(), myvector.end(), RandomNumber);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Generator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span> <span class="params">( ForwardIterator first, ForwardIterator last, Generator gen)</span></span><br><span class="line">  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">      *first = gen();</span><br><span class="line">      ++first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>partion</code> <em>用一个函数把容器分成两个部分</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partition algorithm example</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    <span class="comment">// std::partition</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsOdd</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (i%<span class="number">2</span>)==<span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set some values:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i) myvector.push_back(i); <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator bound;</span><br><span class="line">    bound = <span class="built_in">std</span>::partition (myvector.begin(), myvector.end(), IsOdd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print out content:</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"odd elements:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myvector.begin(); it!=bound; ++it)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"even elements:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=bound; it!=myvector.end(); ++it)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> BidirectionalIterator, <span class="keyword">class</span> UnaryPredicate&gt;</span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">partition</span> <span class="params">(BidirectionalIterator first,</span><br><span class="line">                             BidirectionalIterator last, UnaryPredicate pred)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">      <span class="keyword">while</span> (pred(*first)) &#123;</span><br><span class="line">        ++first;</span><br><span class="line">        <span class="keyword">if</span> (first==last) <span class="keyword">return</span> first;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        --last;</span><br><span class="line">        <span class="keyword">if</span> (first==last) <span class="keyword">return</span> first;</span><br><span class="line">      &#125; <span class="keyword">while</span> (!pred(*last));</span><br><span class="line">      swap (*first,*last);</span><br><span class="line">      ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>random_shuffle</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using built-in random generator:</span></span><br><span class="line">  <span class="built_in">std</span>::random_shuffle ( myvector.begin(), myvector.end() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// using myrandom:</span></span><br><span class="line"><span class="comment">// random generator function:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myrandom</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::rand()%i;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::random_shuffle ( myvector.begin(), myvector.end(), myrandom);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> RandomNumberGenerator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_shuffle</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                         RandomNumberGenerator&amp; gen)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    iterator_traits&lt;RandomAccessIterator&gt;::difference_type i, n;</span><br><span class="line">    n = (last-first);</span><br><span class="line">    <span class="keyword">for</span> (i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; --i) &#123;</span><br><span class="line">      swap (first[i],first[gen(i+<span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replace</code>(注意这里和string不太一样)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);            <span class="comment">// 10 20 30 30 20 10 10 20</span></span><br><span class="line">  <span class="built_in">std</span>::replace (myvector.begin(), myvector.end(), <span class="number">20</span>, <span class="number">99</span>); <span class="comment">// 10 99 30 30 99 10 10 99</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replace</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                  <span class="keyword">const</span> T&amp; old_value, <span class="keyword">const</span> T&amp; new_value)</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">      <span class="keyword">if</span> (*first == old_value) *first=new_value;</span><br><span class="line">      ++first;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//replace_if</span></span><br><span class="line">  <span class="keyword">template</span> &lt; <span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> UnaryPredicate, <span class="keyword">class</span> T &gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replace_if</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span><br><span class="line">                     UnaryPredicate pred, <span class="keyword">const</span> T&amp; new_value)</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pred(*first)) *first=new_value;</span><br><span class="line">      ++first;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reverse</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i) myvector.push_back(i);   <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="built_in">std</span>::reverse(myvector.begin(),myvector.end());    <span class="comment">// 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> BidirectionalIterator&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((first!=last)&amp;&amp;(first!=--last)) &#123;</span><br><span class="line">    <span class="built_in">std</span>::iter_swap (first,last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rotate</code>按照第二个参数位置旋转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i) myvector.push_back(i); <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="built_in">std</span>::rotate(myvector.begin(),myvector.begin()+<span class="number">3</span>,myvector.end());</span><br><span class="line">                                                  <span class="comment">// 4 5 6 7 8 9 1 2 3</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(ForwardIterator first, ForwardIterator middle,</span><br><span class="line">               ForwardIterator last)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ForwardIterator next = middle;</span><br><span class="line">  <span class="keyword">while</span> (first!=next)</span><br><span class="line">  &#123;</span><br><span class="line">    swap (*first++,*next++);</span><br><span class="line">    <span class="keyword">if</span> (next==last) next=middle;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first==middle) middle=next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>swap_ranges</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">5</span>,<span class="number">10</span>);        <span class="comment">// foo: 10 10 10 10 10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">33</span>);        <span class="comment">// bar: 33 33 33 33 33</span></span><br><span class="line"><span class="built_in">std</span>::swap_ranges(foo.begin()+<span class="number">1</span>, foo.end()<span class="number">-1</span>, bar.begin());</span><br><span class="line"></span><br><span class="line">foo contains: <span class="number">10</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">10</span></span><br><span class="line">bar contains: <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">33</span> <span class="number">33</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2&gt;</span><br><span class="line">  <span class="function">ForwardIterator2 <span class="title">swap_ranges</span> <span class="params">(</span><br><span class="line">  ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1!=last1) &#123;</span><br><span class="line">    swap (*first1, *first2);</span><br><span class="line">    ++first1; ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>transform</code> 转换到另一个数组内</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">foo.push_back (i*<span class="number">10</span>);                         <span class="comment">// foo: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line">bar.resize(foo.size());                         <span class="comment">// allocate space</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), op_increase);</span><br><span class="line">                                                  <span class="comment">// bar: 11 21 31 41 51</span></span><br><span class="line">  <span class="comment">// std::plus adds together its two arguments:</span></span><br><span class="line"><span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(),</span><br><span class="line">                <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());					 <span class="comment">// foo: 21 41 61 81 101</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>unique</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (i==j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;           <span class="comment">// 10 20 20 20 30 30 20 20 10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints,myints+<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using default comparison:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  it = <span class="built_in">std</span>::unique (myvector.begin(), myvector.end());   <span class="comment">// 10 20 30 20 10 ?  ?  ?  ?                                                         //                </span></span><br><span class="line"></span><br><span class="line">myvector.resize( <span class="built_in">std</span>::distance(myvector.begin(),it) ); <span class="comment">// 10 20 30 20 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using predicate comparison:</span></span><br><span class="line"><span class="built_in">std</span>::unique (myvector.begin(), myvector.end(), myfunction);   <span class="comment">// (no changes)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="非变序算法"><a href="#非变序算法" class="headerlink" title="非变序算法"></a>非变序算法</h3><ul>
<li><p><code>count</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;   <span class="comment">// 8 elements</span></span><br><span class="line"><span class="keyword">int</span> mycount = <span class="built_in">std</span>::count (myints, myints+<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"10 appears "</span> &lt;&lt; mycount &lt;&lt; <span class="string">" times.\n"</span>;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>find</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">std</span>::find (myints, myints+<span class="number">4</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (p != myints+<span class="number">4</span>)<span class="comment">//no find</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</span><br><span class="line">  <span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first==val) <span class="keyword">return</span> first;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>search</code></p>
<blockquote>
<p>Searches the range <code>[first1,last1)</code> for the first occurrence of the sequence defined by <code>[first2,last2)</code>, and returns an iterator to its first element, or last1 if no occurrences are found.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; haystack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some values:        haystack: 10 20 30 40 50 60 70 80 90</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++) haystack.push_back(i*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using default comparison:</span></span><br><span class="line">  <span class="keyword">int</span> needle1[] = &#123;<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  it = <span class="built_in">std</span>::search (haystack.begin(), haystack.end(), needle1, needle1+<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (it!=haystack.end())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"needle1 found at position "</span> &lt;&lt; (it-haystack.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"needle1 not found\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1, <span class="keyword">class</span> ForwardIterator2&gt;</span><br><span class="line"><span class="function">ForwardIterator1 <span class="title">search</span> <span class="params">( ForwardIterator1 first1, ForwardIterator1 last1,</span><br><span class="line">                              ForwardIterator2 first2, ForwardIterator2 last2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first2==last2) <span class="keyword">return</span> first1;  <span class="comment">// specified in C++11</span></span><br><span class="line">    <span class="keyword">while</span> (first1!=last1)</span><br><span class="line">    &#123;</span><br><span class="line">      ForwardIterator1 it1 = first1;</span><br><span class="line">      ForwardIterator2 it2 = first2;</span><br><span class="line">      <span class="keyword">while</span> (*it1==*it2) &#123;    <span class="comment">// or: while (pred(*it1,*it2)) for version 2</span></span><br><span class="line">          ++it1; ++it2;</span><br><span class="line">          <span class="keyword">if</span> (it2==last2) <span class="keyword">return</span> first1;</span><br><span class="line">          <span class="keyword">if</span> (it1==last1) <span class="keyword">return</span> last1;</span><br><span class="line">      &#125;</span><br><span class="line">      ++first1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>equal</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator1, <span class="keyword">class</span> InputIterator2&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equal</span> <span class="params">( InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 )</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first1!=last1) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*first1 == *first2))   <span class="comment">// or: if (!pred(*first1,*first2)), for version 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      ++first1; ++first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mismatch</code></p>
<blockquote>
<p>Compares the elements in the range [first1,last1) with those in the range beginning at first2, and returns the first element of both sequences that does not match.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator1, <span class="keyword">class</span> InputIterator2&gt;</span><br><span class="line">  pair&lt;InputIterator1, InputIterator2&gt;</span><br><span class="line">    mismatch (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( (first1!=last1) &amp;&amp; (*first1==*first2) )  <span class="comment">// or: pred(*first1,*first2), for version 2</span></span><br><span class="line">  &#123; ++first1; ++first2; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(first1,first2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lexicographical_compare</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::lexicographical_compare(foo,foo+<span class="number">5</span>,bar,bar+<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycomp</span> <span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span><br><span class="line"></span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">tolower</span>(c1)&lt;<span class="built_in">std</span>::<span class="built_in">tolower</span>(c2); &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::lexicographical_compare(foo,foo+<span class="number">5</span>,bar,bar+<span class="number">9</span>,mycomp);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator1, <span class="keyword">class</span> InputIterator2&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">lexicographical_compare</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span><br><span class="line">                                InputIterator2 first2, InputIterator2 last2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first1!=last1)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (first2==last2 || *first2&lt;*first1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*first1&lt;*first2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ++first1; ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (first2!=last2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lower_bound</code>找到一个已排序序列中第一个可能插入不变序位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lower_bound/upper_bound example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>    <span class="comment">// std::lower_bound, std::upper_bound, std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(myints,myints+<span class="number">8</span>);           <span class="comment">// 10 20 30 30 20 10 10 20</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::sort (v.begin(), v.end());                <span class="comment">// 10 10 10 20 20 20 30 30</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator low,up;</span><br><span class="line">  low=<span class="built_in">std</span>::lower_bound (v.begin(), v.end(), <span class="number">20</span>); <span class="comment">// 3         ^</span></span><br><span class="line">  up= <span class="built_in">std</span>::upper_bound (v.begin(), v.end(), <span class="number">20</span>); <span class="comment">// 6                 ^</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lower_bound at position "</span> &lt;&lt; (low- v.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"upper_bound at position "</span> &lt;&lt; (up - v.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>equal_range</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; bounds;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// using default comparison:</span></span><br><span class="line">  <span class="built_in">std</span>::sort (v.begin(), v.end());                              <span class="comment">// 10 10 10 20 20 20 30 30</span></span><br><span class="line">  bounds=<span class="built_in">std</span>::equal_range (v.begin(), v.end(), <span class="number">20</span>);            <span class="comment">//          ^        </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using "mygreater" as comp:</span></span><br><span class="line">  <span class="built_in">std</span>::sort (v.begin(), v.end(), mygreater);                   <span class="comment">// 30 30 20 20 20 10 10 10</span></span><br><span class="line">  bounds=<span class="built_in">std</span>::equal_range (v.begin(), v.end(), <span class="number">20</span>, mygreater); <span class="comment">//       ^</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>for_each</code> <code>sort</code> <code>min</code> <code>max</code></p>
</li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
