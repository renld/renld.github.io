<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[vim Learning]]></title>
      <url>http://renld.github.io/2016/08/12/vim/</url>
      <content type="html"><![CDATA[转载学习~~~ 陈皓]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python实战计划 使用 find 函数]]></title>
      <url>http://renld.github.io/2016/08/12/PL3-3/</url>
      <content type="html"><![CDATA[今天才发现sublime可以直接编译我我我…… highcharts find({needName:needValue},{showType:showValue}) 上次作业的清洗可以简化为for i in item_info.find(&#123;'pub_date':&#123;'$in':['2016.01.12','2016.01.14']&#125;),&#123;'area':&#123;'$slice':2&#125;,'_id':0&#125;:#id:notshow print(i) datefrom datetime import date,timedeltadate(2016,02,02)days = timedelta(days=1)while the_date &lt;= end_date: yield (the_date.strftime('%Y.%m.%d')) the_date = the_date + days 模板 options = &#123; 'chart' : &#123;'zoomType':'xy'&#125;, 'title' : &#123;'text': 'Monthly Average Temperature'&#125;, 'subtitle': &#123;'text': 'Source: WorldClimate.com'&#125;, 'xAxis' : &#123;'categories': ['周一', '周二', '周三', '周四']&#125;, 'yAxis' : &#123;'title': &#123;'text': '数量'&#125;&#125; &#125;series = [ &#123; 'name': 'OS X', 'data': [11,2,3,4], 'type': 'line', 'y':5&#125;, &#123; 'name': 'Ubuntu', 'data': [8,5,6,7], 'type': 'line', 'color':'#ff0066'&#125;, &#123; 'name': 'Windows', 'data': [12,6,7,2], 'type': 'line'&#125;, &#123; 'name': 'Others', 'data': [29,24,68,23], 'type': 'line'&#125; ]charts.plot(series, options=options,show='inline')# options=dict(title=dict(text='Charts are AWESOME!!!')) #AIM 依旧用现成数据库数据吧.. Results结果 Conclusionyield 是一个类似 return 的关键字，只是这个函数返回的是个生成器。 datetime]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python实战计划 简单的数据图表]]></title>
      <url>http://renld.github.io/2016/08/11/PL3-2/</url>
      <content type="html"><![CDATA[第一步: 整理清洗数据 第二步: 更新数据库 第三步: 数据的可视化 jupyter notebook update(&#123;id:1&#125;,&#123;$set:&#123;name:2&#125;&#125;)db.createCollection('Ita')db.Ita.copyTo('Info')#反了...data,type,namecharts.plot(series,show='inline',options=dict(title=dict(text='xxx'))) #sampleseries = [ &#123; 'name': 'OS X', 'data': [11], 'type': 'column'&#125;, &#123; 'name': 'Ubuntu', 'data': [8], 'type': 'column', 'color':'#ff0066'&#125;, &#123; 'name': 'Windows', 'data': [12], 'type': 'column'&#125;, &#123; 'name': 'Others', 'data': [29], 'type': 'column'&#125; ]series2 = [&#123;'name': 'John','data': [5],'type': 'column'&#125;,&#123;'name': 'John','data': [5],'type': 'column'&#125;]charts.plot(series, show='inline')# options=dict(title=dict(text='Charts are AWESOME!!!')) Aim 由于当时只爬了8k条数据。。所以直接用给的json mongoimport -d ceshi -c item_info "../data_sample.json" Codeupdate 不要写成 updata… 成果 感想基本也是逃模板啦..详情模板戳到上面那个页面就好 本来想把那个页面直接copy内嵌进来的.. 发现根本加载不出就算了]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python实战计划 如何让数据说话]]></title>
      <url>http://renld.github.io/2016/08/11/PL3-1/</url>
      <content type="html"><![CDATA[提出优秀问题 通过数据论证,找到答案 得出结论 笔记提出正确的问题 正确的提问能解释现象 错误的提问能强行关联无关的事物 正确的提问能验证假设 错误的提问是为了证明自己是对的 正确的提问能探索方向 错误的提问会不知道自己干什么 ABTask方法 通过数据论证,找到答案对比横向对比,纵向对比 细分把大的目标分成小的领域 Mindnode划分… 解读数据样本问题 =&gt; 沉默的大多数 因果关联错误 忽略前提 =&gt; 有些数据是由前提的 对上一周大作业分析mongoexport -d dataBase -c Info --csv -f title,type,time,price,new,place -o information.csv2016-08-11T15:27:12.130+0800 csv flag is deprecated; please use --type=csv instead2016-08-11T15:27:12.143+0800 connected to: localhost2016-08-11T15:27:12.488+0800 exported 17438 records file 注意..因为奇怪的原因..每条信息重复了一遍 提出优秀问题信息齐全度的影响因素 通过数据论证,找到答案细分问题 横向对比&amp;&amp;纵向对比本来想用numbers,死机无数次放弃了…好好敲代码 价格from pymongo import MongoClientclient = MongoClient('localhost',27017)db = client['dataBase']Info = db['Info']analy = db['analy']cnts = dict()op = open('out.txt','w')for price in analy.find(): if price['price'] in cnts: cnts[price['price']] = cnts[price['price']]+1 else: cnts[price['price']] = 1for item in cnts: print(item,cnts[item],file=op,sep='\t') numbers 生成的统计表 然后发现…自己统计错东西了…. 重新写一个呗~ 除了个1k看数据,似乎不是很明显 from pymongo import MongoClientclient = MongoClient('localhost',27017)db = client['dataBase']Info = db['Info']analy = db['analy']cnts = dict()tot = dict()op = open('out.txt','w')for price in analy.find(): ps = int(price['price']) // 100 if ps in cnts: cnts[ps] = cnts[ps] + 1 tot[ps] = tot[ps] + price['inforNum'] else: cnts[ps] = 1 tot[ps] = price['inforNum']for item in sorted(cnts): if cnts[item] &gt; 1 : #clear special information print(item ,tot[item]/cnts[item],file=op,sep='\t') print('from', item * 100, 'to', (item + 1) * 100, 'counts', tot[item] / cnts[item], sep='\t') 由于第一张图可以知道,大部分数据集中在3k以下,所以重新绘制.. from pymongo import MongoClientclient = MongoClient('localhost',27017)db = client['dataBase']Info = db['Info']analy = db['analy']cnts = dict()tot = dict()op = open('out.txt','w')for price in analy.find(): ps = int(price['price']) if ps &lt; 3000:#选择精准数据 if ps in cnts: cnts[ps] = cnts[ps] + 1 tot[ps] = tot[ps] + price['inforNum'] else: cnts[ps] = 1 tot[ps] = price['inforNum']for item in sorted(cnts): if cnts[item] &gt; 1 : #clear special information print(item ,tot[item]/cnts[item],file=op,sep='\t') print(item , tot[item] / cnts[item], sep='\t') 看来我是小看了小商品价格填写的认真程度了2333 月份因为不知道python对于C++pair有什么东西,就自己编写了一个key 但是这样结果似乎意义不大.. from pymongo import MongoClientclient = MongoClient('localhost',27017)db = client['dataBase']Info = db['Info']analy = db['analy']types = dict()for month in range(1,13): cnts = dict() for data in analy.find(): if data['month'] == None: pass m = data['month'] + str('#') + str(data['inforNum']) if m in cnts: cnts[m] = cnts[m] + 1 else: cnts[m] = 1 months = sorted(cnts.keys()) print(months)for m in months: print('in month', m, 'info get', cnts[m])'''in month #2 info get 3in month #3 info get 3in month 01#2 info get 12in month 01#3 info get 14in month 02#2 info get 189in month 02#3 info get 165in month 02#4 info get 9in month 03#2 info get 442in month 03#3 info get 360in month 03#4 info get 69in month 04#2 info get 480in month 04#3 info get 348in month 04#4 info get 100in month 05#2 info get 754in month 05#3 info get 454in month 05#4 info get 106in month 06#2 info get 1206in month 06#3 info get 724in month 06#4 info get 247in month 07#2 info get 992in month 07#3 info get 1059in month 07#4 info get 270in month 08#2 info get 249in month 08#3 info get 325in month 08#4 info get 105in month 09#2 info get 1in month 09#3 info get 3in month 10#3 info get 1in month 11#2 info get 2in month 11#3 info get 4in month 12#2 info get 11in month 12#3 info get 11in month 12#4 info get 1''' 于是重新求平均值 from pymongo import MongoClientclient = MongoClient('localhost',27017)db = client['dataBase']Info = db['Info']analy = db['analy']types = dict()for month in range(1,13): cnts = dict() tot = dict() for data in analy.find(): if data['month'] == None: continue m = data['month'] if m in cnts: cnts[m] = cnts[m] + 1 tot[m] = tot[m] + data['inforNum'] else: cnts[m] = 1 tot[m] = data['inforNum'] months = sorted(cnts.keys()) #print(months)for m in months: print('in month', m, 'tot =',cnts[m],'\t','average info get',tot[m]/ cnts[m])'''in month tot = 6 average info get 2.5in month 01 tot = 26 average info get 2.5384615384615383in month 02 tot = 363 average info get 2.5041322314049586in month 03 tot = 871 average info get 2.571756601607348in month 04 tot = 928 average info get 2.5905172413793105in month 05 tot = 1314 average info get 2.506849315068493in month 06 tot = 2177 average info get 2.559485530546624in month 07 tot = 2321 average info get 2.6889271865575184in month 08 tot = 679 average info get 2.787923416789396in month 09 tot = 4 average info get 2.75in month 10 tot = 1 average info get 3.0in month 11 tot = 6 average info get 2.6666666666666665in month 12 tot = 23 average info get 2.5652173913043477''' 这样就明显多了 分析 10月份平均值最高是因为数据组数太少 3~8月数据量多,期中信息平均最多的是7月,或许是因为7月放假了大家比较闲.. 类别类似的 from pymongo import MongoClientclient = MongoClient('localhost',27017)db = client['dataBase']Info = db['Info']analy = db['analy']types = dict()tot = dict()op = open('out.txt','w')for t in analy.find(): tp = t['type'] if tp in types: types[tp] = types[tp] + t['inforNum'] tot[tp] = tot[tp] + 1 else: types[tp] = t['inforNum'] tot[tp] = 1i = 0for type in types.keys(): if tot[type] == 1:continue i = i + 1 st = str(types[type]/tot[type])[0:3] if i % 5 == 0: print(type,'ave',st,file = op) else: print(type, 'ave', st, file=op,end='\t\t') if i &gt; 100: break#only show some data 手套 ave 2.3 婴儿浴盆/婴儿浴床 ave 3.0 其他礼品 ave 2.6 陶瓷/景泰蓝 ave 2.2 麦克风 ave 2.5数码产品 ave 2.2 粮油 ave 2.7 帐篷 ave 3.2 其他电器 ave 2.6 戒指 ave 2.3奶瓶/奶嘴 ave 3.0 空气净化器 ave 2.6 电脑一体机 ave 2.6 门窗 ave 3.0 血压计/血糖仪 ave 3.0空调扇 ave 3.0 佛珠 ave 2.1 酸奶机 ave 2.5 电子琴 ave 3.0 家畜/家禽 ave 2.0蔬菜水果 ave 2.0 农用品/农产品 ave 2.0 冰箱 ave 3.3 电磁炉 ave 2.6 收音机/录音机 ave 3.0饮水机 ave 2.5 电脑外设 ave 2.0 手链/手串 ave 2.0 架子 ave 2.0 考试/教辅 ave 2.4灭火器/消防 ave 2.0 Xbox ave 2.5 牛仔裤 ave 2.2 其他锅 ave 2.6 字画 ave 2.0配饰 ave 2.0 无线网卡 ave 2.0 美甲 ave 3.0 保健美容设备 ave 3.3 冰淇淋机 ave 2.8无线路由器 ave 2.9 葫芦 ave 2.0 摇摇车 ave 2.7 咖啡 ave 2.5 台球桌 ave 2.9安全护栏 ave 3.0 项链 ave 2.1 摇椅 ave 4.0 充电器 ave 2.6 燃气灶 ave 2.7书桌 ave 4.0 设备机械 ave 2.0 其他保健品 ave 2.3 茶几 ave 3.4 美容器材 ave 2.2饭盒 ave 3.0 其他商用电脑 ave 3.0 苗木 ave 2.2 其他工艺品 ave 2.7 地毯 ave 3.5大家电 ave 2.0 沙发 ave 3.6 展柜货架 ave 2.0 其他装饰摆设 ave 2.3 前台桌 ave 3.4其他耳机 ave 2.8 维生素/营养品 ave 2.4 封口机 ave 3.0 烤面包机/面包机 ave 3.0 护肤品 ave 2.0十字绣 ave 2.2 其他农用品 ave 2.0 电脑椅 ave 3.0 办公桌 ave 3.5 键鼠 ave 2.7钢琴 ave 2.8 折叠床 ave 3.6 干衣机 ave 3.0 培训课程 ave 2.3 五金工具 ave 2.5相机/相机配件 ave 2.0 皮鞋/皮靴 ave 2.6 服饰/箱包 ave 2.0 茶叶 ave 2.3 相框 ave 2.5台式电脑整机 ave 2.7 运动健身 ave 2.0 其他设备/办公用品 ave 2.0 复印传真 ave 2.0 葡萄酒/红酒 ave 3.0其他桌子 ave 3.5 奶粉 ave 2.9 跑步机 ave 2.1 吸奶器 ave 3.0 空调 ave 3.6电水壶/热水瓶 ave 2.3 其他家电 ave 2.0 海参 ave 2.5 400电话 ave 2.5 晾衣架 ave 3.6分裤/短裤 ave 2.0 会有不同啦..但很难分析QAQ 生成数据库Code想想不如重建一个数据…… from pymongo import MongoClientclient = MongoClient('localhost',27017)db = client['dataBase']Info = db['Info']analy = db['analy']i = 0types = &#123;&#125;for data in Info.find(): if i % 2 != 0: infor = 0 if data['new'] != None: infor = infor + 1 if data['place'] != None: infor = infor + 1 if data['time'] != None: infor = infor + 1 if data['title'] != None: infor = infor + 1 AnalysisInfo = dict(type=data['type'],inforNum=infor,month=data['time'][0:2],price=data['price']) analy.insert_one(AnalysisInfo) i = i + 1 mongoexport -d dataBase -c analy --csv -f type,month,inforNum,price -o analy.csv2016-08-11T16:01:44.909+0800 csv flag is deprecated; please use --type=csv instead2016-08-11T16:01:44.915+0800 connected to: localhost2016-08-11T16:01:45.004+0800 exported 8719 records 这里本来想直接用numbers搞的结果数据量太大死机play 得出结论出人意料的是,信息齐全度和月份的关联最大 因为很多人标价1元(假标价)所以坑害了一些数据真实性 类别爬取大类的话想对好分析一些]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第二周实战作业：爬取一万商品数据]]></title>
      <url>http://renld.github.io/2016/08/10/PL2-final/</url>
      <content type="html"><![CDATA[赶集啦~~~ Aim ResultScreenShot 8khref 3kinformation PrintOut由于没有开time.sleep所以会被反扒, 卡死之后一般用ctrl+c停止那个类目爬取…… 二级页面爬取成功会输出页面名,否则会输出停止页面 end at /jiaju/o39//rirongbaihuo/ end at 168Fail to Get Info fromhttp://cs.ganji.com/shouji/2245928138x.htmFail to Get Info fromhttp://cs.ganji.com/shouji/2245928138x.htmFail to Get Info fromhttp://cs.ganji.com/shouji/2201642961x.htmFail to Get Info fromhttp://cs.ganji.com/shouji/2201642961x.htmFail to Get Info fromhttp://cs.ganji.com/shouji/2178792516x.htmFail to Get Info fromhttp://cs.ganji.com/shouji/2178792516x.htm另外没有报错????打开上述页面发现是被买走了 Code封装Soupdef GetSoup(url,buquan=1): if buquan: wb_data = requests.get((BaseUrl + url),timeout=2) # 因为有的页面需要前缀. else: wb_data = requests.get(url) wb_data.encoding = 'utf8' # 加上这句否则会乱码!!! if wb_data.status_code == 200: soup = BeautifulSoup(wb_data.text,'lxml') return soup else: print('Fail to Get Info from'+url) return None 得到channelTypeSel = '#wrapper &gt; div.content &gt; div &gt; div &gt; dl &gt; dt &gt; a'def GetChannal(url): soup = GetSoup(url) if soup == None: return None else: types = soup.select(TypeSel) for type in types: href = type.get('href') title = type.get_text() FirstUrl.insert_one(dict(title=title,href=href)) 爬取每个channal 用set来排除重复信息(因为赶集网后面的页面会定向为同一个..) return一个爬取成功与否的值 GoodSel = '#wrapper &gt; div.leftBox &gt; div.layoutlist &gt; dl &gt; dd.feature &gt; div &gt; ul &gt; li &gt; a'ThirdSet = set()def GetGoods(url): soup = GetSoup(url) if soup != None: goods = soup.select(GoodSel) for good,p in zip(goods,range(1,10)): title = good.get_text().strip() href = good.get('href') data = dict(title=title,href=href) if data['href'] in ThirdSet: return False else: ThirdSet.add(data['href']) SecondUrl.insert_one(data) return True else: return False def GetGoodsUrl(): for up in FirstUrl.find(): base = up['href'] for p in range(1, 10000): st = base + 'o' + str(p) + '/' try: if GetGoods(st) == False: print(base, 'end at', str(p))#爬取成功 break except: print('error in page', st)#有bug pass 爬取每个商品页面应该开多进程的…. 不过分了几个函数也不会挂得太惨咯.. place和新旧类别挺麻烦的QAQ 因为缺少信息会挂一片(比如jiaju页面很多都没有新旧…) 所以删掉try从小搞一下..来debug ttSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div.col-cont.title-box &gt; h1'tmSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div.col-cont.title-box &gt; div &gt; ul.title-info-l.clearfix &gt; li &gt; i'tpSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div &gt; ul &gt; li &gt; span &gt; a'pcSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div &gt; ul &gt; li &gt; i.f22.fc-orange.f-type'plSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div &gt; ul &gt; li &gt; a'newSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div.det-summary &gt; div &gt; div.second-dt-bewrite &gt; ul &gt; li'def GetGoodfInfo(url): soup = GetSoup(url,buquan=0) if soup != None: titles = soup.select(ttSel)[0].get_text() timers = soup.select(tmSel)[0].get_text().split('\\')[0].strip().split('\xa0')[0] types = soup.select(tpSel)[5].get_text() prices = soup.select(pcSel)[0].get_text() places = soup.select(plSel) place = ''.join(places[i].get_text() for i in range(1,4)) news = soup.select(newSel)[0].get_text().split(':')[1].replace('\n','').strip() #print('place',place) #print('type',types) data = dict(title=titles,time=timers,type=types,price=prices,place=place,new=news) #print(data) Info.insert_one(data) 完整Code#-*- coding: utf8 -*-from bs4 import BeautifulSoupfrom pymongo import MongoClientimport requestsclient = MongoClient('localhost',27017)dataBase = client['dataBase']FirstUrl = dataBase['FirstUrl']SecondUrl = dataBase['SecondUrl']Info = dataBase['Info']BaseUrl = 'http://cs.ganji.com'ErShouUrl = '/wu/'headers = &#123; 'Cookie':'ganji_uuid=3031153094415879005517; ganji_xuuid=3d4ba517-3b7d-4f20-e0d7-05de7a77b9c9.1459734446990; t3=2; statistics_clientid=me; __utmt=1; GANJISESSID=50071f0ac4021a7aa6fcfc7c52f229fa; STA_DS=1; lg=1; ganji_login_act=1470799155185; citydomain=cs; _gl_tracker=%7B%22ca_source%22%3A%22www.baidu.com%22%2C%22ca_name%22%3A%22-%22%2C%22ca_kw%22%3A%22-%22%2C%22ca_id%22%3A%22-%22%2C%22ca_s%22%3A%22seo_baidu%22%2C%22ca_n%22%3A%22-%22%2C%22ca_i%22%3A%22-%22%2C%22sid%22%3A40680747040%7D; __utma=32156897.1667757214.1468391541.1468391541.1470799081.2; __utmb=32156897.7.10.1470799081; __utmc=32156897; __utmz=32156897.1470799081.2.2.utmcsr=baidu|utmccn=(organic)|utmcmd=organic', 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'&#125;def GetSoup(url,buquan=1): if buquan: wb_data = requests.get((BaseUrl + url),timeout=2) else: wb_data = requests.get(url) wb_data.encoding = 'utf8' # 加上这句否则会乱码!!! if wb_data.status_code == 200: soup = BeautifulSoup(wb_data.text,'lxml') return soup else: print('Fail to Get Info from'+url) return NoneTypeSel = '#wrapper &gt; div.content &gt; div &gt; div &gt; dl &gt; dt &gt; a'def GetChannal(url): soup = GetSoup(url) if soup == None: return None else: types = soup.select(TypeSel) for type in types: href = type.get('href') title = type.get_text() FirstUrl.insert_one(dict(title=title,href=href))GoodSel = '#wrapper &gt; div.leftBox &gt; div.layoutlist &gt; dl &gt; dd.feature &gt; div &gt; ul &gt; li &gt; a'ThirdSet = set()def GetGoods(url): soup = GetSoup(url) if soup != None: goods = soup.select(GoodSel) for good,p in zip(goods,range(1,10)): title = good.get_text().strip() href = good.get('href') data = dict(title=title,href=href) if data['href'] in ThirdSet: return False else: ThirdSet.add(data['href']) SecondUrl.insert_one(data) return True else: return FalsettSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div.col-cont.title-box &gt; h1'tmSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div.col-cont.title-box &gt; div &gt; ul.title-info-l.clearfix &gt; li &gt; i'tpSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div &gt; ul &gt; li &gt; span &gt; a'pcSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div &gt; ul &gt; li &gt; i.f22.fc-orange.f-type'plSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div &gt; ul &gt; li &gt; a'newSel = '#wrapper &gt; div.content.clearfix &gt; div.leftBox &gt; div &gt; div.det-summary &gt; div &gt; div.second-dt-bewrite &gt; ul &gt; li'def GetGoodfInfo(url): soup = GetSoup(url,buquan=0) if soup != None: titles = soup.select(ttSel)[0].get_text() timers = soup.select(tmSel)[0].get_text().split('\\')[0].strip().split('\xa0')[0] if soup.select(tmSel) != [] else None types = soup.select(tpSel)[5].get_text() prices = soup.select(pcSel)[0].get_text() places = soup.select(plSel) if len(places) &gt; 4: place = ''.join(places[i].get_text() for i in range(1,4)) else: place = None news = soup.select(newSel)[0].get_text().replace('\n','').replace(' ','').strip() if soup.select(newSel) != [] else None #print('place',place) #print('type',types) data = dict(title=titles,time=timers,type=types,price=prices,place=place,new=news) #print(data) Info.insert_one(data)def GetGoodsUrl(): for up in FirstUrl.find(): base = up['href'] for p in range(1, 10000): st = base + 'o' + str(p) + '/' try: if GetGoods(st) == False: print(base, 'end at', str(p)) break except: print('error in page', st) passif __name__ == '__main__': GetChannal(ErShouUrl) GetGoodsUrl() for url in SecondUrl.find(): GetGoodfInfo(url['href']) try: GetGoodfInfo(url['href']) except Exception as e: print(str(e), 'fail to get ', url['href']) pass 心得与疑问笔记 把’&gt;’改成’ ‘之后不一定是严格下一级元素 访问量高的网站对于同一个ip的频次会有限制 lambda x:x.text import lxml解析会快很多 try少量还行,,大量bug太多还是得debug try: GetGoodfInfo(url['href']) except Exception as e: print(str(e), 'fail to get ', url['href']) pass 心得忘了判断404…好迷……..幸好跑之前加了个try 这次爬取的数据量突然变大后感受到了爬虫的魅力. 爬取时候没有用time.sleep似乎因为本身的延迟也没有挂的太惨 写了try之后那么挂了Ctrl+c能爬取接下来另一个页面 大数据量爬取得先爬几百个测一下字符串通用性~ 疑问但是有一些疑问 爬取的页面有一部分重复了一遍…是因为系统刷新了么… 爬取了8k个url之后爬不了了… 并没有理解出爬取大量页面和爬取少量的不同哇? 答复 重复可能是因为爬取规则有问题，或者网站本身的问题，所以重复的需要处理下。 8k url爬不了这个要看他提示什么错误了，如果没有提示错误就比较不好排除了。 大量和少量的不同很多，大量的爬取需要注意更多细节的东西，这不，到8k的url就爬不了。 chmod可以整个文件夹修改的，加上-R 不用一个个文件修改 另外我发现重复似乎是因为..同时run了两个py程序往数据库里面写……….]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PythonChallenge]]></title>
      <url>http://renld.github.io/2016/08/09/PythonChallenge/</url>
      <content type="html"><![CDATA[真是一个有趣的游戏…..让我回忆起母语的魅力src Task1print(1&lt;&lt;38) Task2#C++弱智题python我在干嘛...str = 'g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr\'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.'str.replace('k','m').replace('o','q').replace('e','g')alp = 'abcdefghijklmnopqrstuvwxyzabc'def toInt(ch): for i in range(0,len(alp)): if(alp[i] == ch): return i return -1def addTwo(ch): for i in range(0,len(alp)): if(alp[i] == ch): return alp[i+2]for i in str: ans = addTwo(i) if ans != None: print(addTwo(i),end='') else: print(i,end='') 被标准库完虐&gt;&gt;&gt; import string&gt;&gt;&gt; text = """g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr... amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ... ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb.... lmu ynnjw ml rfc spj."""&gt;&gt;&gt; table = string.maketrans(... string.ascii_lowercase,... string.ascii_lowercase[2:]+string.ascii_lowercase[:2]).join([chr(ord(x)+2) for x in 'map']) Task3被完虐 p = &#123;&#125;with open("hehe.html","r") as f: for k,s in zip(f,range(0,1000000000000000)): for j in k: if j in p: p[j] = p[j] + 1 else: p[j] = sans = sorted(p.items(),key=lambda d:d[1],reverse = False)for ps in range(0,len(ans)): if ans[ps][1] &lt; 2000: print(ans[ps][0],end='') 网上解答 s = ''.join([line.rstrip() for line in open('hehe.html')])OCCURRENCES = &#123;&#125;for c in s: OCCURRENCES[c] = OCCURRENCES.get(c, 0) + 1avgOC = len(s) // len(OCCURRENCES)print (''.join([c for c in s if OCCURRENCES[c] &lt; avgOC]) ) # equality...print ("".join([char for char in mess if char.isalpha()]))...print (re.sub(r'[^a-z]', '', str))]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[regular expression]]></title>
      <url>http://renld.github.io/2016/08/09/RE/</url>
      <content type="html"><![CDATA[跟风学正则の笔记 测试工具 what is Regular Expression 正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。 HowFrom LiaoXueFeng Simple Introduction在正则表达式中，如果直接给出字符，就是精确匹配。 用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以： &#39;00\d&#39;可以匹配&#39;007&#39;，但无法匹配&#39;00A&#39;； 而.可以匹配任意字符，所以： &#39;py.&#39;可以匹配&#39;pyc&#39;、&#39;pyo&#39;、&#39;py!&#39; 要匹配变长的字符，在正则表达式中， 用*表示任意个字符（包括0个） 用+表示至少一个字符 用?表示0个或1个字符 用{n}表示n个字符，用{n,m}表示n-m个字符： A|B可以匹配A或B，所以(P|p)ython可以匹配&#39;Python&#39;或者&#39;python&#39;。 ^表示行的开头，^\d表示必须以数字开头。 $表示行的结束，\d$表示必须以数字结束。 如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\。当然，要查找\本身，你也得用\. 例如：deerchao\.net匹配deerchao.net，C:\\Windows匹配C:\Windows。 In Pythonimport res = r'ABC\-001'ans = re.match(r'^\d&#123;3&#125;\-\d&#123;3,8&#125;$', '010-12345')# &lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;# print(ans.group(0)ans = re.match(r'^\d&#123;3&#125;\-\d&#123;3,8&#125;$', '010 12345')#nonere.split(r'\s+', 'a b c')# +匹配前面的子表达式一次或多次# \s匹配任何空白字符# ['a', 'b', 'c']ans = re.split(r'[\s\,]+', 'a,b, c d')# \将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符# ['a', 'b', 'c', 'd']# 分组m = re.match(r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$', '010-12345')# &lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;m.group(0)# '010-12345'm.group(1)# '010'm.group(2)# '12345'# 贪婪匹配re.match(r'^(\d+)(0*)$', '102300').groups()# + 匹配前面的子表达式一次或多次。# * 匹配前面的子表达式零次或多次# ('102300', '')# 非贪婪匹配re.match(r'^(\d+?)(0*)$', '102300').groups()#? 匹配前面的子表达式零次或一次。#('1023', '00')print(ans)#预编译# 编译:re_telephone = re.compile(r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$')# 使用：re_telephone.match('010-12345').groups()#('010', '12345') 字符类型 普通字符 非打印字符 | char | description || —- | ———————————- || \cx | 匹配由x指明的控制字符。 || \f | 匹配一个换页符。等价于 \x0c 和 \cL || \n | 匹配一个换行符。等价于 \x0a 和 \cJ || \r | 匹配一个回车符。等价于 \x0d 和 \cM || \s | 匹配任何空白字符 空格、制表符、换页符==[\f\n\r\t\v]。 || \S | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 | 控制字符 | char | description || —- | —————————————- || $ | 匹配输入字符串的结尾位置。 || ( ) | 标记一个子表达式的开始和结束位置。 || | 匹配前面的子表达式零次或多次。要匹配 字符，请使用 *。 || + | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 || . | 匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \。 || [ | 标记一个中括号表达式的开始。要匹配 [，请使用 [。 || ? | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 || \ | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。 || ^ | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。 || { | 标记限定符表达式的开始。要匹配 {，请使用 {。 || | | 指明两项之间的一个选择。要匹配 |，请使用 |。 || | | 限定字符 char description * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 示例\d{3}\s+\d{3,8} \d{3}表示匹配3个数字，例如&#39;010&#39;； \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&#39; &#39;，&#39; &#39;等； \d{3,8}表示3-8个数字，例如&#39;1234567&#39;。 \(?0\d{2}[) -]?\d{8}。 “(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。 正则表达式 描述 /\b([a-z]+) \1\b/gi 一个单词连续出现的位置。 /(\w+):\/\/([^/:]+)(:\d)?([^# ])/ 将一个URL解析为协议、域、端口及相对路径。 /^(?:Chapter\ Section) [1-9][0-9]{0,1}$/ 定位章节的位置。 /[-a-z]/ A至z共26个字母再加一个-号。 /ter\b/ 可匹配chapter，而不能匹配terminal。 /\Bapt/ 可匹配chapter，而不能匹配aptitude。 /Windows(?=95 \ 98 \ NT )/ 可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。 /^\s*$/ 匹配空行。 /\d{2}-\d{5}/ 验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。 /&lt;\s(\S+)(\s[^&gt;])?&gt;[\s\S]&lt;\s\/\1\s*&gt;/ 匹配 HTML 标记。 Exerciseemailimport re# emailpatten = 'bill.gates@microsoft.com'r = r'^(\w*)\.?(\w*)@(\w+).(\w+)'print(re.match(r,patten).groups())r1 = r'(&lt;\w+\s\w+&gt;)\s*(\w*)\.?(\w*)@(\w+).(\w+)'patten1 = '&lt;Tom Paris&gt; tom@voyager.org'print(re.match(r1,patten).groups())# 别人的re_email = re.match(r'^(\w+\.\w+|\w+)(\@\w+\.com)$','bill.a@microsoft.com')print(re_email.groups()) 参考资料Runoob 30min 廖雪峰 官方文档 python正则 路人甲]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python实战计划 多进程抓取]]></title>
      <url>http://renld.github.io/2016/08/09/PL2-3/</url>
      <content type="html"><![CDATA[单进程多线程: 一张桌子多个人吃饭, from multiprocessing import pool 创建进程池 pool = Pool( process = 60 ) # 默认可能更好pool.map(get_all_links_from,channel_list.split()) # 依次对第二个参数指向第一个函数指针 ​ 用命令行运行程序 一边运行count, 一边运行主程序 Aim抓取过程中遇到网络问题,设计一个功能保证数据开始抓取的信息不回重复 Solution这一章任务似乎与主题无关……. 放上标程先 from multiprocessing import Poolfrom page_parsing import get_item_info_from,url_list,item_info,get_links_fromfrom channel_extracing import channel_list# ================================================= &lt; &lt;链接去重 &gt; &gt; =====================================================# 设计思路：# 1.分两个数据库，第一个用于只用于存放抓取下来的 url (ulr_list)；第二个则储存 url 对应的物品详情信息(item_info)# 2.在抓取过程中在第二个数据库中写入数据的同时，新增一个字段(key) 'index_url' 即该详情对应的链接# 3.若抓取中断，在第二个存放详情页信息的数据库中的 url 字段应该是第一个数据库中 url 集合的子集# 4.两个集合的 url 相减得出圣贤应该抓取的 url 还有哪些db_urls = [item['url'] for item in url_list.find()] # 用列表解析式装入所有要爬取的链接index_urls = [item['url'] for item in item_info.find()] # 所引出详情信息数据库中所有的现存的 url 字段x = set(db_urls) # 转换成集合的数据结构y = set(index_urls)rest_of_urls = x-y # 相减# ======================================================================================================================]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux私房菜 计算机概论]]></title>
      <url>http://renld.github.io/2016/08/08/Linux-01/</url>
      <content type="html"><![CDATA[textbook answer 读书笔记~ CPU读取的数据来自内存 Intel 北桥负责链接较快的CPU,内存,显卡等, AMD集成内存和CPU 外频 : CPU与外部组件进行数据传输/运算时的速度 系统不稳定的可能原因 系统超频 电源不稳 内存无法负荷 系统过热 32/64位指计算机能处理的字组大小]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python实战计划 爬取大规模数据]]></title>
      <url>http://renld.github.io/2016/08/08/PL2-2/</url>
      <content type="html"><![CDATA[300条广州号码 笔记 观察页面特征 不同区域数目问题 设计工作流程(设计两个爬虫) ​增加页面判断,错误页面不予爬取 Aim 效果 输出 Code挑选页面花了好久时间… 还有对于404页面排除 #-*- coding: utf8 -*-from pymongo import MongoClientfrom bs4 import BeautifulSoupimport requestsimport timehost = 'localhost'port = 27017client = MongoClient(host,port)db = client['db']url_sheet = db['url_sheet']info_sheet = db['info_sheet']#pages 1 to 10Base_Url = ['http://gz.58.com/shoujihao/pn&#123;&#125;/'.format(str(i)) for i in range(1,11)]headers = &#123; 'Cookie':'...'&#125;titleSel = '#infolist &gt; div &gt; ul &gt; div &gt; ul &gt; li &gt; a &gt; strong'def checkNumber(num): for i in range(0,len(num)): if num[i] &lt; '0' or num[i] &gt; '9': return (False) else: pass return (True)tempOut = open('out.txt','w')def Get_Url(url): time.sleep(0.5) wb_data = requests.get(url, headers=headers) soup = BeautifulSoup(wb_data.text,'lxml') hrefs = soup.select(hrefSel) for p in hrefs: if p.get_text().strip().find('精准') == -1:#delete else # 提取的内容有很多空白字符，需要replace替换掉 # "title": title_text.replace("\n", "").replace("\t", "").replace(" ", ""), number = p.get_text().strip().replace('\n',' ').replace('\t',' ').replace(' ',' ').split(' ')[0] if len(number) == 11: url_sheet.insert_one(dict(number = number,url = p.get('href'))) else: pass else: passTestInfoUrl = 'http://gz.58.com/shoujihao/26973010446666x.shtml?psid=192625604192771088616429809&amp;entinfo=26973010446666_0'PhoneSel = '#main &gt; div.col.detailPrimary.mb15 &gt; div.col_sub.mainTitle &gt; h1'ConnectSel = '#t_phone'PutinTimeSel = '#main &gt; div.col.detailPrimary.mb15 &gt; div.col_sub.mainTitle &gt; div &gt; ul.mtit_con_left.fl &gt; li.time'def test404(): f = open('hehe.html','r') soup = BeautifulSoup(f,'lxml') str = soup.find_all('script')[-1].get_text() if str[-6:-3] == '404': print('404')def Get_Info(url = TestInfoUrl): time.sleep(1) wb_data = requests.get(url, headers=headers) soup = BeautifulSoup(wb_data.text,'lxml') str = soup.find_all('script')[-1].get_text() if str[-6:-3] == '404': print('404') pass else: Phone = soup.select(PhoneSel)[0].get_text().replace('\n',' ').strip()[:11] cto = soup.select(ConnectSel)[0].get_text().replace('\n',' ').strip() timer = soup.select(PutinTimeSel)[0].get_text().replace('\n',' ').strip() #print(Phone,cto,timer,sep='#') info_sheet.insert_one(dict(number=Phone,ConnectNumber=cto,PostTime=timer,Url=url))def main(): for pU in Base_Url: Get_Url(pU) for url in url_sheet.find(): Get_Info(url['url']) #Get_Info() #test404()if __name__ == '__main__': main() 课程Code 笔记:分成两个爬虫分别爬取 # 在最左边是在python 中对象的名称，后面的是在数据库中的名称# spider 1def get_links_from(channel, pages, who_sells=0): # td.t 没有这个就终止 list_view = '&#123;&#125;&#123;&#125;/pn&#123;&#125;/'.format(channel, str(who_sells), str(pages)) ... if soup.find('td', 't'): ... # return urls else: # It's the last page ! pass# spider 2def get_item_info(url):#404 finder no_longer_exist = '404' in soup.find('script', type="text/javascript").get('src').split('/') if no_longer_exist: pass else:#info Getter title = soup.title.text price = soup.select('span.price.c_f50')[0].text date = soup.select('.time')[0].text area = list(soup.select('.c_25d a')[0].stripped_strings) if soup.find_all('span', 'c_25d') else None item_info.insert_one(&#123;'title': title, 'price': price, 'date': date, 'area': area, 'url': url&#125;) print(&#123;'title': title, 'price': price, 'date': date, 'area': area, 'url': url&#125;) 总结这节课在前几节内容上拓展了页面防错. 另外url页面爬取难度也变大了..有了很多很多的判断 两个爬虫的同时应用充分展现了数据库的魅力 权当复习和练手吧hhh level up~~~ 今天七夕诶,祝情成眷]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python实战计划 Begining for MongoDB]]></title>
      <url>http://renld.github.io/2016/08/07/PL2-1/</url>
      <content type="html"><![CDATA[对小猪租房再度下手 MongoDB MongoDB环境搭建(Mongod in Mac)sudo /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"brew update #这一步也许不行...sudo chown -R $(whoami) /usr/local #这一步很关键..brew install mongodbcd /sudo mkdir -p /data/dbsudo chown -R radar_sir /data/db pycharm插件测试代码(之后refresh) from pymongo import MongoClienthost = 'localhost'port = 27017client = MongoClient(host,port)db = client['test']sheet = db['sheet']for i in range(1001): print(i) sheet.insert_one(&#123; 'name': 'name' + str(i), 'age': i &#125;) 基本使用#启动brew services listbrew services start mongodbmongod###上面都是骗人的--,#去下载的mongodb/bin里面 命令行打开mongo#下面也是在那个文件夹里面打开#查询mongoshow dbsdb# 转移数据库use liw# 读取数据db.sheet_out.find()# db.col.find().pretty()&amp;&amp;# db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()||# db.col.find(&#123;$or:[&#123;"by":"菜鸟教程"&#125;,&#123;"title": "MongoDB 教程"&#125;]&#125;).pretty()&gt;= db.col.find(&#123;likes : &#123;$gte : 100&#125;&#125;)typedb.col.find(&#123;"title" : &#123;$type : 2&#125;&#125;) # 2 -&gt; String, 1 -&gt; Double# 对应关系# client = MongoClient('localhost', 27017)# ilw = client['ilw']# sheet_out = ilw['sheet_out']#命令行数据导出#jsonmongoexport -d local(数据库名称) -c start_long(Collection名称) -o startup_log.json(导出文件名称)#csv ???mongoexport -d local(数据库名称) -c startup_log(collection名称) --csv -f(字段名称) hostname,startTime -o startup_log.csv(导出文件名称)# examplemongoexport -d ilw -c sheet_out --csv -f title,place,price,comment -o sheet_out.csvmongoexport -d dataBase -c SecondUrl --csv -f title,href -o href.csvmongoexport -d dataBase -c Info --csv -f title,type,time,price,new,place -o information.csvmongoexport -d dataBase -c analy --csv -f type,month,InforNum -o analy.csv2016-08-08T14:29:35.978+0800 csv flag is deprecated; please use --type=csv instead2016-08-08T14:29:35.986+0800 connected to: localhost2016-08-08T14:29:36.010+0800 exported 528 records# 存在mongoexport相同文件夹下,效果如下#数据导入db.createCollection('log')show collectionsmongoimport -d local(数据库名称) -c log(Collection名称) --file startup_log.json(导出文件名称)mongoimport -d local(数据库名称) -c log(Collection名称) --type csv --headerline --file startup_log.csv(导出文件名称)#validating settings: must specify --fields, --fieldFile or --headerline to import this file type ##其它使用 ###链接链接# 使用用户名和密码连接到MongoDB服务器，你必须使用 'username:password@hostname/dbname' 格式，'username'为用户名，'password' 为密码。# mongodb://admin:123456@localhost/ ###创建删除数据库# 创建数据库# pycharm# use DATABASE_NAME# 删除# 转移到那个之后 db.dropDatabase() ###插入更新删除数据# 插入db.COLLECTION_NAME.insert(document)# db.col.insert(&#123;title: 'MongoDB 教程', # description: 'MongoDB 是一个 Nosql 数据库',# by: '菜鸟教程',# url: 'http://www.runoob.com',# tags: ['mongodb', 'database', 'NoSQL'],# likes: 100# &#125;)# updatedb.collection.update( &lt;query&gt;, # update的查询条件，类似sql update查询内where后面的。 &lt;update&gt;,# update的对象和一些更新的操作符（如$,$inc...）等 &#123; upsert: &lt;boolean&gt;,# 如果不存在update的记录，是否插入objNew,true为插入 multi: &lt;boolean&gt;, # 如果这个参数为true,就把按条件查出来多条记录全部更新 writeConcern: &lt;document&gt;# 抛出异常的级别。 &#125;)# exampledb.col.update(&#123;'title':'MongoDB 教程'&#125;,&#123;$set:&#123;'title':'MongoDB'&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;) # 输出信息# save 覆盖原有db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;)# removedb.collection.remove( &lt;query&gt;,# 删除的文档的条件 &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;)# db.col.remove(&#123;'title':'MongoDB 教程'&#125;) ###Limit,Skip,sortdb.COLLECTION_NAME.find().limit(NUMBER)# 读取的记录条数。db.COLLECTION_NAME.find().skip(NUMBER) # 跳过的记录条数。db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)# 1 increase正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！实例如下：var name=eval("/" + 变量值key +"/i"); 以下是模糊查询包含title关键词, 且不区分大小写:title:eval("/"+title+"/i") // 等同于 title:&#123;$regex:title,$Option:"$i"&#125; ###regexdb.posts.find(&#123;post_text:&#123;$regex:"w3cschool.cc"&#125;&#125;)# ignore Casedb.posts.find(&#123;post_text:&#123;$regex:"w3cschool.cc",$options:"$i"&#125;&#125;) Exercise课程代码&amp;&amp;笔记#-*- coding: utf8 -*-import pymongo# 链接mongodbclient = pymongo.MongoClient('localhost',27017)# 激活本地客户端client# localhost : 本地# 27017 : 端口 不要写成27817..waxtu = client['waxtu']# 创建数据库表格sheet_tab = waxtu['sheet_tab']# 创建表单名称path = 'walden.txt'with open(path,'r') as f: lines = f.readlines() for index, line in enumerate(lines): data = dict(index=index,line=line,words=len(line.split())) #print(data) 检查是否读取.. sheet_tab.insert_one(data)# 存储数据for item in sheet_tab.find(): print(item) #&#123;'_id': ObjectId('57a80116d6616918def0fbfa'), 'index': 9703, 'words': 1, 'line': '.\n'&#125;# 检查数据是否存入# 另一种方法 refresh数据库插件for item in sheet_tab.find(&#123;'words':0&#125;): print(item['line'])# $lt/ $lte/ $gt/ $gte/ $ne，依次等价于&lt;/ &lt;=/ &gt;/ &gt;=/ !=。# (l表示less g表示greater e表示equal n表示not ）for item in sheet_tab.find(&#123;'words':&#123;'$gt':5&#125;&#125;): print(item) Task爬虫内容和这一章基本是一样的 Code爬取信息#-*- coding: utf8 -*-from bs4 import BeautifulSoupimport requestsimport timePriceSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; span.result_price &gt; i'TitleSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; div &gt; a &gt; span'CommentSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; div &gt; em &gt; span'UrlSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname'PlaceSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; div &gt; em'Testurl = 'http://cs.xiaozhu.com' # attention for adding http://headers = &#123; 'User-Agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36', 'Cookie' : 'abtest_ABTest4SearchDate=b; _gat_UA-33763849-7=1; __utmt=1; xzuuid=b2e6cf19; OZ_1U_2282=vid=v7a566a4734c93.0&amp;ctime=1470629052&amp;ltime=1470629048; OZ_1Y_2282=erefer=https%3A//www.baidu.com/link%3Furl%3DqGXg8_L7_OKuYp3jvCSU2LCcrIH5r8_CN22-4NrCKWWUCQRu4q4wOdeB4q2b_Zg9%26wd%3D%26eqid%3Db72a32fa000083cd0000000557a80293&amp;eurl=http%3A//www.xiaozhu.com/&amp;etime=1470628619&amp;ctime=1470629052&amp;ltime=1470629048&amp;compid=2282; _ga=GA1.2.206747787.1470457508; __utma=29082403.206747787.1470457508.1470469908.1470628620.3; __utmb=29082403.4.10.1470628620; __utmc=29082403; __utmz=29082403.1470628620.3.2.utmcsr=baidu|utmccn=(organic)|utmcmd=organic'&#125;def GetInfo(url = Testurl): time.sleep(1) wb_data = requests.get(url,headers=headers) soup = BeautifulSoup(wb_data.text,'lxml') prices = soup.select(PriceSel) titles = soup.select(TitleSel) comments = soup.select(CommentSel) urls = soup.select(UrlSel) places = soup.select(PlaceSel) for price,title,comment,url,place in zip(prices,titles,comments,urls,places): data = dict(price=price.get_text(),title=title.get_text(), place=place.get_text().split('\n')[-1].strip(), comment=comment.get_text().split('\n')[1].strip(), url=url.get('detailurl')) 存储处理/完整代码#-*- coding: utf8 -*-from bs4 import BeautifulSoupimport requestsimport timefrom pymongo import MongoClientclient = MongoClient('localhost', 27017)ilw = client['ilw']sheet_out = ilw['sheet_out']url = ['http://cs.xiaozhu.com/search-duanzufang-p&#123;&#125;-0/'.format(str(i)) for i in range(1,4)]Testurl = 'http://cs.xiaozhu.com' # attention for adding http://headers = &#123; 'User-Agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36', 'Cookie' : 'abtest_ABTest4SearchDate=b; _gat_UA-33763849-7=1; __utmt=1; xzuuid=b2e6cf19; OZ_1U_2282=vid=v7a566a4734c93.0&amp;ctime=1470629052&amp;ltime=1470629048; OZ_1Y_2282=erefer=https%3A//www.baidu.com/link%3Furl%3DqGXg8_L7_OKuYp3jvCSU2LCcrIH5r8_CN22-4NrCKWWUCQRu4q4wOdeB4q2b_Zg9%26wd%3D%26eqid%3Db72a32fa000083cd0000000557a80293&amp;eurl=http%3A//www.xiaozhu.com/&amp;etime=1470628619&amp;ctime=1470629052&amp;ltime=1470629048&amp;compid=2282; _ga=GA1.2.206747787.1470457508; __utma=29082403.206747787.1470457508.1470469908.1470628620.3; __utmb=29082403.4.10.1470628620; __utmc=29082403; __utmz=29082403.1470628620.3.2.utmcsr=baidu|utmccn=(organic)|utmcmd=organic'&#125;PriceSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; span.result_price &gt; i'TitleSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; div &gt; a &gt; span'CommentSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; div &gt; em &gt; span'UrlSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname'PlaceSel = '#page_list &gt; ul &gt; li &gt; div.result_btm_con.lodgeunitname &gt; div &gt; em'def GetInfo(url = Testurl): time.sleep(1) wb_data = requests.get(url,headers=headers) soup = BeautifulSoup(wb_data.text,'lxml') prices = soup.select(PriceSel) titles = soup.select(TitleSel) comments = soup.select(CommentSel) urls = soup.select(UrlSel) places = soup.select(PlaceSel) for price,title,comment,url,place in zip(prices,titles,comments,urls,places): data = dict(price=price.get_text(),title=title.get_text(), place=place.get_text().split('\n')[-1].strip(), comment=comment.get_text().split('\n')[1].strip(), url=url.get('detailurl')) sheet_out.insert_one(data)def main(): for URL in url: GetInfo(URL) for items in sheet_out.find(&#123;'price':&#123;'$gte': 500&#125;&#125;): print(items)if __name__ == '__main__': main() 效果 总结数据库的导入更好的处理了数据.. 但是学习了基于命令行的数据导入导出之后,并不会迁移到pycharm里面还是有点可惜.. 还是得调用csv库像前面几章那样做么QAQ (已经解决√)再有windows下面的导入导出命令Mac下面没有数据来模拟…有的时候并不能得到对应的结果]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python实战计划 爬取商品数据]]></title>
      <url>http://renld.github.io/2016/08/07/PL1-final/</url>
      <content type="html"><![CDATA[对58同城下手 Task1SubTask1 58二手市场类别页面Aim(因为改版..只能爬取转转商品) Results广州58健身页面非推广信息(298条) Code 本来想爬取每个位置,删除推广的,然后发现爬了之后就没有推广,于是直接爬了 接地气一点..换个URL爬 注意爬取图片时候用lazy_url 清理一下信息,用strip() 爬了300条信息,增加了url #-*- coding: utf8 -*-from bs4 import BeautifulSoupimport requestsimport timeimport csvurlBase = 'http://cs.58.com/pbdn/0/'urlJS = ['http://gz.58.com/jianshenqixie/0/pn&#123;&#125;/'.format(str(i)) for i in range(0,10)]headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36', 'Cookie': '...' #太占位置了..po上来时候删掉&#125;titleSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr &gt; td.t &gt; a'priceSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr &gt; td.t &gt; span.pricebiao &gt; span'oripriceSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr &gt; td.t &gt; span.priceyuan'describtionSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr &gt; td.t &gt; span.desc'placeSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr &gt; td.t &gt; span.fl'imgSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr &gt; td.img &gt; a &gt; img'tuiGuang = '#jingzhun &gt; tbody &gt; tr.jztr.last &gt; td.jzxztd'goodSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr'info = ['title','price','place','describtion','Url','img','OriPrice']def GetInfo(url, writer): time.sleep(3) wb_data = requests.get(url,headers=headers) soup = BeautifulSoup(wb_data.text,"lxml") titles = soup.select(titleSel) imgs = soup.select(imgSel) prices = soup.select(priceSel) describtions = soup.select(describtionSel) oriprices = soup.select(oripriceSel) places = soup.select(placeSel) for title,price,oriprice,describtion,place,img in zip(titles,prices,oriprices,describtions,places,imgs): writer.writerow( &#123; 'title' : title.get_text().strip(), 'price' : price.get_text().strip(), 'place' : place.get_text().strip().replace('\n',''),#clear blank and '\n' 'describtion' : describtion.get_text().strip(), 'img' : img.get('lazy_src'),#carefully for iamges!! 'OriPrice':oriprice.get_text().strip(), 'Url' : title.get('href') &#125;) return ('success get url: ' + url)def main(): testFile = open('test.csv', 'w') writer = csv.writer(testFile) writer.writerow(info) writer = csv.DictWriter(testFile, info) for ps in urlJS: print(GetInfo(ps, writer)) testFile.close()if __name__ == '__main__': main() SubTask2 58二手市场类别页面 想必这个要跑很久…吃饭前写完丢在哪里跑吧 结果是…. 吃了饭回来发现….. 有个函数参数写多了…………. Results同样因为页面改版,同样是上一个里面得到的链接,用上一步得到的url进一步爬取呗:) 爬取浏览量似乎很简单,爬不到新旧程度,和发帖时间 PostTimes = [PostTimes[1]] #补上这句后就能爬取到描述了..没想到那里有两个相同标签QAQ Code#-*- coding: utf8 -*-from bs4 import BeautifulSoupimport requestsimport timeimport csvurlJS = ['http://gz.58.com/jianshenqixie/0/pn&#123;&#125;/'.format(str(i)) for i in range(0,10)]headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36', 'Cookie': '...'&#125;info = ['kind','title','PostTime','price','New','Place']titleSel = '#infolist &gt; div.infocon &gt; table &gt; tbody &gt; tr &gt; td.t &gt; a'kindSel = '#nav &gt; div &gt; span &gt; a'IntitleSel = 'body &gt; div.content &gt; div &gt; div.box_left &gt; div.info_lubotu.clearfix &gt; div.box_left_top &gt; h1'PostTimeSel = 'body &gt; div.content &gt; div &gt; div.box_left &gt; div &gt; div &gt; div &gt; p'priceSel = 'body &gt; div.content &gt; div &gt; div.box_left &gt; div.info_lubotu.clearfix &gt; div.info_massege.left &gt; div.price_li &gt; span &gt; i'NewSel = 'body &gt; div.content &gt; div &gt; div.box_left &gt; div.info_lubotu.clearfix &gt; div.box_left_top &gt; p &gt; span.look_time'PlaceSel = 'body &gt; div.content &gt; div &gt; div.box_left &gt; div.info_lubotu.clearfix &gt; div.info_massege.left &gt; div.palce_li &gt; span &gt; i'urls = []def GetInfo(url, writer): time.sleep(3) wb_data = requests.get(url, headers=headers) soup = BeautifulSoup(wb_data.text, "lxml") #这里写了一个生成的小脚本...(因为都是重复信息) titles = soup.select(IntitleSel) prices = soup.select(priceSel) News = soup.select(NewSel) Places = soup.select(PlaceSel) kinds = soup.select(kindSel) PostTimes = soup.select(PostTimeSel) PostTimes = [PostTimes[1]] for kind,title,PostTime,price,New,Place in zip(kinds,titles,PostTimes,prices,News,Places): writer.writerow(dict(kind = kind.get_text(), title = title.get_text(), PostTime = PostTime.get_text(), price = price.get_text(), New = New.get_text(), Place = Place.get_text())) return ('successful get url: ' + url)def GetUrl(url): time.sleep(3) wb_data = requests.get(url,headers=headers) soup = BeautifulSoup(wb_data.text,"lxml") titles = soup.select(titleSel) for href in titles: urls.append(href.get('href')) return ('successful get base url: ' + url)def main(): testFile = open('test1.csv', 'w') writer = csv.writer(testFile) writer.writerow(info) writer = csv.DictWriter(testFile, info) for ps in urlJS: print(GetUrl(ps)) for pages in urls: GetInfo(pages,writer)#这里应该print的.. #testURL = 'http://zhuanzhuan.58.com/detail/761852078245855236z.shtml?fullCate=5%2C46%2C542&amp;fullLocal=3&amp;from=pc' #GetInfo(testURL,writer) testFile.close()if __name__ == '__main__': main() Review第一个任务算是一个小复习吧: requests处理网络请求 BeautifulSoup解析网页 soup.select(titleSel)得到元素 kind.get_text() &amp;&amp; kind.get( ‘src’ ) ​ csv.writer(testFile) &amp;&amp; writer.writerow(info) &amp;&amp; writer = csv.DictWriter(testFile, info) 自己生成重复太多的info代码 time.sleep headers -*- coding: utf8 — Task2 爬取JS浏览量58同城改版了… 似乎浏览量可以直接爬取…… (说实话 改版之后漂亮很多) 于是用自己博客做试验咯….. 打开了 当初换了域名后浏览量清零 暴怒关闭的浏览量统计…….(厚颜) inspect &gt; sources &gt; busuanzi &gt; … 然后发现不算子爬取不了??????? #-*- coding: utf8 -*-from bs4 import BeautifulSoupimport requestsimport timeimport csvapi = 'http://busaunzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback_835222807248'js = requests.get(api,'lxml')print(js) 视频笔记 由于58同城特殊性,可以从title爬取信息soup.title.text url.split(&#39;.&#39;)[-1].strip(&#39;x.shtml&#39;)得到id … if (…) else none ReadMoresRequests BeautifulSoupoutput prettify() 方法将Beautiful Soup的文档树格式化后以Unicode编码输出,每个XML/HTML标签都独占一行 get_text() 方法,这个方法获取到tag中包含的所有文版内容包括子孙tag中的内容,并将结果作为Unicode字符串返回: soup.get_text("|", strip=True) 第一个参数是分割,第二个是去除空白 偏门方法 soup.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;通过点取属性的方式只能获得当前名字的第一个tag:soup.p# &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;soup.p['class']soup.title.name# u'title'soup.a # &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;append()Tag.append() 方法想tag中添加内容,就好像Python的列表的 .append() 方法:soup = BeautifulSoup("&lt;a&gt;Foo&lt;/a&gt;")soup.a.append("Bar")soup# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;soup.a.contents# [u'Foo', u'Bar'] ​ 主要方法 .select() 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag:soup.select("title")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]soup.select("p nth-of-type(3)")# [&lt;p class="story"&gt;...&lt;/p&gt;]搜索指定名字的属性时可以使用的参数值包括 字符串 , 正则表达式 , 列表, True .soup.find_all('a') #name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉.# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]soup.find(id="link3") #可以传入正则,函数# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;css_soup.find_all("p", class_="body strikeout")# [&lt;p class="body strikeout"&gt;&lt;/p&gt;]soup.find_all("a", limit=2)#返回前两个 正则表达式如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容.下面例子中找出所有以b开头的标签,这表示\和\标签都应该被找到: import refor tag in soup.find_all(re.compile("^b")): print(tag.name)# body# b下面代码找出所有名字中包含”t”的标签:for tag in soup.find_all(re.compile("t")): print(tag.name)# html# title 函数def has_class_but_no_id(tag): return tag.has_attr('class') and not tag.has_attr('id')soup.find_all(has_class_but_no_id)# [&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;,# &lt;p class="story"&gt;Once upon a time there were...&lt;/p&gt;,# &lt;p class="story"&gt;...&lt;/p&gt;] Html5 X-path Http http1.3(download) 总结 一定要观察是否有两个相同标签再大量爬取……..(先爬几个生成格式文档试试) 如果有唯一描述的样式,可以soup.select(&#39;time&#39;) #代表id, . 代表class]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python实战计划 动态数据爬取]]></title>
      <url>http://renld.github.io/2016/08/06/PL1-4/</url>
      <content type="html"><![CDATA[动态加载 Notes 异步加载数据是由JS控制 比如往下翻才显示图片 inspect -&gt; network-&gt;xhr里面查看request.获取url 新浪微博评论/豆瓣影评 Task: 爬取美眉照片效果展示没成功下载下来只有一堆地址咯 这种图片网一般有反爬虫机制吧..answer Code也没有成功爬下图片 Codefrom bs4 import BeautifulSoupimport requestsimport time#可以打开看看page = n之后是什么样的网页..url = 'http://weheartit.com/inspirations/taylorswift?scrolling=true&amp;page='address = open('imgAddr',"w")for i in range(1,10): time.sleep(3) wb_data = requests.get(url + str(i)) soup = BeautifulSoup(wb_data.text, 'lxml') imgs = soup.select('img.entry-thumbnail') # 这里不能用selector...得用img.className for p in imgs: print(p.get('src'),file = address)address.close() DownloadImage存下来的地址没有成功下载照片QAQ… 但是下了百度首页的照片玩玩… #! /usr/bin/env python#-*- coding utf-8 -*-import urllib.requestimport osimport timedata = open('imgAddr',"r")data.seek(0)save_Path = "/Users/macbook/desktop/p/"os.chdir(save_Path)def DownloadImage(url = None,file_name = None): time.sleep(5) if(url != None): print('DownLoading',url) urllib.request.urlretrieve(url, file_name)#DownloadImage('http://www.baidu.com/img/first_9fe9815bdadfd21af47fc245f3bb0ba2.png','temp.png')for each_URL in data: DownloadImage(each_URL,each_URL.replace( str('/') , str('_') ) ) 总结没有下载到图片莫名遗憾, 技术长进空间很大啊.. 其实就是因为没看懂post…怎么搭怎么选QAQ, 去shadowsocks翻的墙并不能理解是怎么用的… 另外answer中对于名字的处理值得借鉴 def download(url): r = requests.get(url, proxies=proxies, headers=headers) if r.status_code != 200: return # http://www.example.com/test.png?a=1 # 第一个split，获取问号前面的字符 # 第二个split，获取倒数第二个一个斜杠的后面的内容，因为最后一个斜杠后面的字符串都一样，不能用 filename = url.split("?")[0].split("/")[-2] target = "./&#123;&#125;.jpg".format(filename) with open(target, "wb") as fs: fs.write(r.content) print("%s =&gt; %s" % (url, target))]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python实战计划 静态网页爬取]]></title>
      <url>http://renld.github.io/2016/08/06/PL1-3/</url>
      <content type="html"><![CDATA[真实静态网页爬取 2016里约奥运田径项目 小猪租房(广州) 里约奥运田径项目 因为女(自)票(己)想(想)看(装)田(逼)径,于是迫不及待地爬了一下里约的田径项目… 效果展示数据链接_xlsx 数据链接_numbers 源站点 谷歌不知道为什么爬不了…. code#-*- coding: utf8 -*-#记得加文字编码...from bs4 import BeautifulSoupimport requestsimport timeimport csvmenu = ['http://gz.xiaozhu.com/search-duanzufang-p&#123;&#125;-0/'.format(str(i)) for i in range(1,16)]url = 'http://www.ixueyi.com/yundong/293095.html'out = open("out.txt","w")daySel = '#jc_nrong &gt; div.TXCss107 &gt; table &gt; tbody &gt; tr:nth-child(3) &gt; td:nth-child(1)'timeSel = '#jc_nrong &gt; div.TXCss107 &gt; table &gt; tbody &gt; tr:nth-child(3) &gt; td:nth-child(2)'#jc_nrong &gt; div.TXCss107 &gt; table &gt; tbody &gt; tr:nth-child(5) &gt; td:nth-child(2)#jc_nrong &gt; div.TXCss107 &gt; table &gt; tbody &gt; trheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36', 'Cookie': 'NID=83=bg7QNR2QyqmCJMAb4JQZLk-HVFPL8aKM8EWsW9mbT8BfMslyf2uYA3gyIBdRUo_nSvekTZ9bu_6XHC2_8emosYlEIHbQe5XOFW_iIMK50IzdBIy6NSyr4thlswmjuqAIImVrA4e2t5uJtxD1H-Dy7dKoPxQLMBSYMWShPtqFBIMXj8_taezc1fcjXV4J5VVXnupDxk2Moq02PD-ekuAaoY9MPHtL; DV=kjjFsysMM5AYdPPDgiI1UyVX_W3FrAI'&#125;outF = 'WriteCsvFile1.csv'csvf = open(outF, 'w')writer = csv.writer(csvf)writer.writerow(['日期','时间','项目','轮次'])inType = ['Day','Time','Name','Type']writer = csv.DictWriter(csvf,inType)def GetHost(url = url,headers = headers): time.sleep(1) wb_data = requests.get(url) soup = BeautifulSoup(wb_data.text, 'lxml') titles = soup.select('#jc_nrong &gt; div.TXCss107 &gt; table &gt; tbody &gt; tr &gt; td') Day = '8月12日' times = '01:30' types = '铁饼' sing = '小组' first = 1 for sth in titles: inf = sth.get_text() if(inf.find('月') != -1): Day = inf elif(inf.find(':') != -1): times = inf elif(inf.find('赛') != -1): if(first): first=0 pass else: sing = inf writer.writerow(dict(Day=Day,Time=times,Name=types,Type=sing)) elif(inf.find('&lt;class \'type\'&gt;') == -1): types = infGetHost()没close文件...是不是会挂w 笔记writenget /page_one.html HTTP/1.1 Host: www.sample.comResponse status_code: 200inspect -&gt; Doc -&gt; network -&gt; cookie作为登录状态显示网页源代码 如果能唯一定位那么就是正确的找到更为简单方法描述1. soup.select('div.property_title &gt; a[target = "_blank]") - 这样抓取到了不想要的东西.. 对比两个不一样的地方 + 特定属性2. soup.select('img[width = "160']') 特定属性 - 抓取的所有都是同一个地址: 网站做了反爬取部分 - 爬取移动端页面...3. 父级标签 多对一列表解析式urls = ['....&#123;&#125;....'.format(str(i)) for i in range(30,930,30)]] codefrom bs4 import BeautifulSoupimport requestsimport time#requests != requesturl = 'http://renld.cn/'wb_data = requests.get(url)# .text 属性!!!soup = BeautifulSoup(wb_data.text,'lxml')#inspect -&gt; network -&gt; cookie作为登录状态headers = &#123; 'Uesr-Agent': '...' 'Cookie': '...'&#125;url_saves = './'time.sleep(2)wb_data = requests.get(url_saves, headers = headers)soup = BeautifulSoup(wb_data.text,'lxml') Task1Task CODEfrom bs4 import BeautifulSoupimport requestsimport timeurl = 'http://gz.xiaozhu.com/fangzi/1700198435.html'headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36', 'Cookie': 'abtest_ABTest4SearchDate=b; xzuuid=334a0f71; _gat_UA-33763849-7=1; __utmt=1; OZ_1U_2282=vid=v7a566a4734c93.0&amp;ctime=1470458319&amp;ltime=1470458217; OZ_1Y_2282=erefer=-&amp;eurl=http%3A//bj.xiaozhu.com/&amp;etime=1470457507&amp;ctime=1470458319&amp;ltime=1470458217&amp;compid=2282; _ga=GA1.2.206747787.1470457508; __utma=29082403.206747787.1470457508.1470457508.1470457508.1; __utmb=29082403.13.10.1470457508; __utmc=29082403; __utmz=29082403.1470457508.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)'&#125;def GetHost(url = url,headers = headers): wb_data = requests.get(url, headers=headers) soup = BeautifulSoup(wb_data.text, 'lxml') title = soup.select('body &gt; div.wrap.clearfix.con_bg &gt; div.con_l &gt; div.pho_info &gt; h4 &gt; em') # body &gt; div.wrap.clearfix.con_bg &gt; div.con_l &gt; div.pho_info &gt; h4 &gt; em address = soup.select('body &gt; div.wrap.clearfix.con_bg &gt; div.con_l &gt; div.pho_info &gt; p &gt; span') Add = address[0].get_text() Addr = Add[0:Add.find('\n')] # body &gt; div.wrap.clearfix.con_bg &gt; div.con_l &gt; div.pho_info &gt; p &gt; span DailyCost = soup.select('div.day_l &gt; span') # pricePart &gt; div.day_l &gt; span # imgs = soup.select('img[width="160"]') 为什么不能直接这样爬取 619.8874296435272??????? # 获取图片 答案里是...images = soup.select("#curBigImage") imgs = soup.select('#detailImageBox &gt; div.pho_show_l &gt; div &gt; div &gt; img') hosterImg = soup.select('#floatRightBox &gt; div.js_box.clearfix &gt; div.member_pic &gt; a &gt; img') # 这样爬了几次后网速会变慢..需要开VPN换个频道...... # 这样爬取的链接jpg不能打开... sexN = soup.select('#floatRightBox &gt; div.js_box.clearfix &gt; div.w_240 &gt; h6 &gt; span') if sexN[0].get('member_boy_ico') != None: sex = 'girl' else: sex = 'boy' name = soup.select('#floatRightBox &gt; div.js_box.clearfix &gt; div.w_240 &gt; h6 &gt; a') # .get('title') inf = dict(title=title[0].get_text(),address=Addr,DailyCost=DailyCost[0].get_text(), Bigimg=imgs[0].get('src'),hosterImg=hosterImg[0].get('src'),sex=sex,name=name[0].get_text()) print(inf,sep='\n') return(inf)if __name__ == '__main__': GetHost() print&#123;'sex': 'boy', 'Bigimg': 'http://image.xiaozhustatic1.com/00,800,533/4,0,58,6360,1800,1200,4a7bcf82.jpg', 'hosterImg': 'http://image.xiaozhustatic1.com/21/3,0,60,4932,252,252,82759f23.jpg', 'title': '珠江边主卧180°江景 近广州塔海心沙近地铁', 'name': '大卷', 'DailyCost': '289', 'address': '广东省广州市海珠区海琴湾'&#125; Question (基本解决)为什么不能像教程那样通过width抓取图片 (???)为什么抓取的图片打不开 (???)由于得到的是list,不能直接用get,那么更好办法使用get…(我是用取第一位[0]) Task2Task codefrom bs4 import BeautifulSoupimport requestsimport time#生成menu地址menu = ['http://gz.xiaozhu.com/search-duanzufang-p&#123;&#125;-0/'.format(str(i)) for i in range(1,16)]url = 'http://gz.xiaozhu.com/fangzi/1700198435.html'out = open("out.txt","w")headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36', 'Cookie': 'abtest_ABTest4SearchDate=b; xzuuid=334a0f71; _gat_UA-33763849-7=1; __utmt=1; OZ_1U_2282=vid=v7a566a4734c93.0&amp;ctime=1470458319&amp;ltime=1470458217; OZ_1Y_2282=erefer=-&amp;eurl=http%3A//bj.xiaozhu.com/&amp;etime=1470457507&amp;ctime=1470458319&amp;ltime=1470458217&amp;compid=2282; _ga=GA1.2.206747787.1470457508; __utma=29082403.206747787.1470457508.1470457508.1470457508.1; __utmb=29082403.13.10.1470457508; __utmc=29082403; __utmz=29082403.1470457508.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)'&#125;def GetHost(url = url,headers = headers): time.sleep(1) wb_data = requests.get(url, headers=headers) soup = BeautifulSoup(wb_data.text, 'lxml') title = soup.select('body &gt; div.wrap.clearfix.con_bg &gt; div.con_l &gt; div.pho_info &gt; h4 &gt; em') address = soup.select('body &gt; div.wrap.clearfix.con_bg &gt; div.con_l &gt; div.pho_info &gt; p &gt; span') Add = address[0].get_text() Addr = Add[0:Add.find('\n')] DailyCost = soup.select('div.day_l &gt; span') imgs = soup.select('#detailImageBox &gt; div.pho_show_l &gt; div &gt; div &gt; img') hosterImg = soup.select('#floatRightBox &gt; div.js_box.clearfix &gt; div.member_pic &gt; a &gt; img') sexN = soup.select('#floatRightBox &gt; div.js_box.clearfix &gt; div.w_240 &gt; h6 &gt; span') if sexN[0].get('member_boy_ico') != None: sex = 'girl' else: sex = 'boy' name = soup.select('#floatRightBox &gt; div.js_box.clearfix &gt; div.w_240 &gt; h6 &gt; a') # .get('title') inf = dict(title=title[0].get_text(),address=Addr,DailyCost=DailyCost[0].get_text(), Bigimg=imgs[0].get('src'),hosterImg=hosterImg[0].get('src'),sex=sex,name=name[0].get_text()) return(inf)'''#page_list &gt; ul &gt; li:nth-child(1) &gt; a'''#对于每个生成的地址,爬取下一级页面的地址..参考笔记代码for first in menu: web_data = requests.get(first) Soup = BeautifulSoup(web_data.text, 'lxml') addr = Soup.select('#page_list &gt; ul &gt; li &gt; a') for p in addr: if (p.get('href') != None): print(GetHost(p.get('href')), file=out) print Question (已解决)爬取太慢了QAQ..怎么设延时比较好,怎么知道自己有没有被封ip…… (已解决)爬取的信息能不能丢到csv文件里去..txt实在太丑…… (已解决)cookies是不是应该加密(不直接放到博客上…) 总结真实网页的爬取果然比静态难很多啊..开个vpn把电脑先丢到那里爬咯…300组数据orz 哈哈哈爬了几十分钟爬完了,链接在评论里面 CSV晚上写了一个txtTocsv脚本转换成表格形式 import csvinfo = ['title','name','DailyCost','hosterImg','Bigimg','address','sex']with open('1_3out.txt',"r") as txtf, open('WriteCsvFile.csv', 'w') as csvf: writer = csv.writer(csvf) writer.writerow(info) writer = csv.DictWriter(csvf,info)#字典Writer for i in txtf: k = eval(i) #返回成表达式 writer.writerow(k) 效果展示 老师答复 因为网站做了更新，所以做教程的时候可以抓取，但是现在已经不能用教程里的那种方法使用width去定位 图片的后缀有正确吗，如果正确的话还打不开，那换种方法看看，去我们的问题集里有关于如何下载图片的方法。 cookie加密了，网站还懂得认你的身份吗？所以不加 延迟的话一般设置2，3秒差不多，只有一直出现网络被断开就是被禁了，如果还是被禁的话，再调大一点，解决这个问题的根本方法还是使用代理]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python实战计划 爬取商品信息]]></title>
      <url>http://renld.github.io/2016/08/05/PL1-2/</url>
      <content type="html"><![CDATA[静态网页爬取 成果 代码#!/usr/bin/env python# -*- coding: utf-8 -*-from bs4 import BeautifulSoupwith open('index.html', 'r') as f: Soup = BeautifulSoup(f.read(), 'lxml') #有冒号的得删掉 images = Soup.select('body &gt; div &gt; div &gt; div.col-md-9 &gt; div &gt; div &gt; div &gt; img') titles = Soup.select('body &gt; div &gt; div &gt; div.col-md-9 &gt; div &gt; div &gt; div &gt; div.caption &gt; h4 &gt; a') prices = Soup.select('body &gt; div &gt; div &gt; div.col-md-9 &gt; div &gt; div &gt; div &gt; div.caption &gt; h4.pull-right') #这里直接把星星和数目都统计了,然后用i*2,和i*2+1分别提取 stars = Soup.select('body &gt; div &gt; div &gt; div.col-md-9 &gt; div &gt; div &gt; div &gt; div.ratings &gt; p')"""优质作业答案: reviews = soup.select( 'body &gt; div &gt; div &gt; div.col-md-9 &gt; div &gt; div &gt; div &gt; div.ratings &gt; p.pull-right') grades_crawler = soup.select( 'body &gt; div &gt; div &gt; div.col-md-9 &gt; div &gt; div &gt; div &gt; div.ratings &gt; p:nth-of-type(2) &gt; span ') # 上一行抓取所有的星星描述 grades = [] # 设置一个空列表 while len(grades_crawler) != 0: # 循环条件长度不为0 e = grades_crawler[0:5] # 提取星星描述前五个元素，也就是一个商品的星级 grades.insert(1, e) # 把这五个商品星级的列表作为一个元素插入grades列表中 del grades_crawler[0:5] # 删除抓取到的描述列表的前五位这样之后就可以用zip来读取了 另外 c = b.replace('&lt;span class="glyphicon glyphicon-star"&gt;&lt;/span&gt;', '★') # 将描述实五角星的替换为图案 d = c.replace('&lt;span class="glyphicon glyphicon-star-empty"&gt;&lt;/span&gt;', '☆') # 将描述虚五角星的替换为图案 star.append(d) # 将转化完的结果逐个插入列表star中 'grade': ''.join(star).replace('[', '').replace(']', '').replace(',', '').replace(' ', '') 这个很炫.join用法示例 &gt;&gt;&gt;li = ['my','name','is','bob'] &gt;&gt;&gt;' '.join(li) 'my name is bob' &gt;&gt;&gt;'_'.join(li) 'my_name_is_bob' """info = []for i in range(0,len(images)): data = dict(image = images[i].get('src'),title = titles[i].get_text(), price = prices[i].get_text(),starNum = stars[i*2].get_text(), star = len(stars[i*2+1].find_all("span",'glyphicon glyphicon-star'))) info.append(data) #print(data)with open("1-2.txt","w") as out: for i in info: print(i,file = out) 总结 添加库文件from bs4 import BeautifulSoup 打开本地文档with open(&#39;index.html&#39;, &#39;r&#39;) as f: beautifulSoup…Soup = BeautifulSoup(f.read(), &#39;lxml&#39;)就像熬一碗汤吧233 然后通过select copy过来的路径select出来,删掉冒号后的东西(我也不知道为什么…) 最后一步就是组合成一个个对象咯. get_text()得到标签外的文字 get(&#39;name&#39;)得到属性名对应内容 find_all( name , attrs , recursive , text , **kwargs ) 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件对应链接,这里用find_all(大标签名,类名),然后得到一个数组..统计一下长度用len呗.]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python实战计划 制作自己网页]]></title>
      <url>http://renld.github.io/2016/08/05/PL1-1/</url>
      <content type="html"><![CDATA[忘记领50rmb优惠卷了…那只能好好学了呗 最终成果 我的代码&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;spring blossom&lt;/title&gt; &lt;!-- 这里一定得写rel类型啊....--&gt; &lt;link rel="stylesheet" type="text/css" href="main.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="header"&gt; &lt;img src="images/blah.png"&gt; &lt;ul class="nav"&gt; &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Site&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Other&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="main-content"&gt; &lt;!-- 面朝大海,春暖花开 --&gt; &lt;h2 align="center"&gt;Spring Blossom&lt;/h2&gt; &lt;img src="images/0001.jpg" height="150" width="150"&gt; &lt;img src="images/0003.jpg" height="150" width="150"&gt; &lt;img src="images/0004.jpg" height="150" width="150"&gt; &lt;hr/&gt; &lt;ul&gt; &lt;li&gt;&lt;p class="article"&gt;From tomorrow on,&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p class="article"&gt;write to each of my dear ones&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p class="article"&gt;Telling them of my happiness&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="footer"&gt; &amp;copy; Renld &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结 又开始写实验报告的感觉QAQ…… 引入CSS文件记得加stylesheet 不同div 对于class不同于是CSS文件的渲染也不同,一般分成header, main-content 和footer &lt;hr/&gt;是大下线—对应markdowm中--- 图片后面的属性记得调height和weight,另外我似乎记得html有网格框架 标签可以内嵌]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 'First' Learning]]></title>
      <url>http://renld.github.io/2016/08/05/HFPy/</url>
      <content type="html"><![CDATA[因为后面涉及数据库,服务器内容,太监之后只有基础内容了QAQ HEADFIRST PYTHON循环与递归 python默认递归深度100 参考代码 """递归打印多重列表"""movies = ["The Holy Grail", "The Life of Brian", "The Meaning of Life", [1,2,3]];def pt(List): for a in List:# if isinstance(a,list):#判断类型 pt(a); else: print(a); # for a in range(0,len(List)): # if isinstance(List[a],list): # pt(List[a]); # else: # print(List[a]);pt(movies); 封装以及命名空间 nester.py放到一个文件夹中,加上setup.py from distutils.core import setupsetup( name = 'nester', version = '1.0.0', py_modules = ['nester'], author = 'abc', author_email = '505636638@qq.com',#信息基本都是瞎写的= = url = "baidu.com", discription = '1', ) 在文件夹中执行 python3 setup.py sdist;sudo python3 setup.py install import后就可以通过命名空间执行了 import nesternester.pt(nester.movies)#from nester import pt &lt;=&gt; using namespace...#pt(nester.movies) ​ 文件操作import osos.chdir('../p')os.getcwd();#get file address#Idata = open('sketch.txt')data.seek(0);#return begineach_line = data.readline();# help(each_line.split)# S.split(sep=None, maxsplit=-1) -&gt; list of stringsfor each_line in data: if each_line.find(':') != -1: try: (role,line_spoken) = each_line.split(':',1) print(role,end = ''); print(' said: ',end = ''); print(line_spoken,end = ''); except: pass#Oout = open("data.out","w") #a -&gt; append,w+ read &amp; writefor eachS in other: print(eachS,file = out)out.close(); 数据处理line_spoken = line_spoken.strip()#去除不必要的空白locals()#当前BIF中变量集合 第一本编程书笔记 int(), str()对于类型的转化 [a:b]对于数组的分片 函数传入参数可以(id = 1,)不按顺序传入 print中sep表示分隔字符 **为幂,//为整除 列表推倒: k = [n for n in range(1,10) if n % 2 == 0]g = &#123;i:j.upper() for(i,j) in zip(range(1,6),'abcde')&#125; 类的继承 在括号内写父类 exercise#创造1-10.txt文本,以数字命名def creater(name): name = name + '.txt' file = open('/users/macbook/desktop/' + name,'w') file.write('hello' + name) return filefor x in range(1,11): if(x &lt; 10): creater('0' + str(x)) else: creater(str(x)) pass]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Greedy & Violent]]></title>
      <url>http://renld.github.io/2016/07/22/greedy/</url>
      <content type="html"><![CDATA[贪心可不是件简单事儿. 有趣的贪心依据与思想 贪心既然是一个方向的dp,往往相邻交换法可以得到优先级 真正不要脑洞的贪心还是很少的(比如例题11,UVA11520) ​ 贪心法是每步选择局部最优解，然后一步一步向目标迈进。这个“目标”两字很关键，说明贪心法是目标导向的，每一步的方向一定是目标。那么我上面两种方法其实只是在模仿那个经典问题的模式，但是却没有时刻注意到这个问题最终目标是实现从1到n每一位都能放上满足条件的车，比如第二个反例最后一个格最后都无法放车了，就是因为前面没有按照对最终目标的影响效果去选择局部最优解，单纯的选最左边一个是毫无道理的，因为本题已经不是那个经典的选最少点的问题了。(UVA11134题解摘录) 热身训练sort大法好==. HEllo World (2 ^ ans &gt; n) CF363A最小碰撞时间 Building designing sort两个指针扫 Ancient Cipher sort计数 DNA Consensus String 枚举 Big Chocolate 找规律== All in All 两个指针扫 Children’s Game(UVA10905) 字符串最大==sort by a + b &gt; b + a UVA11389 给出两个数组,使得搭配后所有超出S的值 超出部分和最小 例题1 UVA11292 勇者斗恶龙,两个指针往后扫 加上这两句话(if)才能过??? if(n) sort(dg, dg + n);if(m) sort(hero, hero + m); 进阶 LA3266 田忌赛马 (这个我CSDN博客有详细题解== 当初放弃ACM Steps题目..现在看来脸皮厚多了) UVA11100 (进阶)个数尽量少严格递增…等差(距)数列 LA4094(进阶) 梦之队 这道题网上题解分析很贪心hhh LA4636(进阶) 给出主视图和左视图,求最小立体…(每次找max,相等加到ans,不相等舍弃大的那个) LA3303 相邻交换法 a1b2 &lt; a2b1 LA2757 从后向前 区间问题最早完成 例题2 UVA11729 Bi时间交代任务,Ji时间完成. ==&gt; (交换法证明)完成时间长的先交代 例题10 UVA11384 用最少次数全部变成0 =&gt;&gt; 保持平衡 ,每次把大的一半减去(n/2)+1 递归/二分(每次减大的数的一半) 最少区间选择 UVA10382 sort by zuo when equal by you 最多区间选点 UVA11134 二维的..等价于两个一维,紫书P237 Priest John’s Busiest Day 至少出席区间一半时间 因为左右等价,sort by middle 最小惩罚 LA4850 求两个最大惩罚之和,end排序贪心扫一遍后,枚举 做法一: 枚举一个任务以及调动位置 struct seg&#123; int f,e; bool operator&lt;(const seg &amp; b)const&#123; return e &lt; b.e; &#125;&#125;cs[500 + 5];/* in main sort(cs, cs + n); &gt; int ans = gao(-1,10000,n); &gt; for(int i = 0;i &lt; n;i++)//枚举一个任务调动 &gt; for(int j = 0;j &lt; n;j++)//枚举调动位置 &gt; ans = min(ans,gao(i,j,n)); &gt; printf("%d\n", ans);*/int gao(int cur,int to,int n)&#123; int sum = 0, cnt = 0; int max1 = 0,max2 = 0; for(int i = 0; i &lt;= n; i++) &#123; if(cnt == to) &#123; sum += cs[cur].f; max2 = max(max2,sum - cs[cur].e); if(max2 &gt; max1) swap(max2,max1); &#125;//调动位置 if(i != cur &amp;&amp; i &lt; n) &#123; sum += cs[i].f; max2 = max(max2,sum - cs[i].e); if(max2 &gt; max1) swap(max1,max2); cnt++; &#125;//未调动位置 &#125; return max1 + max2;&#125; 剪枝 牺牲的任务只能在两个最大惩罚值中的最后一个任务的前面，只有牺牲前面的任务才能使最大惩罚值的值减小，注意这里是牺牲，就表示有可能牺牲这个任务后，该任务的惩罚值变成了最大惩罚值的其中一个。 ​ 方法2 二分套二分 半边界优先队列维护 LA3507 知道DDL和花费,用优先队列维护最优值 int ans = 0;for (int i = 0; i &lt; n; i++) &#123; ans += af[i].q; dd.push(af[i].q); while (ans &gt; af[i].d) &#123; ans -= dd.top(); dd.pop(); &#125;&#125; ​ 路径最小 例题3 UVA11300 所有人转手金币之和最小 (少一个方程的线性方程组=&gt;)单变量极值不等式 数轴上一串点距离和,中位数是极小值点. 例题4 LA3708 加入m个雕塑到n个等距中,求最小移动距离 变换坐标系为len = 1; tot最小,一定移动到最接近的位置 随机选一个坐标原点不动 //坐标缩小后就可以更方便的选择double pos = (double)i / n * (n + m);//原来雕像的位置ans += fabs(pos - floor(pos + 0.5))/(n + m);//*n+m后就选四舍五入最近的 相对不变问题 例题5 UVA10881 蚂蚁爬.求每个蚂蚁最后的位置和方向 每个蚂蚁的相对顺序不会改变=&gt;记录id,最后对应回去 sort(before, before + n);for (int i = 0; i &lt; n; i++) &#123; order[before[i].id] = i;&#125;// 之后i := 0-&gt;n, a = order[i]就是从小到大的顺上去 树形贪心 例题15 LA3902 每个叶节点不超过k有个站 求站的最小数 ​ 每次取最深的 通过node表flood fill. (node[dis]表示深度为dis的叶子)) ​ for(int i = 0;i &lt; k;i++) v = fa[v];//第k级祖先if (e[u].size() == 1 &amp;&amp; d &gt; k) node[d].push_back(u);//node表构建 CF363c 完全二叉树..每次找最近公共祖先还是很简单的== 左右互搏法 例题16 LA3177 围成一个圈每个人拿r[i]个礼物,相邻不相同 n == 1,特殊情况总共r[1]个 ​n % 2 == 0 =&gt; max(r[i] + r[i+1])个 n % 2 == 1 二分答案 以r[1]为界限循环一圈,(除了第一个)奇数尽量拿右边的,偶数尽量拿左边的, (因为第一个和最后一个都是奇数位)看最后一个是否会拿左边的. bool check(int p)&#123; int x = a[1], y = p - a[1];//bound left[1] = x,right[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; if (i &amp; 1) &#123; right[i] = min(a[i],y - right[i-1]);//奇数尽量拿右边的 left[i] = a[i] - right[i]; &#125; else &#123; left[i] = min(a[i], x - left[i-1]);//偶数尽量拿左边的 right[i] = a[i] - left[i]; &#125; &#125; return left[n] == 0;&#125; UVA11627(数据有毒) 过障碍维护当前最左和最右 LA4725 两个飞机一个入口,问最小编码..维护当前飞机,ab能飞和tot能飞 维护当前机场的飞机数目，机场可以供起飞的数目还有可以起飞的总数。 超过数目后，判断可供起飞的数目是否为0就行了。 其实也就是因为a起飞数和b起飞数不是完全相干的 所以要多个变量定义. inline int min(int a,int &amp;b,int &amp;c)&#123; if (a &gt; b) &#123; if (b &gt; c) return c; return b; &#125; if (a &gt; c) return c; return a;&#125;bool ok(int m)&#123;//high cnt = m int ap = 0,bp = 0;//当前飞机场数目 int af = 0,bf = 0,tf = 0;//a可以起飞数,b,总 for (int i = 0; i &lt; n; i++) &#123; if(a[i] &gt; m || b[i] &gt; m) return false; ap += a[i];//时间i降落 bp += b[i]; if(ap &gt; m)//之前起飞 &#123; int dec = min(ap - m, af,tf); ap -= dec,af -= dec,tf -= dec; &#125; if(bp &gt; m) &#123; int dec = min(bp - m, bf,tf); bp -= dec,bf -= dec,tf -= dec; &#125; if(ap &gt; m || bp &gt; m) return false; if(af &lt; ap) af++;//主要是这个if限制了状态定义 if(bf &lt; bp) bf++; if(tf &lt; ap + bp) tf++; &#125; return true;&#125; LA3403 (紫书例题)天平难题…二进制枚举二叉树,记录左右最大值 滑动窗口/单调队列 例题18 UVA11078 找Ai和Aj使得Ai - Aj尽量大 维护小于j的最大i值 MaxAi = max(Aj,MaxAi) 例题21 LA2678 正整数序列,求最短子序列和&gt;S 重点在于随后加一个if (ans == maxn) ans = 0 尺取法for (ptr1 = ptr2 = 0; ptr2 &lt; N; ptr2++) &#123; sum += a[ptr2];//每次后面的指针后移 while (ptr1 &lt;= ptr2 &amp;&amp; sum - a[ptr1] &gt;= S) &#123; sum -= a[ptr1]; ptr1++; &#125; if (sum &gt;= S)update(ans, ptr2 - ptr1 + 1);&#125; for (ptr1 = ptr2 = 0; ptr2 &lt; N; ) &#123; while (sum &lt; S &amp;&amp; ptr2 &lt; N ) &#123; sum += a[ptr2]; ptr2++; &#125; while (sum &gt;= S &amp;&amp; ptr1 &lt; ptr2) &#123; update(ans, ptr2 - ptr1); sum -= a[ptr1]; ptr1++; &#125;&#125; 可怕的暴力三维问题 例题6 LA2995 (最大立体)三维坐标系转换 void get(int k, int i, int j, int len, int &amp;x, int &amp;y, int &amp;z)&#123; if (k == 0) &#123; x = len; y = j; z = i; &#125; if (k == 1) &#123; x = n - 1 - j; y = len; z = i; &#125; if (k == 2) &#123; x = n - 1 - len; y = n - 1 - j; z = i; &#125; if (k == 3) &#123; x = j; y = n - 1 - len; z = i; &#125; if (k == 4) &#123; x = n - 1 - i; y = j; z = len; &#125; if (k == 5) &#123; x = i; y = j; z = n - 1 - len; &#125;&#125;/* 给出六个面 k: 前 左 后 右 顶 底 i j 枚举位置 len是深入的长度 x y z从上往下看的坐标系*/ 例题8 LA3401 修改最少的面使得立方体相同 写个小程序枚举”姿态” 枚举每个立方体每种姿态最少涂色数 套路 例题7 UVA11464 01矩阵枚举第一行 例题11 UVA10795 汉诺塔的扩展 汉诺塔变形,给出始态终态,求移动步数 赋予中间态定义f(P,i,final)表示把1…i全部移动到final所需要的步数 ans = f(start,k-1,6-start[k]-finish[k]) + f(finish,k-1,6-start[k]-finish[k])+1 (k 是最大编号要移动的盘子) f(P,i,final) = (P[i] == final) ? f(P , i-1, final): f(P,i-1,6-P[i]-final) + (1LL&lt;&lt;(i-1)); 例题17 计数排序 例题19 UVa11549 Floyd判圈法 long long a = k,b = k;do&#123; a = next_num(a); b = next_num(b); if(b &gt; ans) ans = b; b = next_num(b); if(b &gt; ans) ans = b;&#125;while (a != b); 例题24 三维最大子空间 二分二分模板= = //整数while(l &lt; r)&#123; int m = l + (r - l + 1) / 2; if(check(m)) l = m; else r = m - 1;&#125;l is answer //浮点数while (r - l &gt; 0.000001) &#123; double m = (r + l )/2; if (check(m)) &#123; l = m; &#125;else r = m;&#125;//单调时最小位置i = lower_bound(a,a + n,val) - a; 例题12 最小品质因子最大值最小a值最大b LA4254 白书手写题解== LA4253 返回值有意义的二分(判存在性,极角维护左右) 二维降,扫描线 例题20 LA3905 流星最多的时间 扫描线计数法(碰到起点+1) 抽象为起点和终点,由于是直线,二维= 一维∩一维 整数计算 例题23 LA3695 找一个矩形边上包括尽量多的点 求平行坐标轴的矩形边上最多点覆盖 扫描线,对所有点依据x排序,对所有y排序,unique for (int a = 0; a &lt; m; a++) &#123; for (int b = a + 1; b &lt; m; b++) &#123; int low = y[a], high = y[b];//枚举平行于x轴的两条边 int k = 0,M = 0; for (int i = 0; i &lt; n; i++) &#123;//扫描平行于y轴的边 if (i == 0 || p[i].x != p[i-1].x) &#123; k++;//统计x坐标个数 on[k] = on2[k] = 0; left[k] = k == 0 ? 0 : on2[k-1] - on[k-1] + left[k-1];//y = low (+) high 上已经有多少点 &#125; if(p[i].y &gt; low &amp;&amp; p[i].y &lt; high) on[k]++;//左记录线记录low,high之间的边(不含端点) if(p[i].y &gt;= low &amp;&amp; p[i].y &lt;= high) on2[k]++;//右记录线记录low,high之间的边(含端点) &#125; if(k &lt;= 2) return n;//总共只有两个坐标(这里不用再对x排序- -) for (int j = 1; j &lt;= k; j++) &#123; ans = max(ans,on2[j] + M + left[j]);//ans = max(on2[j] + on2[j-1] + left[j] - left[j-1]) M = max(M,on[j] - left[j]);//维护on[i] - left[j]的最大值 &#125; &#125;&#125; 悬线法 例题22 LA3029 最大子矩阵. 把每个格子向上延伸的连续空格看成一条悬线 有障碍物的区域中的最大子矩阵 (USACO用一个height数组过的(USACO6.1)) 训练指南是维护up,l,r三个数组,l,r标记以up为高度的矩形最左和最右的位置 01 GUY 例题25 LA2965 尽量多的串使得大写字母都出现偶数次 =&gt;用二进制位表示字母 =&gt;xor == 0 =&gt;枚举前一半,而后枚举后一半中途相遇 码农题 例题9 UVA11210 麻将(判断”听牌”) Ugly Windows 代码量不大但是有坑 LA3667 最少刻度 二进制bfs扩展参考 for (i = 0; i &lt; N; i++) &#123; if (cur.found &amp; (1&lt;&lt;i)) continue;//当前存在 int v = *iter + arr[i];//扩展节点 if(cur.st.find(v) != cur.st.end()) continue; if(v &gt; MAX) continue; next = cur; next.st.insert(v); for (set&lt;int&gt;::iterator iter2 = cur.st.begin();//进一步扩展 iter2 != cur.st.end(); iter2++) &#123; int x = abs(v - *iter2); if (idx[x] != -1) &#123; next.found |= (1&lt;&lt;idx[x]); &#125; &#125; if (next.found != cur.found) &#123; q.push(next); &#125;&#125; ​ UVA10825 乘2..m后所有位数字还是那些…..枚举最后一位生成所有位数 LA3621 最少几次乘除得到${X}^{n}$.迭代加深搜索+剪枝 trick writein &amp; readin inline int readint()&#123; char c = getchar(); while(!isdigit(c)) c = getchar(); int x = 0; while(isdigit(c))&#123; x = x * 10 + c - '0'; c = getchar(); &#125; return x;&#125;int buf[10];//global varibleinline void writeint(int i)&#123; int p = 0; if(i == 0)p++; else while(i) &#123; buf[p++] = i % 10; i /= 10; &#125; for(int j = p - 1;j &gt;= 0;j--) putchar('0' + j);&#125; 例题及习题指 &lt;&lt;算法竞赛入门经典(训练指南)&gt;&gt;对应例题 私在vjudge中开题集(因为uva墙外服务器是在是慢啊…) 1-1 1-2-1 1-2-2 1-3 求LA5704 Yummy Triangular Pizza传统题解,oeis是个好地方]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BYE Freshman]]></title>
      <url>http://renld.github.io/2016/07/09/byefresh/</url>
      <content type="html"><![CDATA[据说珠海最好的景点.是澳门. 于是在离开中珠的前一天,与两位同样留有签注的少年同行. 一脸懵逼的自助游还是挺新奇与快乐的.第一次体会到资本主义的奢靡社会(并不..刚刚在高铁站的物价明明比澳门还贵…)坐了很久很久的K3到了拱北口岸.去KFC扒了两口汉堡换了一些葡币便过关了..异常地平静安和的刷了两次卡就过了.. 真的走着出境的感觉.还是挺奇妙的.但是..还是没有什么异样… 资本主义的天并没有想象中的不一样..倒是珠海会更多几分白云.没有遇见诗壕的豪华游艇倒是一进去就被发了两张卡.恩..三个人发了两张,我一脸莫名的去要了一张发现是新葡京…于是大概就默认是那位女士觉得我太真诚单纯善良了(微笑脸:) 随步到公交站后随意选了一个似曾相识(也就是前一天百度的..)地名,做了好久好久的车,莫名来到了氹仔=.=填海造路的场景还是挺有意思的.寸土寸金四个字被潇航说出莫名的耳熟.不过话说回到这个围湖造田的地域他们会不会有些惊奇. 正当我们觉得或许坐错车/坐过站的时候.似乎到了那个似曾相识的地名(官街?) 下去后发现居然是一条小吃街.顿时两眼发光去点了一个猪扒包-.菠萝包皮配上猪扒的感觉回味到现在都很奇妙.只可惜当时一时错过了猫山王雪糕的宣传.真的架势做的很大.而后混了进去找了一家纪念品店大家又兴奋起来.凯丹给女友送去一张明信片,我和潇航各自买了一个筹码做个留恋(其实觉得纪念品这种东西似乎送人就少了几分纪念意义?) 散步去某个葡萄牙博物馆后又走了一圈.发现澳门这个神奇的地方居然几乎只有单行道相通,所有公交车也都是环线而行.(为什么我对右侧驾驶又毫无新奇感..或许反正是环线吧…)绕了一些路太阳实在太大于是便找个位置歇息准备去大三巴签个到. 路上碰到一个好心的爷爷努力用国语告诉我们在哪下车.但其实当我们看到新葡京的真相后便也大抵知晓我们回到了景区.旁边几个必胜典当行欢迎着rmb消费,金光闪闪的外表下,这就是当时和同桌说的”我才不会去当兵,我还想享受一点资本主义的奢靡生活”? 或许这只是表面的绚烂,还没感受到内在的浮华吧. 到了牌坊后又是一脸无感的拍照纪念.唯一有(新)趣(奇)一些的或许是旁边有某著名教派的宣传摊位. 不过牌坊旁边便是澳门博物馆了.这大概是这场旅行最惊艳的地方了,8mop的学生票简直告诉了我博物馆的奇妙世界.几乎每一个展品都有互动步骤,入门处的四大发明让人忍不住留影.教课书实在太过枯燥与乏味,当真正与活字印刷机相邻之后,简直被古人的智慧震撼. 博物馆中努力还原澳门的历史,许多的小人小像栩栩如生.特别有趣的是一排留声空间留下了当年卖货郎的叫卖声,吆喝语气.动人而又客人.平常一日的浏览居然一次一次地被带来惊喜,这大概是那儿最美的东西吧. 外面烈日,内部空调,摆设不经意间简直华丽到像天堂.这或许是第一个我想再来一次的博物馆吧. 好吃的?! 真的国际象棋 好漂亮的花轿. money 出去后拜见了牌坊后的墓地.门口记录着天主教的殉教着,推开门后,第一次被天主教的圣洁和肃穆震撼,内心似乎多了一些感受,又似乎无法表达出来那份震惊和内心发出的敬意吧.或许这是与牌坊门口那某著名教派所相异相差的地方. 慕名去马嘉烈花光了最后几十mop,很香的蛋挞,同行的男生十分喜欢.可我或许曾在培楠宿舍蹭过一个,也没有那么惊艳.可惜对面银联不能取钱,而名气太大的店子居然拒收RMB..想给预约了这种手信的同学花了很大心力找了几个人才把身上最后20rmb换成了20mop带了两个回去. 澳门此行不知道也没有遗憾.不过被一些东西惊艳后便算是满足和感动了.见识了一处新的风景大概也能理解别人周游世界的理想了.看到这个世界中很多新奇而有趣的东西,作为人生的向往,或许也不错吧. 之后便是吃饱喝足元气满满的准备回迁了.完全没想到居然有那么多的物资.五点折腾到八点半后洗了个澡便四肢发软的躺倒床上.到了饭点后与宿舍在东北人家聚了个餐,也算了在中珠外四大食堂签了一遍到了.麻婆豆腐味道很不错.就像珠海这边的川菜很棒一般.(尽管四川/重庆同学并不这么认为). 岐关车外迎着保安的敬礼也算是告别中珠了.去年当时也大概是这几天知道被移动录取.然后发现是一个神奇的四年珠海学院.不过更神奇的是.发现中山大学居然有个珠海校区…不过算是邂逅也算是意外地感受了这里的蓝天白云和面朝大海后的春暖花开.秋天的中珠的云美如画,而夏日的滚滚浓云便印证着孙逸仙魔法学校的名号.清空烈日的常态下,雨珠在大树垂须下的晶莹令人称奇.第一次感受春风十里的舒适也是第一次感受到蓝天白云的纯净.大概就像微信地图中给它的定义—景点. 当了一年的freshman似乎也就第一个学期特别拼,而看到努力学习和绩点并不成正比后第二个学期便开始努力调整习惯开始适当地去体验和感受生活.(似乎变成了半条咸鱼?)不再日出而作全心投入的结果当然不是更加优秀的绩点(刚刚出了两门公选后均绩成功掉下了4..却似乎没有太多莫名的忧伤),反而觉得又像高三一样,更加追求的是有趣的生活,和舍友的关系也日渐亲密起来.没加社团或许是个遗憾,但是通过ACM的打拼认识了很多很优秀的少年少女,也算是心满意足. 和别人聊天时发现自己再过一个月也成了学长.或许要努力把自己变得更加成熟和强大一点才能胜任吧.也可以借此机会好好玩一下羊城的风光,东校寒假的伙食配置简直对它充满的向往和期望.暑假拉开了真正的序幕,努力把自己打造成一个更强大的人吧.]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Primary Engineering Practice]]></title>
      <url>http://renld.github.io/2016/07/04/egt1/</url>
      <content type="html"><![CDATA[engerineering time Finding 十多天了谢谢两条大腿带飞😭 每天都可以准时吃饭非常爽 hhhh虽然每天也是花式懵逼地坐在一边有点惭愧 (:з」∠)总之非常开心的（😘 —by rxy 很有意思的课程,怪不得那么多人怀念小学期. disappear实训最开始三天去参加4+2了,把两个队友抛在珠海焊电路板感觉还是有一些愧疚.4+2被淘汰那天看到电路板真是那天唯一的欣慰与感动.有点可惜错过了这份雕琢的经历.不过这张照片还是在那天朋友圈刷屏中特别醒目. learn C不过4+2回来后,对于位运算有莫名的信心.所以在回来前几天发现都是在水一些C语言的知识后..觉得实训怎么这么水啊…..每天都能早早的水完task然后就快乐的离场吃饭… 那两三天真的过得挺轻松的…每天讲一点大一最开始自学的C语言…然后就水几个task. 然后发现俊爷在快乐的刷进度0.0舍友对他也赞美有嘉233 不过真的水到好无聊..于是就开始大冒险… 有一次debugTASK看了两个后直接把文杰喊了过来验收.. 然后水到倒数第二个时候发现..居然是一道写代码题. 然后文杰留下了一句评价 空手套白狼 FPGA整个实训中最恐怖的传说便是烧掉一块FPGA板子了 因为淘宝价1200…简直精贵了整个实验的配置.. 每一天都有烧板子的消息传来…没想到有一天终于轮到了我们组.. 调试了一个下午后发现小车有毒…居然不能脱离USB线 把问题归罪到H桥后去找老师更换H桥… 过了十分钟队长还没回来..去看一眼得知板子坏了… 那个心情还是挺忐忑的.. 那个TA顺便恐吓了我们一人200的要求= = 然后似乎那次验收顺便收货了一个B… (字居然写的这么丑了-.-) 最后一天整整一个上午…都ELF过去..问文杰= =我们又被”恐吓”恭喜中奖了… 中午得知换了台电脑可以烧了..兴奋地不会宿舍洗澡睡觉直接滚去实验室干活了233 Teachers移动的TA果然超级赞..发现他们不在电工群后就去私加了一个TA的QQ..想要问要不要带板子和小车来上课..结果那天TA8:50回了我一句不要= =///// 见识了文杰师兄的卖萌.简直有趣到可怕..居然把我的语气语调带的有点标普了..然而文杰似乎也是fu南的??!!每次都被莫名喊成”大腿”立得一手好flag..于是守候到了实验室关门的晚霞0.0可惜文杰居然不要我爆照..真的好萌XD huangkai老师的慕尼黑工业大学的团队0….0据说高薪聘请过来的..似乎让我在雅礼的招生群装了一个逼…另外上课似乎觉得我们大一还是通识教育..鼓励我们创新精神?几次样例代码都有一些小bug..什么Switch大写了首字母..接口多了一个参数!!?….估计就是防止我们copy&amp;paste的小tirck吧.. 不过说实话..被坑(水)久了之后..还是觉得TA讲课会切中要害一些. 另外外教这种生物..在我出国梦暗淡之后…就成了我自习的一个借口了2333 else1这几天每一天晚上都好悠闲啊2333.. 终于享受到了一年级学生应有的愉悦 水完了一本\… 不知道谁安利的书… 一章学一个引擎简直可怕.. 然后美化博客debug很久..换了个域名2333 …于是每次我都是朋友圈错乱感的制造者 else2这次实训两个室友都当上了他们组的大腿2333 每天回宿舍给我各种秀-.- 似乎看到他们下个学期冉冉升起的学霸希望 而且我们宿舍崛起的绩点23333 最后有一点想提的是..这几天伙食也是经历了由万象纷呈到过零丁洋再到普通中珠伙食的经历.给大家一点希望吧..中珠太美..但是暑假还是东校伙食美(每次逛食堂都能快乐地..抓一盘菜233) 面向硬件的编程主要是对于宏文件的套用 说白了,就是学会用模板. 很不幸的是苦于找模板.忘模板…这样就还是很尴尬. –原文抬头 预备工作 加载C盘驱动) Quartus载入单片机,载入sof文件 打开eclipse,创建工程,载入NIOS_Sys.sopcinfo(也在上面那个链接中) eclipse编译的时候需要忽略两个选项. FPGA文档 头文件//standard C library#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdint.h&gt; //like int16_t;#include &lt;stdbool.h&gt;//else#include "io.h"#include "system.h"#include "altera_avalon_pio_regs.h"#include &lt;altera_avalon_performance_counter.h&gt;//what?#include "sys/alt_irq.h"#include "adc_spi_read.h"#include "terasic_includes.h"#include "alt_types.h" #include "terasic_includes.h"/*#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // malloc, free#include &lt;string.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt; // usleep (unix standard?)#include &lt;io.h&gt;#include "sys/alt_flash.h"#include "sys/alt_flash_types.h"#include "alt_types.h" // alt_u32#include "altera_avalon_pio_regs.h" //IOWR_ALTERA_AVALON_PIO_DATA#include "sys/alt_irq.h" // interrupt#include "sys/alt_alarm.h" // time tick function (alt_nticks(), alt_ticks_per_second())#include "sys/alt_timestamp.h" #include "sys/alt_stdio.h"#include "system.h"#include &lt;fcntl.h&gt;#include "terasic_debug.h"typedef int bool;#define TRUE 1#define FALSE 0*/ #include "alt_types.h"/*typedef signed char alt_8;typedef unsigned char alt_u8;typedef signed short alt_16;typedef unsigned short alt_u16;typedef signed long alt_32;typedef unsigned long alt_u32;typedef long long alt_64;typedef unsigned long long alt_u64;*/ 基本IO//基本亮灯方式IOWR(LED_BASE,0,0xff);//机器key按压状态KEY_BASE // write registerIOWR(LED_BASE,0,led);int value = 1;//按照输出数的二进制位亮灯IOWR_ALTERA_AVALON_PIO_DATA( PIO_LED_BASE, value ); // read register, 普通情况下是3 if(val ^ 3)说明被按键,自动带有防抖int value = IORD_ALTERA_AVALON_PIO_DATA( PIO_LED_BASE ); 中断中断就是在程序任意阶段突然发生的一个函数 清空中断标记之后还原.  Initialization Enable the interrupt for the specific input IOWR_ALTERA_AVALON_PIO_IRQ_MASK(, );  Set the edge capability IOWR_ALTERA_AVALON_PIO_EDGE_CAP(, )  Register handler alt_ic_isr_regsiter( , ,, , ) volatile static char key = 0;unsigned int nirq_isr_context;void nIRQ_Initial(void);//记得在main中initialvoid isr_function(void);//记得声明在前面...void nIRQ_Initial(void)&#123; //todo: set up interrupt function IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,3);//3 = 1 | 2,表示1和2输入时都有反应 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);//这句话是清空中断状态 alt_ic_isr_register( 0, 1,isr_function, 0, 0 );//声明中断函数&#125;void isr_function(void)&#123; //do something IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);&#125; 计时模块usleep(264762)大概是一秒. //开始计时器 PERF_RESET(PERFORMANCE_COUNTER_BASE); PERF_START_MEASURING(PERFORMANCE_COUNTER_BASE); PERF_BEGIN(PERFORMANCE_COUNTER_BASE,1);//1在这里是个标示，标示1号位的计数 重复计数会累加， /* 想要测试间的函数部分 ，每一个测试时间块设置一个函数出去，比如这里测的print函数 当然不写函数也是可以的,可以把下面的"printf"改成"for"便可以测试for循环的时间 所以我认为是在第一个BEGIN和END之间找到一个关键字(如果把下面的2改成1,它会记成上面的时间) */ PERF_END(PERFORMANCE_COUNTER_BASE,1);//结束时间计数，对应上面1的标志 PERF_BEGIN(PERFORMANCE_COUNTER_BASE,2); //usleep(1000);//这个是一个sleep封装，下面的for循环暴力模拟 //for(i = 0;i &lt; 200000 ;i++); 如果要测试usleep时间的话那么就得写在第2个 计时区域里面 PERF_END(PERFORMANCE_COUNTER_BASE,2); //最后一个标志stop PERF_STOP_MEASURING(PERFORMANCE_COUNTER_BASE); //按照它的模板输出时间 perf_print_formatted_report(PERFORMANCE_COUNTER_BASE,alt_get_cpu_freq(), 2,"printf","usleep","IOWR");//第一个是输出时间的种类，后面的是要求测试的函数 //printf("Product of entered matrices: %d \n",*timer); perf_get_total_timealt_u64 perf_get_total_time (void* hw_base_address)&#123; return perf_get_section_time (hw_base_address, 0); &#125; subTask Volatilevariables这个实在eclipse里面把编译选项级别改高(level2)后,很多变量被”优化”到不能修改的尴尬地步. subTask 存储位置//不同存储位置声明 ,onclip是会快一些的.#define USE_ONCHIP_MEMORY #ifdef USE_ONCHIP_MEMORY int first[10][10] __attribute__ (( section ( ".onchip_memory2_0" ))); int second[10][10] __attribute__ (( section ( ".onchip_memory2_0" ))); int multiply[10][10] __attribute__ (( section ( ".onchip_memory2_0" ))); #else int first[10][10]; int second[10][10]; int multiply[10][10]; #endif 读入电压#define START_FLAG 0x8000 //标记已经测量#define DONE_FLAG 0x8000const int adc_channel = 2;//输入信号端口volatile static char key = 0;//按键(中断)int done = 0;//成功读取电压值int spi_response; // 读取电压值unsigned int nirq_isr_context;void nIRQ_Initial(void);//记得在main中initialvoid isr_function(void);//记得声明在前面...void nIRQ_Initial(void)&#123; //todo: set up interrupt function IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,3);//3 = 1 | 2,表示1和2输入时都有反应 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);//这句话是清空中断状态 alt_ic_isr_register( 0, 1,isr_function, 0, 0 );//声明中断函数&#125;void isr_function(void)&#123; //set the desired channel by writingit to the SPI bus.绑定?(terry) IOWR(ADC_SPI_READ_BASE,0,adc_channel);//初始接口信号,必须每次中断初始化,取消START_FLAG // start the converstion by writingthe START_FLAG to the SPI bus.(terry) IOWR(ADC_SPI_READ_BASE,0,adc_channel | START_FLAG);//写入当前接口信号 done=0;//done去掉也可以实现任务. while(!done) &#123; //只有最高位为1才代表SPI从ADC读取完成。(terry) spi_response = IORD(ADC_SPI_READ_BASE,0); //读出当前借口信号 done = (spi_response &amp; DONE_FLAG); //如果读出成功 &#125; int adc_value = spi_response &amp; 0xFFF; //取有效位电压值 printf("voltage = %d\n", adc_value); IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);&#125;int main()&#123; nIRQ_Initial();//中断初始化 while(1) &#123; //中断触发,输出ADC值 &#125; printf("done = %d\n",done); //检查时DONE_FLAG return 0;&#125; SUBTASK 测量实际电压数值//增设这个函数的目的是为了去噪.(平均值采样分析)double test()&#123; IOWR(ADC_SPI_READ_BASE,0,adc_channel);//初始接口信号 done=0; IOWR(ADC_SPI_READ_BASE,0,adc_channel | START_FLAG);//写入当前接口信号 while(!done) &#123; spi_response = IORD(ADC_SPI_READ_BASE,0); //读出当前借口信号 done = (spi_response &amp; DONE_FLAG); //如果读出成功 &#125; int adc_value = spi_response &amp; 0xFFF; //取有效位电压值 printf("voltage = %lfV\n", 3.3*adc_value/4096); return 3.3*adc_value/4096;&#125; 来自terry博客对于信号处理的一段解释,我觉得很有意思 ADC 将模拟型号转换成数字信号，通常地， 假如传感器测量范围是 0V－3.3V，ADC 是 12bit， 0V 时是 0000 0000 0000，3.3V 时是 1111 1111 1111。 由于转换是线性的所以 voltage = adc_value * 3.3 / 4096。(2^12 = 4096) 这样之后mask也很好理解了 真正有意义的位是后面三个十六进制位(也就是后面12位01位) 那么mask = 0x8000 = 1000 0000 0000 0000 是首位掩码标记. adc_channel | START_FLAG 其实就是一个绑定,但是加上了一个mask(正常电压范围达不到mask) spi_response &amp; DONE_FLAG是在探测mask位是否有值,也就是检查start_flag spi_response &amp; 0xFFF 取出来的时候需要提取有效部分,也就是后面12位. 举个例子(由于md样式|表示成or): -变量名/表达式 -对应二进制数值 adc_channel = 2 0000 0000 0000 0010 adc_channel or START_FLAG 1000 0000 0000 0010 spi_response = 1000 0011 1111 1111 1000 0011 1111 1111 spi_response &amp; DONE_FLAG 1000 0000 0000 0000 spi_response &amp; 0xFFF 0000 0011 1111 1111 START_FLAG和DONE_FLAG 1000 0000 0000 0000 PWMPWM就是用数字信号的比率实现模拟信号的高低 硬件实现/* * main.c * * Created on: 07.11.2012 * Author: karl_ee */#include "main.h"int main()&#123; unsigned int i,j; unsigned long phase1=0x0,phase2=0x000//分别是任务一和任务二的初始相位 ,duty1=0x1388,duty2=0x1388//分别是任务一输出和任务二输出占空比 ,period=0x186A//前面的相位和占空比需要与这个period作比 ,enable=0x1;//0x3才能输出两个信号 while(1) &#123; motor_setting(phase1,duty1,phase2,duty2,period,enable); for(i=0;i&lt;2550;i++) for(j=0;j&lt;2550;j++);//delay &#125;&#125;/* * motor_setting.c * * Created on: 07.11.2012 * Author: karl_ee * input parameters: * phase: range from 0 to value of period * duty cycle: set to number=period*percentage of duty cycle * period: according to the freq of cpu, * normally the period should be set to the value * that makes the freq of pwm waveform to be 15 k * e.g., for 50MHz, value should be 3333(0xD05) * enable:'0' represents off, '1' is on, lease significant bit is for channel 1 * e.g., for channel 1 on and channel 2 off, enable=0x1 * */#include "motor_setting.h"void motor_setting(unsigned long phase1, unsigned long duty1 ,unsigned long phase2, unsigned long duty2 ,unsigned long period,unsigned long enable)&#123; unsigned long * pwm_en= (unsigned long *)PWM_EN; unsigned long * pwm_period=(unsigned long *)PWM_PERIOD; unsigned long * pwm_phase1=(unsigned long *)PWM_PHASE1;//这个是位置=&gt;.h头文件 unsigned long * pwm_phase2=(unsigned long *)PWM_PHASE2; unsigned long * pwm_duty1=(unsigned long *)PWM_DUTY1; unsigned long * pwm_duty2=(unsigned long *)PWM_DUTY2; * pwm_en=enable; * pwm_period=period; * pwm_phase1=phase1; * pwm_phase2=phase2; * pwm_duty1=duty1; * pwm_duty2=duty2;&#125;/* * motor_setting.h * * Created on: 07.11.2012 * Author: karl_ee * input parameters: * phase: range from * duty cycle: * period: according to the freq of cpu, * normally the period should be set to the value * that makes the freq of pwm waveform to be 15 k * e.x for 50MHz, value should be 3333(0xD05) * enable:'0' represents off, '1' is on */#ifndef MOTOR_SETTING_H_#define MOTOR_SETTING_H_#include "system.h"#define PWM_EN PWM0_BASE#define PWM_PERIOD PWM0_BASE+1#define PWM_DUTY1 PWM0_BASE+2#define PWM_DUTY2 PWM0_BASE+3#define PWM_PHASE1 PWM0_BASE+4//#define PWM_PHASE2 PWM0_BASE+5void motor_setting(unsigned long phase1, unsigned long duty1,unsigned long phase2, unsigned long duty2, unsigned long period,unsigned long enable);#endif /* MOTOR_SETTING_H_ */ 顺着线索一路找下去可以在NIOSCar.qsf里面找到这样一段 #-------------------------------------------------------------#reuse above pins for PWM0-3#-------------------------------------------------------------set_location_assignment PIN_B6 -to PWM0Ch0set_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to PWM0Ch0set_location_assignment PIN_A6 -to PWM0Ch1set_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to PWM0Ch1 也就是说它把BASE赋给B6和A6位了,在DE0_Nano_User_Manual_v1.9.pdf里面大概12页找到对应管脚以及它上面的物理位置,然后就有输出信号了. 软件实现unsigned int i;for (i=1; i &lt; 100; i++)&#123; if (i&lt;30) IOWR(PIO0_BASE, 0, 0);//这里的宏定义参考ppt else IOWR(PIO0_BASE, 0, 1);&#125; 然后对应这一段 #============================================================# GPIO_0, GPIO_0 connect to GPIO Default#============================================================set_location_assignment PIN_D3 -to GPIO_0[0]set_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to GPIO_0[0] RUN THE CAR/* 组合了一些函数在这里 能让小车run起来~~~ 1. 有两个头文件有毒..这里删了 2. 把main.h 和 motor_setting.h 仿制了一份 3. 采用pwm2,也就是pwm0后面两位的接口.*///standard C library#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdint.h&gt; //like int16_t;#include &lt;stdbool.h&gt;//else#include "io.h"#include "system.h"#include "altera_avalon_pio_regs.h"#include &lt;altera_avalon_performance_counter.h&gt;//what?#include "sys/alt_irq.h"#include "alt_types.h"typedef signed char char_8;typedef unsigned char uchar_8;typedef signed short short_16;typedef unsigned short ushort_16;typedef signed long long_32;typedef unsigned long ulong_32;typedef long long long_64;typedef unsigned long long ulong_64;//first mortor#define PWM_EN PWM0_BASE#define PWM_PERIOD PWM0_BASE+1#define PWM_DUTY1 PWM0_BASE+2#define PWM_DUTY2 PWM0_BASE+3#define PWM_PHASE1 PWM0_BASE+4#define PWM_PHASE2 PWM0_BASE+5void motor_setting(unsigned long phase1, unsigned long duty1, unsigned long phase2, unsigned long duty2, unsigned long period,unsigned long enable)&#123; unsigned long * pwm_en= (unsigned long *)PWM_EN; unsigned long * pwm_period=(unsigned long *)PWM_PERIOD; unsigned long * pwm_phase1=(unsigned long *)PWM_PHASE1; unsigned long * pwm_phase2=(unsigned long *)PWM_PHASE2; unsigned long * pwm_duty1=(unsigned long *)PWM_DUTY1; unsigned long * pwm_duty2=(unsigned long *)PWM_DUTY2; * pwm_en=enable; * pwm_period=period; * pwm_phase1=phase1; * pwm_phase2=phase2; * pwm_duty1=duty1; * pwm_duty2=duty2;&#125;//仿造PWM0函数写下的PWM2宏定义以及函数#define PWM_EN1 PWM2_BASE#define PWM_PERIOD1 PWM2_BASE+1#define PWM_DUTY11 PWM2_BASE+2#define PWM_DUTY21 PWM2_BASE+3#define PWM_PHASE11 PWM2_BASE+4#define PWM_PHASE21 PWM2_BASE+5void motor_setting1(unsigned long phase1, unsigned long duty1, unsigned long phase2, unsigned long duty2, unsigned long period,unsigned long enable)&#123; unsigned long * pwm_en= (unsigned long *)PWM_EN1; unsigned long * pwm_period=(unsigned long *)PWM_PERIOD1; unsigned long * pwm_phase1=(unsigned long *)PWM_PHASE11; unsigned long * pwm_phase2=(unsigned long *)PWM_PHASE21; unsigned long * pwm_duty1=(unsigned long *)PWM_DUTY11; unsigned long * pwm_duty2=(unsigned long *)PWM_DUTY21; * pwm_en=enable; * pwm_period=period; * pwm_phase1=phase1; * pwm_phase2=phase2; * pwm_duty1=duty1; * pwm_duty2=duty2;&#125;int a = 1;volatile static char key = 0;unsigned int nirq_isr_context;void nIRQ_Initial(void);//记得在main中initialvoid isr_function(void);//记得声明在前面...void nIRQ_Initial(void)&#123; //todo: set up interrupt function IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,3);//3 = 1 | 2,表示1和2输入时都有反应 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);//这句话是清空中断状态 alt_ic_isr_register( 0, 1,isr_function, 0, 0 );//声明中断函数&#125;void isr_function(void)&#123; a = !a; //这句话是用来测试是否进入中断的... printf("cs - %d\n",a); IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);&#125;int main()&#123; nIRQ_Initial();//注意初始化!!!!!!!!! unsigned int i, j; unsigned long phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; unsigned long duty1=0x0000, duty2=0x0000, duty3=0x0000, duty4=0x0000; unsigned long period=0x186A,enable=0x3; //初始化,马达不会跑 motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); while(1) &#123; if(a)//小车的普通状态,倒着跑 &#123; phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x1000, duty2=0x0000, duty3=0x1000, duty4=0x0000; period=0x186A,enable=0x3; &#125; else//按键后改变的状态,正向跑 &#123; phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x0000, duty2=0x1000, duty3=0x0000, duty4=0x1000; period=0x186A,enable=0x3; &#125; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); for(i=0;i&lt;2550;i++);//这里一个莫名的delay...或许数据可以改小一点.. //for(j=0;j&lt;2550;j++);//delay &#125; return 0;&#125; 今天真的挺迷的…check电路时候一拔USB之后小车断电, 测了几次后FPGA漏电然后各种重新烧重新测..似乎就像搭这个博客一样… 反正码农嘛..写烂了debug后丢掉就好. 超声波模块 这次实验选用了GPIO1的一些管脚,注意是与GPIO0的方向相反 VCC和地线采用JP2 的11 和12口,提供4V电压(觉得这里可以优化成3.3V) RX口和TK口对应NIOSCAR.qsf line355~line365行的引脚对应,分别对应模块的TK和RX #-------------------------------------------------------------#reuse above pins for New Ultrasound 0#-------------------------------------------------------------#set_location_assignment PIN_F13 -to GPIO_1[0]#set_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to GPIO_1[0]#set_location_assignment PIN_T15 -to GPIO_1[1]#set_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to GPIO_1[1]set_location_assignment PIN_F13 -to New_Ultrasound0_rxset_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to New_Ultrasound0_rxset_location_assignment PIN_T15 -to New_Ultrasound0_txset_instance_assignment -name IO_STANDARD "3.3-V LVTTL" -to New_Ultrasound0_tx 然后这次实验有三个task,分别是对光敏,距离和时间的检测 //standard C library#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdint.h&gt; //like int16_t;#include &lt;stdbool.h&gt;//else#include "io.h"#include "system.h"#include "altera_avalon_pio_regs.h"#include &lt;altera_avalon_performance_counter.h&gt;//what?#include "sys/alt_irq.h"#include "alt_types.h"typedef signed char char_8;typedef unsigned char uchar_8;typedef signed short short_16;typedef unsigned short ushort_16;typedef signed long long_32;typedef unsigned long ulong_32;typedef long long long_64;typedef unsigned long long ulong_64;//中断int a = 1;volatile static char key = 0;unsigned int nirq_isr_context;void nIRQ_Initial(void);//记得在main中initialvoid isr_function(void);//记得声明在前面...void nIRQ_Initial(void)&#123; //todo: set up interrupt function IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,3);//3 = 1 | 2,表示1和2输入时都有反应 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);//这句话是清空中断状态 alt_ic_isr_register( 0, 1,isr_function, 0, 0 );//声明中断函数&#125;void isr_function(void)&#123; a = !a; //这句话是用来测试是否进入中断的... printf("cs - %d\n",a); IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);&#125;//操作函数,Address是传入地址,x是对应命令unsigned int light(long Address,long x)&#123; unsigned int i; unsigned char res_l, res_h; Uart_send_byte(Address, 0xe8); for (i = 0; i &lt; 2000; i++) ; Uart_send_byte(Address, 0x02); for (i = 0; i &lt; 2000; i++) ; Uart_send_byte(Address,x);//修改的函数.. res_h = Uart_receive_byte(Address); for (i = 0; i &lt; 1000; i++); res_l = Uart_receive_byte(Address); return (((unsigned int) res_h) &lt;&lt; 8) + res_l;&#125;#define task3 //这里改成123分别测试int main()&#123; printf("HELLO WORLD\n"); nIRQ_Initial(); while(1)&#123; ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数#ifdef task2 int cnt = 0,i; for(i = 0;i &lt;5;i++) &#123; cnt += ultrasound_read(NEW_ULTRASOUND0_BASE, a);//a = 0, 5m; a = 1, 11m; &#125;//消除噪音 cnt /= 5; printf("%d.%dm\n",cnt/1000,cnt%1000);#endif#ifdef task1 printf("%d\n",light(NEW_ULTRASOUND0_BASE,0xa0) );#endif#ifdef task3 int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ; printf("%d.%dm\n", clk / 1000000 , clk % 1000000); //相对来说,这个测距更为精确，但是探测很多次之后似乎会死机？？？#endif &#125; return 0;&#125; light函数传入x小结 传入参数 对应效果 0xa0 光敏传感器(1ms探测耗时) 0x1e 3m,返回测量时间 x from 0x01 to 0x2f (63 ~ 93) ~ 577 * x µs 0xb0 0xb2 5m,33ms,返回mm 返回µs 0xb8 0xba 11m,68ms,返回mm 返回µs 0xc4 0x45 5s 1s 休眠等待 主要函数/**************************************************************************** Function: unsigned int ultrasound_read(long Address, unsigned char settings) Description: // This function receives one Byte via the corresponding UART from the Address Precondition: Call ultrasound_init(long Address) prior to use this function Parameters: long Address - Address of the UART (and therefore of the Ultrasound) unsigned char settings - defines maximum distance to measure (1: 11m; 0: 5m) Returns: unsigned int - distance in mm Remarks: Distance in meter ***************************************************************************/ 另外的笔记进一步的省电措施 如果用户希望将省电进行到底 发送 0xc1 关 LED 探测显示，以降低电流消耗。 发送0xc0 可以恢复 LED 探测显示。 配置方法非常简单，向本模块发送指令时序：“I2C 地址 + 寄存器 2 +0xc0/0xc1”即可，发送完成后请延时至少 2 秒，以让系统自动完成配置。并开始按照新配置工作。 测距范围 同步进程单函数同步#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "includes.h"#include "io.h"/* Definition of Task Stacks */#define TASK_STACKSIZE 2048#define N_TASKS 8 //最大进程数OS_STK taskStk[N_TASKS][TASK_STACKSIZE];//申请栈空间void task(void * pdata)&#123; int pos = (int) pdata; while(1) &#123; printf("%d",pos);//调试输出当前改变的位 IOWR(LED_BASE, 0, IORD(LED_BASE,0) ^ (1&lt;&lt;pos));//改变当前位的值 OSTimeDlyHMSM(0, 0, (pos + 1), 0);//每一个延迟时间,注意不能设为0. &#125;&#125;int main(void)&#123; OSInit(); int idx; for(idx = 0;idx &lt; N_TASKS; ++idx) &#123; OSTaskCreate( task,//同步进程函数 (void*)idx,//id(传入task函数参数) &amp;taskStk[idx][TASK_STACKSIZE-1],//取最后一位地址 idx+1);//优先级 //成功之后返回0 &#125; OSStart();//不会初始化到这里 return 0;&#125; 双函数同步_努力异步#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "includes.h"#include "io.h"/* Definition of Task Stacks */#define TASK_STACKSIZE 2048OS_STK task1_stk[TASK_STACKSIZE];OS_STK task2_stk[TASK_STACKSIZE];/* Definition of Task Priorities */#define TASK1_PRIORITY 1#define TASK2_PRIORITY 2const char msg1[]=&#123;89,111,117,32,115,111,108,118,101,100,32,116,104,105,115,32,116,97,115,107,33,10&#125;;const char msg2[]=&#123;71,111,111,100,32,106,111,98,33,32,89,111,117,32,97,114,101,32,97,119,101,115,111,109,101,33,10&#125;;void Task1(void* pdata)&#123; while (1) &#123; OSTimeDlyHMSM(0, 0, 7, 250);//这段时间走task2就好,其实没有设置的很精 int i; for(i=0; i&lt;sizeof(msg1); i++) &#123; printf("%c",msg1[i]); IOWR(LED_BASE, 0, (1 &lt;&lt; (i &amp; 0x7) ));//同时用亮灯展示当前输出位,顺时针 OSTimeDlyHMSM(0, 0, 0, 250); &#125; &#125;&#125;void Task2(void* pdata)&#123; while (1) &#123; int i; for(i=0; i&lt;sizeof(msg2); i++) &#123; printf("%c",msg2[i]); IOWR(LED_BASE, 0, (1 &lt;&lt; 8-(i &amp; 0x7) ));//逆时针 OSTimeDlyHMSM(0, 0, 0, 250); &#125; OSTimeDlyHMSM(0, 0, 7, 250);//这段时间走task1就好,其实没有设置的很精确. &#125;&#125;int main(void)&#123; OSInit();//初始化 //声明task OSTaskCreate( Task1, (void*)0, (void *)&amp;task1_stk[TASK_STACKSIZE-1], TASK1_PRIORITY); OSTaskCreate( Task2, (void*)0, (void *)&amp;task2_stk[TASK_STACKSIZE-1], TASK2_PRIORITY); //start multitasking OSStart(); return 0;&#125; 很遗憾的是最后没有完全理解另一个进程同步函数, 在尝试的过程中发现那个函数也只是起了一个延时的作用,于是放弃了调试 同步进程这种事让我想起了C++中也可以实现233于是完成的挺顺利的 最后几次看中珠的夕阳.可惜没邂逅彩霞 FINAL task: 完成小车避障功能 PID实现小车跟踪 努力实现创新功能 相关代码及注释… /* task1: 避障 task2: 包含中断的跟踪 状态一: 20cm 跟踪, 10cm 后退 状态二: 20cm 跟踪. task3: 跟着光强的方向走*/#define task2 //standard C library#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdint.h&gt; //like int16_t;#include &lt;stdbool.h&gt;//else#include "io.h"#include "system.h"#include "altera_avalon_pio_regs.h"#include &lt;altera_avalon_performance_counter.h&gt;//what?#include "sys/alt_irq.h"#include "alt_types.h"typedef signed char char_8;typedef unsigned char uchar_8;typedef signed short short_16;typedef unsigned short ushort_16;typedef signed long long_32;typedef unsigned long ulong_32;typedef long long long_64;typedef unsigned long long ulong_64;/*PWM信号输出,控制马达*///first mortor#define PWM_EN PWM0_BASE#define PWM_PERIOD PWM0_BASE+1#define PWM_DUTY1 PWM0_BASE+2#define PWM_DUTY2 PWM0_BASE+3#define PWM_PHASE1 PWM0_BASE+4#define PWM_PHASE2 PWM0_BASE+5//仿造PWM0函数写下的PWM2宏定义以及函数#define PWM_EN1 PWM2_BASE#define PWM_PERIOD1 PWM2_BASE+1#define PWM_DUTY11 PWM2_BASE+2#define PWM_DUTY21 PWM2_BASE+3#define PWM_PHASE11 PWM2_BASE+4#define PWM_PHASE21 PWM2_BASE+5void motor_setting(unsigned long phase1, unsigned long duty1, unsigned long phase2, unsigned long duty2, unsigned long period,unsigned long enable);void motor_setting1(unsigned long phase1, unsigned long duty1, unsigned long phase2, unsigned long duty2, unsigned long period,unsigned long enable);//中断int a = 1;volatile static char key = 0;unsigned int nirq_isr_context;void nIRQ_Initial(void);//记得在main中initialvoid isr_function(void);//记得声明在前面...void nIRQ_Initial(void)&#123; //todo: set up interrupt function IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEY_BASE,3);//3 = 1 | 2,表示1和2输入时都有反应 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);//这句话是清空中断状态 alt_ic_isr_register( 0, 1,isr_function, 0, 0 );//声明中断函数&#125;void isr_function(void)&#123; a = !a; //这句话是用来测试是否进入中断的... printf("cs - %d\n",a); IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEY_BASE, 0x1);&#125;//超声波操作函数,Address是传入地址,x是对应命令unsigned int light(long Address,long x)&#123; unsigned int i; unsigned char res_l, res_h; Uart_send_byte(Address, 0xe8); for (i = 0; i &lt; 2000; i++) ; Uart_send_byte(Address, 0x02); for (i = 0; i &lt; 2000; i++) ; Uart_send_byte(Address,x);//修改的函数.. res_h = Uart_receive_byte(Address); for (i = 0; i &lt; 1000; i++); res_l = Uart_receive_byte(Address); return (((unsigned int) res_h) &lt;&lt; 8) + res_l;&#125;/* 马达驱动的参数 1,2是对右边马达,phase是初始相位,duty是占空比,都得/period enable是对于两个端口的使能*/unsigned long phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000;unsigned long duty1=0x0000, duty2=0x1000, duty3=0x0000, duty4=0x0000;unsigned long period=0x186A,enable=0x3;/* 封装四个方向函数 up和down在for循环十次后基本能前进后退..调整了一定参数 避障中left和right函数先后退一步然后前进(也是一个for(10)) 跟踪中的直接左右拐就行..for(5)*/void up()&#123; phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x0000, duty2=0x1000, duty3=0x0000, duty4=0x1000; period=0x186A,enable=0x3; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); usleep(8000);&#125;void down()&#123; phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x1000, duty2=0x0000, duty3=0x1000, duty4=0x0000; period=0x186A,enable=0x3; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); usleep(20000);&#125;#ifdef task1void le()&#123; down(); phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x0000, duty2=0x1000, duty3=0x1000, duty4=0x0000; period=0x186A,enable=0x3; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); usleep(5000);&#125;void ri()&#123; down(); phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x1000, duty2=0x0000, duty3=0x0000, duty4=0x1000; period=0x186A,enable=0x3; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); usleep(5000);&#125;#elsevoid le()&#123; phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x0000, duty2=0x1000, duty3=0x1000, duty4=0x0000; period=0x186A,enable=0x3; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); usleep(5000);&#125;void ri()&#123; phase1=0x000, phase2=0x000, phase3=0x000, phase4=0x000; duty1=0x1000, duty2=0x0000, duty3=0x0000, duty4=0x1000; period=0x186A,enable=0x3; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); usleep(5000);&#125;#endif//避障中查询距离是否过近int ck(unsigned int dis)&#123; //if(dis &gt; 2900000) return 0; if(dis &lt; 200000) return 0; return 1;&#125;//如果已经超过范围int ck1(int dis)&#123; if(dis &gt; 300000 &amp;&amp; dis &lt; 2900000) return 1; return 0;&#125;int main()&#123; printf("HELLO WORLD\n");//hello world DEBUG大法好 nIRQ_Initial();//中断初始化函数 //默认马达初始化为0 motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); //PID积分参数 int tot = 0,tot1 = 0; /* 跟踪参数 第一个是最远有效距离66.6666cm 第二个是跟踪距离 第三个是后退距离 */ int meter = 666666; int meter02 = 200000; int meter03 = 100000; int p; // cycle //pid系数 double k = 0.3 ,j = 0.05,d = 0; //这里是先调了一个直线的PID,然后转化成有角度后改的一个参量 int clk11; //pace while(1)&#123;#ifdef task3 //光敏测距 ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数 int clk = light(NEW_ULTRASOUND0_BASE,0xa0) ; printf("1 =&gt; %d.%dm\t", clk ); usleep(10000); int clk1 = light(NEW_ULTRASOUND1_BASE,0xa0) ; printf("2 =&gt; %d.%dm\t", clk1 ); usleep(10000); int clk2 = light(NEW_ULTRASOUND2_BASE,0xa0) ; printf("3 =&gt; %d.%dm\n", clk2 ); usleep(10000); #define run for(p = 0;p &lt; 5;p++) //选取光最强的方向 if (clk1 &gt;= clk &amp;&amp; clk1 &gt;= clk2) &#123; clk11 = clk1; &#125;//don' rotate else if(clk &gt;= clk1 &amp;&amp; clk &gt;= clk2) &#123; clk11 = clk; run le(); &#125;//left rotate else if(clk2 &gt;= clk &amp;&amp; clk2 &gt;= clk1) &#123; clk11 = clk2; run ri(); &#125;//right rotate //go go go if(clk11 &lt; 200 )//光太弱停止..参数应该适当调大的.. &#123; tot = tot1 = 0; duty1=0x0000, duty2=0x0000; duty3=0x0000, duty4=0x0000; &#125; else//PID向前跑 &#123; printf("up\n"); d = clk11 ; duty1=0x0000, duty2=0x1000; duty3=0x0000, duty4=0x1000; tot += d; tot1 = 0; &#125; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); int rtime = (int)(100 * d );//这里乘了一个d之后记得强制转换,double有毒 if(rtime &lt;= 0) rtime = 0;//小于零有毒..这两个有可能保持后退状态 usleep(rtime);#endif#ifdef task21 //测试只能前进的跟踪 ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数 int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ; printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000); usleep(10000); int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ; printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000); usleep(10000); int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ; printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000); usleep(10000);#define run for(p = 0;p &lt; 5;p++) if (clk1 &lt;= clk &amp;&amp; clk1 &lt;= clk2) &#123; clk11 = clk1; &#125;//don' rotate else if(clk &lt;= clk1 &amp;&amp; clk &lt;= clk2) &#123; clk11 = clk; run le(); &#125;//left rotate else if(clk2 &lt;= clk &amp;&amp; clk2 &lt;= clk1) &#123; clk11 = clk2; run ri(); &#125;//right rotate //go go go if(clk11 &gt; meter ) &#123; tot = 0; duty1=0x0000, duty2=0x0000; duty3=0x0000, duty4=0x0000; &#125; else if(clk11 &gt; meter02) &#123; printf("up\n"); d = clk11 - meter02; duty1=0x0000, duty2=0x1000; duty3=0x0000, duty4=0x1000; tot += d; tot1 = 0; &#125; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); int rtime = (int)(d * k + tot * j ); if(rtime &lt;= 0) rtime = 0; usleep(rtime);#endif //get the distance#ifdef task2 //测试跟踪 if(a) &#123; ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数 //用前文自己写的3m内测速函数 int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ; printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000); usleep(10000);//记得usleep,因为每个测距有个时间,不然很容易死循环.. int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ; printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000); usleep(10000); int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ; printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000); usleep(10000); #define run for(p = 0;p &lt; 5;p++)//啊这个只是懒得写.... //选取距离最小的方向 if (clk1 &lt;= clk &amp;&amp; clk1 &lt;= clk2) &#123; clk11 = clk1; &#125;//don' rotate else if(clk &lt;= clk1 &amp;&amp; clk &lt;= clk2) &#123; clk11 = clk; run le(); &#125;//left rotate else if(clk2 &lt;= clk &amp;&amp; clk2 &lt;= clk1) &#123; clk11 = clk2; run ri(); &#125;//right rotate //go go go if(clk11 &gt; meter || tot1)//保证只后退一步....(这个是一开始一直后退的修复) &#123; tot = tot1 = 0; duty1=0x0000, duty2=0x0000; duty3=0x0000, duty4=0x0000; &#125; else if( clk11 &lt; meter03)//后退 &#123; printf("down\n"); d = meter03 - clk11; duty1=0x1000, duty2=0x0000; duty3=0x1000, duty4=0x0000; tot1 += d; tot = 0; &#125; else if(clk11 &gt; meter02)//前进,PID中P,I记录 &#123; printf("up\n"); d = clk11 - meter02; duty1=0x0000, duty2=0x1000; duty3=0x0000, duty4=0x1000; tot += d; tot1 = 0; &#125; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); int rtime = (int)(d * k + (tot + tot1) * j );//同上 if(rtime &lt;= 0) rtime = 0; usleep(rtime); &#125; else &#123;//只能前进,相对好控制一些 ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数 int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ; printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000); usleep(10000); int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ; printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000); usleep(10000); int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ; printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000); usleep(10000); #define run for(p = 0;p &lt; 5;p++) if (clk1 &lt;= clk &amp;&amp; clk1 &lt;= clk2) &#123; clk11 = clk1; &#125;//don' rotate else if(clk &lt;= clk1 &amp;&amp; clk &lt;= clk2) &#123; clk11 = clk; run le(); &#125;//left rotate else if(clk2 &lt;= clk &amp;&amp; clk2 &lt;= clk1) &#123; clk11 = clk2; run ri(); &#125;//right rotate //go go go if(clk11 &gt; meter ) &#123; tot = 0; duty1=0x0000, duty2=0x0000; duty3=0x0000, duty4=0x0000; &#125; else if(clk11 &gt; meter02) &#123; printf("up\n"); d = clk11 - meter02; duty1=0x0000, duty2=0x1000; duty3=0x0000, duty4=0x1000; tot += d; tot1 = 0; &#125; motor_setting(phase1,duty1,phase2,duty2,period,enable); motor_setting1(phase3,duty3,phase4,duty4,period,enable); int rtime = (int)(d * k + tot * j ); if(rtime &lt;= 0) rtime = 0; usleep(rtime); &#125;#endif#ifdef task1 // hide somethingelse#define run for(p = 0;p &lt; 10;p++) ultrasound_init(NEW_ULTRASOUND0_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND1_BASE);//重置测位函数 ultrasound_init(NEW_ULTRASOUND2_BASE);//重置测位函数 int clk = light(NEW_ULTRASOUND0_BASE,0x1e)*170 ; printf("1 =&gt; %d.%dm\t", clk / 1000000 , clk % 1000000); usleep(10000); int clk1 = light(NEW_ULTRASOUND1_BASE,0x1e)*170 ; printf("2 =&gt; %d.%dm\t", clk1 / 1000000 , clk1 % 1000000); usleep(10000); int clk2 = light(NEW_ULTRASOUND2_BASE,0x1e)*170 ; printf("3 =&gt; %d.%dm\n", clk2 / 1000000 , clk2 % 1000000); usleep(10000); //暴力枚举大法好= =(可惜忘了拍xiaoyi的列表...) //每次做一件事就行..因为循环过来可以继续下一个任务. if(ck(clk) &amp;&amp; ck(clk1) &amp;&amp; ck(clk2) ) &#123; run up(); &#125; else if(ck(clk) &amp;&amp; ck(clk1) &amp;&amp; !ck(clk2)) &#123; run le(); &#125; else if(ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; ck(clk2)) &#123; run down(); run ri(); &#125; else if(ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; !ck(clk2)) &#123; run le(); &#125; else if(!ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; !ck(clk2)) &#123; run down(); &#125; else if(!ck(clk) &amp;&amp; !ck(clk1) &amp;&amp; ck(clk2)) &#123; run ri(); &#125; else if(!ck(clk) &amp;&amp; ck(clk1) &amp;&amp; !ck(clk2)) &#123; run down(); run ri(); &#125; else if(!ck(clk) &amp;&amp; ck(clk1) &amp;&amp; ck(clk2)) &#123; run ri(); &#125; printf("%d\t %d\t %d\t %d\n",duty1,duty2,duty3,duty4);#endif &#125; return 0;&#125;void motor_setting(unsigned long phase1, unsigned long duty1, unsigned long phase2, unsigned long duty2, unsigned long period,unsigned long enable)&#123; unsigned long * pwm_en= (unsigned long *)PWM_EN; unsigned long * pwm_period=(unsigned long *)PWM_PERIOD; unsigned long * pwm_phase1=(unsigned long *)PWM_PHASE1; unsigned long * pwm_phase2=(unsigned long *)PWM_PHASE2; unsigned long * pwm_duty1=(unsigned long *)PWM_DUTY1; unsigned long * pwm_duty2=(unsigned long *)PWM_DUTY2; * pwm_en=enable; * pwm_period=period; * pwm_phase1=phase1; * pwm_phase2=phase2; * pwm_duty1=duty1; * pwm_duty2=duty2;&#125;void motor_setting1(unsigned long phase1, unsigned long duty1, unsigned long phase2, unsigned long duty2, unsigned long period,unsigned long enable)&#123; unsigned long * pwm_en= (unsigned long *)PWM_EN1; unsigned long * pwm_period=(unsigned long *)PWM_PERIOD1; unsigned long * pwm_phase1=(unsigned long *)PWM_PHASE11; unsigned long * pwm_phase2=(unsigned long *)PWM_PHASE21; unsigned long * pwm_duty1=(unsigned long *)PWM_DUTY11; unsigned long * pwm_duty2=(unsigned long *)PWM_DUTY21; * pwm_en=enable; * pwm_period=period; * pwm_phase1=phase1; * pwm_phase2=phase2; * pwm_duty1=duty1; * pwm_duty2=duty2;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GoodBye Big Algorithm Waterer]]></title>
      <url>http://renld.github.io/2016/07/03/Algor-Water/</url>
      <content type="html"><![CDATA[有些东西,写下来或许才能放下 或才能重新拾起吧. 一年匆匆入此坑 几经辉煌几近红 时去未能入校队 落得孤生水题多 暑假看紫书白书算导来专题训练一下,弥补4+2的些许遗憾. 啊算导啊.那应该是我们算法界的圣经了. 许多人口中的渲染.似乎引起了对它的肃穆. 上了大学之后,才知道水题是那么的重要.比如有些学科好好刷掉一些题库之后,就很容易博得绩点满堂.以致于降低了大学绩点的吸引力.昨天和学妹吹水的时候.还在吹牛需要竞赛来维持一点智商.”吆喝”了一年的算法竞赛之路,似乎也在今天有了一个新的转角.4+2莫大的打击让我玩了几天html游戏设计(&lt;&lt;网页游戏开发秘笈&gt;&gt;,这是一本一章一个引擎教学的神书…..)然后今天水了一盘计蒜之道的复赛.看起来赚了一件衣服.于是又有点像记录一些东西,勉励之后的方向. 啊水题真的很重要. 水题上百,手速不慢.上学期最开始的时候是郭老师上台宣讲”ACM算法竞赛”,抑或是晓铭老师说了一句”打的好可以去东校参加比赛”.当初就特别真诚的抱着去东校可以报销车费的美好欲望报名了ACM中珠集训队,当时还特别好奇这玩意为啥要宣传,福利挺棒的啊. 厚着老脸在上面一堆省赛一等奖的同学下面写上了自己的名字,每周二晚上与东校那边一起刷vjudge的SYSU系列.刘老师还一人送了一本书,我的是那本黑书.&lt;&lt;算法艺术与信息学竞赛&gt;&gt;书是好书.但是对于刚刚接触这方面的我而言,无异于葵花宝典.其实那一段时间的vjudge提高并不是很明显,因为跟着大腿的方向,并没有补题的习惯.而在算法讨论群里面的那些同学讨论着动归或数据结构,又想到一个TA对我说的话 你最近还是先看一些容易的算法吧,动归以后再搞 于是就没有补题的欲望,而对于那些计算几何之类”看起来听得懂”的题,就更没有补题的欲望了.这个不好的习惯囊括了之后的一次次短码之美月赛,考试等等.莫名自大的可怕,还是难以想象. 于是在短码之美的打击下,(同时也是在知乎)的安利下,翻开了紫书.&lt;&lt;算法竞赛入门经典(第二版)&gt;&gt;,水了两三章之后这本书特别够意思的直接来region题,向TA问了几道题后,王芮浩师兄建议我先去看它的第一版.于是我转战第一版.其实更多的是看书,书看完了,UVA也才刷掉几道搜索的水题. 那个时候真的很拼啊.刷UVA的题动不动就四五个小时过去了.因为那儿的英文挺坑的,看过去少说一个小时过去了.而后理解题意之后宛如智障的瞎打一顿码,而后再去努力理解题解.最后看到一篇博客的一句话深有感触看题解是一个相对的事,如果实在很长时间做不出来,那么无妨一看(把这句或许得辩证的理解,但是我往往被坑去太多时间,以致于”事倍功半”). 当时特别励志的用这句话鼓舞自己 “刷题不过百,不是人傻就是懒” 第一个学期看着题解在UVA上敲了百题后就差不多到期末了.自大情绪又体现出来,于是水题很快很快(真的很快…)的刷完后,就被两道算法题卡住木讷到最后结束.不过也验证了这个小标题水题过百,手速不慢,然而由于vjudge里面过题太少.便没有赢得公费旅游的资格.但是这个阶段得到的最大教训却是另外一个. 因为装逼的需求.于是想要多学一些”算法知识”,于是从网上找了很多很多资料,买了良莠不齐的各种算法书,比如清华大学出版社的&lt;&lt;算法设计与分析&gt;&gt;教材.发现自己是多么稚嫩之外似乎大量的时间一无所获反而盲目满足.甚至有些书都未翻开过.不过最为可惜的莫过于在英语课和思修课上”学”算法,其实也不过看几道水题而已,反而糟蹋了老师的精心准备,愧对老师. 高中起点,扬起新帆寒假尝试了另外几条路之后就觉得USACO(美国高中的训练OJ)是一个不错的选择.有趣的一件事是上面总是CHI(中国)ip比美国多,于是其实这个学期刷题基本都在那上面,见证了一次次把自己以前刷的题归为水题的过程.略为可惜的是之后对于整理笔记的思考不足以体现其价值.而且到写这篇文章的时候也卡在了一道很难写的长程序上面. 开始写博客了之后记录也增多.相比上个学期,由于3月份开始比赛纷至沓来,这个学期其实更多的是去做题了.然而似乎算上比赛过的题也就是百来道,不过这些题的质量相对就高了一些,并不是盲目的模拟(虽然也很多题想了很久没想到算法..模拟过了的)刚开学的时候看(水)了数据结构与算法分析.它更大的用处在于解除我对很多”高级名词”的畏惧. &lt;&lt;数据结构与算法分析(C语言描述)&gt;&gt; 然而在4+2第一场赛后讨论中,被梓华提及的红黑树,以及他写的二叉+桶排给惊艳.于是明白了另一个道理 “没敲过代码的看书过程,意义实在有限” 三月份开始就是各种各样的比赛了,说实话就是一次又一次被惊艳.先是校赛预选赛,脑洞一开用hash优化了一个map的查询,(然而那时候还宣称map是hash结果天真的我..)给队伍贡献了一题.而后百度之星在初赛由于只过了水(相对而言)题于是无缘(拿)复(衣)赛(服),再然后省赛/校赛见识了脑洞对于算法的讲究.当时打浙江省赛木洪对于题目的直觉之间经验了我,特别是后来省赛两位队友脑洞强推公式简直可怕.于是那时候开始努力提高自己的脑洞水平.于是在编程之美里面很快的刷掉了两道脑洞题,当然不能掩饰被hack掉的事实.期末考试后便是4+2校队选拔赛.借了两本4+2的题解..简直打开了一个新的世界…….于是最开始的预期是很悲观的四场打铁,但是最后平均一场一题,也算不上过多遗憾,只能怪自己思维和视野的局限.再然后就是今天的计蒜之道复赛,认真刷好水题的我以倒数第三的位置进了复赛.顺便以倒数第三的拿衣服位置拿了衣服.. 所以话说回来..水题还是很重要的.不过想要更上一层楼,得有更大的思考了. 安利“别人口中”的水题, 建议搜索关键词有: 模拟, 模板题, ACM数学题 &lt;&lt;啊哈!算法&gt;&gt;这本书应该才是真正的算法入门读物,网络上他的博客里面也有他对于基本算法的解释.当时搜排序搜到后就喜欢上了这种”幼儿园式”的教学方法.而且很期待第二版的出版. 建议搜索关键词有: 贪心, 树状数组, 并查集 ,高精度 &lt;&lt;挑战程序设计&gt;&gt;/&lt;&lt;算法竞赛入门经典(第一版)&gt;&gt;/USACO题库 这三个其实才算稍微入门了之后的一些选择,芮浩师兄借了我一本&lt;&lt;挑战程序设计&gt;&gt;,我翻了几页后自己买了一本,然而因为心分三用没有往后再扎实的看下去.&lt;&lt;入门经典&gt;&gt;第一版大概是我唯一看完的一本算法书吧.当时草草看完,因为看不懂的直接跳.现在看来其实也并没有那么难,只是一种莫名的畏惧或陌生吧..USACO题库我刷到最后一章暂停了下来,刷题的一些记录放在了CSDN博客上面.前面三章几乎都是些水题吧.因为重排了之后,后面几章便才开始讲基础的算法模板题.nocow上题解的帮助挺大的.因为简单题可以看到更漂亮的算法,难题可以明白大神的思维方式. 建议搜索关键词有: 网络流, 动态规划, 剪枝 &lt; &lt; ACM国际大学生程序设计竞赛 &gt; &gt; 知识与入门 / 算法与实现 第二本是常用的模板,在第一学期期中机考快速幂的时候知道的.但是这本模板给我最大的体验就是如果没练过,相对坑度比&lt;&lt;算法竞赛入门经典(训练指南)&gt;&gt;要大.另外缺少hash的函数处理模板.其实实际使用中若不是模板题这本书参考价值更多的是看个人,毕竟ACM允许纸质材料后,更多的考察抽象思维能力.&lt;&lt;知识与入门&gt;&gt;便是常见算法的讲解,讲的特别简明精要,优点是可以开拓眼界,缺点是没有证明部分,若没有基础看的会比较虚..相对难一些的比赛想要现学现用也是不大现实.另外其实安利自己从网上收集的模板,在这篇文章里面能找到 建议搜索关键词有: 数据结构, 图论 , 数论 大一结束,我大概也就停留在这个水平吧,之后也不好安利.或许小伙伴你愿意和我一起刷白书呢. 几近一年过去,160的车费补贴也算是实现了最初的梦想,当然离现在的理想还是有些许差距. 希望暑假加油完成专题训练.下学期算法比赛好好表现.不能再靠水题来混日子了. 4+2感想(原4+2题解感想摘录) 伙食很好 讲题详细 难度迷人 补贴超多 公费旅游 五星好评 第一场打铁五个小时一题没有过的感觉还是很不好受的. 晚上思考了很久人生.觉得大一还是努力去见见世面吧. 但是大二的两个队友却都没空参赛了.sigh..真的有一些莫名的绝望. 总结 一段代码写烂一个小时后就得有重写的打算,不要老是”调”评测系统 一个代码超时如果尚有可回忆的方法,那么久一定要坚持复杂度.超时可能是写烂了而不是复杂度太高 对于一个区间的动态维护首先应该想到线段树. 线段树和优先队列的区别. 线段树是每次查询的时候更新,优先队列对于版本信息会较为混淆(不能及时剔除旧版本) 第二场迷之两题一上手看最后一题..写了半小时发现看错题了…….. 但是还算是捡回了昨天的运气XD NIM博弈赢的方式是所有异或为0 统计四堆不如统计两堆.然后枚举后面两堆和前面两堆异或一样就可以了.. BTW.今天晚霞挺美的.生活还是要继续的:) 第三场步入正轨今天来东校比赛..周围都是大腿光环:) 把两个实训队友落在珠海还是内心有一些愧疚的..不过下午看到做出来超级漂亮的板子.简直女神. 过了两题后学了两个小时算法..发现模板这种东西关键时刻还是比较鸡肋的.(顿时为期末模板写烂找好了借口).不过很有趣的是翻到了AC自动机的部分.然后认认真真看了一个小时(并没有看懂)恭喜少豪最后一秒钟提交通过233. 很开心的是郭老师过来说报销车费住宿费.公费旅游名不虚传233 话题步入正轨.这次比赛很难进校队了,但是从一定程度上已经扩宽了我的知识面.比如第三题AC自动机,第二题状态压缩以及第一场里面对于线段树的理解加深.也相对来说超过了最开始看4+2真题时候”可能打铁”的预期.与其说让我暑假放弃对于算法的训练,不如说方向更加明确了一些 最后一场继续打铁心还是很累.. 今天完成第一次把电脑弄崩的成就… 毕竟我还是太嫩了..不过最为可惜的是,看到两个省赛队友都拒绝参赛,那大二的我也不知道会做出什么选择,或许移动大三的课比较水吧.. 不过一题没过的最后一天,看到队友能把小车电焊部分做好,真是超级欣慰和感动 英语题..出题师兄越做越忍不住..不停加注释什么的终于破译了英语之谜 论爆到英语大神重要性 来考考那么weed out是什么意思(微笑)]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DP in Tree]]></title>
      <url>http://renld.github.io/2016/06/25/treeDP/</url>
      <content type="html"><![CDATA[一开始学dfs的时候,觉得那就是递归了. 而后在第一学期期末机考的时候扑街在那道递归题目上, 寒假花了一个上午努力做出来, 兴奋之余并没有意识到其实那道题就有记忆化搜索的意味. 树形DP就是一个dfs+DP的特例,最开始想刷这个是源自于4+2参考书上一道题的完全没有看懂,于是觉得有必要去学一下,找到了下面这篇博客刷题参考然后埋头开刷, 大概期末考试断断续续一个星期, 刷了其中一些比较简单的题, 完全没有达到一开始4+2那题的难度. 东西都写在一个文档里面typora已经处理艰难,所以先将这篇文章发出来(刚刚发现是因为CF那道题的处理上发生了bug,删去了那段之后应该能愉快地继续使用了) 相对概括一些说,它需要找到一个节点和树上其它节点(或者边)之间的关系,然后进行一遍或者两边的搜索. 明天就是4+2了,与大家共勉 yali_漆子超论文笔记ps: 这里只有第一篇的题解. 树的重心 删去后结点最多的树的个数最小 定理: 存在一个点使得分出来的子树的结点个数均不大于N/2 定理二: 如果一颗树中每个点的度&lt;=D 那么存在一条边使得分出来的两颗子树结点个数在$[\frac{N}{D+1},\frac{ND}{D+1}]$ =&gt; D为常数时基于边的分治递归最坏深度为logN 所谓重心，就是删掉此结点后，剩下的结点最多的树结点个数最小。 每次分治，我们首先算出重心，为了计算重心，需要进行两次dfs，第一次把以每个结点为根的子树大小求出来，第二次是从这些结点中找重心其实POJ3107那里有重心的代码. poj 2342 Anniversary party不能选相邻的.记得f[n][1] = max(f[m][0],f[m][1])就可以 poj2196 树上距离每个点最远距离Input file contains multiple test cases 核心思想(三种方法) : 两遍DFS 方法: 记录每棵树根往下最大和第二大,两遍dfs分别更新往下的max和往下的max void dfs(int v,int dep)&#123; vis[v] = dep; for (int i = 0; i &lt; e[v].size(); i++) &#123; int u = e[v][i].to; if (!vis[u]) &#123; dfs(u,dep+1); int nt = dp[u][0] + e[v][i].len; if (nt &gt; dp[v][1]) &#123; dp[v][1] = nt; if (nt &gt; dp[v][0]) &#123; dp[v][1] = dp[v][0]; dp[v][0] = nt; &#125; &#125;//保留最大和第二大的子树最远节点 &#125; &#125;&#125;;void dfs1(int v)&#123; vis[v] = 1; for (int i = 0; i &lt; e[v].size(); i++) &#123; int u = e[v][i].to; if (!vis[u]) &#123; //一个树上最远的节点,要么是两个最远的子树节点,要么是最远兄弟节点+1 if (dp[v][0] == dp[u][0] + e[v][i].len) &#123; dp[u][2] = max(dp[v][2], dp[v][1]) + e[v][i].len; &#125;else dp[u][2] = max(dp[v][2], dp[v][0]) + e[v][i].len; dfs1(u); &#125; &#125;&#125; ​ 方法2 首先任意一次dfs求出树上最长直径的一个端点End,然后以该端点为起点再次dfs求出另一个端点，然后再次以求出的另一个端点为起点dfs,每次做dfs的时候都更新dist[]（dist[u]表示u到树上任意节点的最远距离），可以证明树上任意某个节点到树上任意节点的最远距离的端点一定会是树上直径的两个端点之一。 void dfs(int v,int fa,int len)&#123; if(len &gt; max_len) End = v,max_len = len; for (int i = 0; i &lt; e[v].size(); i++) &#123; int nt = e[v][i].to,w = len + e[v][i].len; if (nt != fa) &#123; dfs(nt, v, w); dp[nt] = max(dp[nt],w); &#125; &#125;&#125;//v是当前节点,len是到现在节点的距离,dp[nt]表示的是现在点最远的子树距离dfs(1,-1,0); //第一遍随意扫一遍,知道一个直径端点dfs(End, -1, 0); //第二遍从一个端点开始扫一遍,知道另一个端点dfs(End, -1, 0); //用另一个端点更新每个点的最远距离(前面两次也有更新) ​ (A了,没注意多重数据)自己不能理解为啥错了(有可能是写崩了)的方法_留在这里 void dfs(int v,int dep)&#123; vis[v] = dep; for (int i = 0; i &lt; e[v].size(); i++) &#123; int u = e[v][i].to; if (!vis[u]) &#123; dfs(u,dep+1); update(dp[v][0],dp[u][0] + e[v][i].len); &#125; &#125;&#125;;//只记录往下的最大值 dp[i][0]void dfs1(int v)&#123; for (int i = 0; i &lt; e[v].size(); i++) &#123; int u = e[v][i].to; if (vis[u] == vis[v] + 1) &#123; int oth = 0; for (int j = 0; j &lt; e[v].size(); j++) &#123; int p = e[v][j].to; if (vis[p] == vis[u] &amp;&amp; p != u) &#123; update(oth, e[v][j].len + dp[p][0]); &#125; &#125; if(v != 1) update(oth, dp[v][1]); dp[u][1] = oth + e[v][i].len; dfs1(u); &#125; &#125;&#125;//然后枚举 dp[i][1] = max(1.父节点向上 2.父到兄弟 + 兄向下) +到父亲距离 ##CF219D 求根集 题目是给一张边有向的树形图。要选出首都的点，首都要都能走到其他点，因此要反转一些边的方向。问可以选哪几个点作为首都，使它们所需反转边的数量最少。 O(n)两遍DFS 将要翻转的边赋值为1,不需要的边赋值为0,就是统计了 一遍向下统计以该节点为根的变化量 一遍向上统计它往上走的变化量 最后求和 void dfs0(int u,int fa)&#123; for(int i=head[u]; i!=-1; i=edge[i].next)&#123; int v=edge[i].v; if(v==fa) continue; dfs0(v,u); d[0][u]+=d[0][v]+edge[i].w; &#125;&#125;//by 题解博客void dfs1(const int &amp;fr,int v)&#123; for (int i = 0; i &lt; e[v].size(); i++) &#123; int u = e[v][i]; if (u != fr) &#123; dp[u][1] = dp[v][1] + dp[v][0] - dp[u][0] + 1; //父节点向上 + 父节点向下 - 当前节点向下 + 当前边反向的差 dfs1(v, u); &#125; &#125; for (int i = 0; i &lt; re[v].size(); i++) &#123; int u = re[v][i]; if (u != fr) &#123; dp[u][1] = dp[v][1] + dp[v][0] - dp[u][0] - 1; dfs1(v, u); &#125; &#125;&#125;//向上DP DP思想: 有向图两边同时展开,看利用情况 POJ1741while(i &lt; j) //经典 &#123; while(dis[i] + dis[j] &gt; k &amp;&amp; i &lt; j) j--; ret += j - i; i++; &#125; 期末附加题 给一棵树,问能不能两两节点配对完 完整代码见另一篇博客 #include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 10000 + 5;vector&lt;int&gt; e[maxn];int paired[maxn];//存储是否配对成功int n,a,b,flag;//个数,两个临时变量,YESinline void dfs(const int pos,const int fa)&#123; if (flag == 0) return;//错误状态 for (int i = 0; i &lt; e[pos].size(); i++) &#123; int nt = e[pos][i]; if (nt != fa) &#123; dfs(nt, pos);//测试下一个配对情况 if (flag == 0) return; &#125; &#125; if (paired[pos] == false) &#123; if (fa &lt; 0 || paired[fa] == 1 ) &#123; flag = 0;//已经被配对,出现错误状态 &#125;else paired[fa] = paired[pos] = 1; &#125;&#125; POJ1155 背包i 最多节点给一颗树,叶节点是客户,其它所有是中转站,求不亏损的情况下的最多客户 第一个树形背包参考 对于每一个节点的子节点向上进行优化 这道题而言,就是每完成一次对于子节点的递归之后就回来优化根节点的状态 状态定义为dp[i][j]表示第i个节点得到j个顾客的时候的最大获益 num数组优化剪枝 防错temp数组(存前) 初始化的时候因为有负数,将 dp[i][0] = 0 dp[i][1] = (i &gt; n + m)?val : -inf (因为后面的是有价值节点) dp[i][oth] = -inf num[i] = 0 关键代码 void dfs(int pos)&#123; for (int i = 0; i &lt; e[pos].size(); i++) &#123; int nt = e[pos][i].t,ct = e[pos][i].w;//下一个节点以及花费 dfs(nt); memcpy(temp, dp[pos], sizeof(dp[pos]));//保存当前的值,防止背包使用更改的值 for (int j = 0; j &lt;= nums[pos] ; j++) &#123;//父节点已有情况 for (int k = 0; k &lt;= nums[nt]; k++) &#123;//子节点已有情况 update(dp[pos][k+j], temp[j] + dp[nt][k] - ct);//背包,看子节点的k个顾客能否优化父节点sum-k=j个的情况 &#125; &#125; nums[pos] += nums[nt];//优化搜索空间,保存当前最多搜索的东西 &#125;&#125; //最后输出 for (int i = m; i&gt;=0; i--) &#123; if (dp[1][i] &gt;= 0) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; HDU 1011_1561 背包ii 取父才取子1011给一颗树,每个节点都有花费和获得 想要拿子节点的东西必须先拿父节点的 1561较难抽象成树,但更好解决 (是1011的一个cost == 1特例) 注意在m=0的时候输出0,不然会挂?== 关键代码分析(1011) void dfs(int pos,const int fa)&#123; //这里dp的状态是,不少于i个的时候能获得的量,那么初始化就是把cost后的都赋值为earn for (int j = bugs[pos]; j &lt;= m; j++) dp[pos][j] = posi[pos];//posi[pos]就是当前节点能获得的量(下面就不用搜以上了) //利用子树进行背包优化 for (int i = 0; i &lt; e[pos].size(); i++) &#123; int nt = e[pos][i]; if(nt == fa) continue; dfs(nt, pos); //从大到小背包,防止重复(因为是往上dp所以这样不会) for (int j = m; j &gt;= bugs[pos]; j--) //父节点花费(bugs[pos],而且已经获得了posi[pos](最开始的赋值..)) //所以不能取到 j - bugs[pos] 以上, for (int k = 1; k &lt;= j - bugs[pos]; k++) update(dp[pos][j],dp[nt][k] + dp[pos][j-k]; &#125;&#125; POJ1974 背包iii给一颗树,求最少删去多少条边能得到大小为p的子树 一开始思路不知道挂在哪里了,三遍dfs把自己搞晕 参考 int dp[maxn][maxn];//以a为根size为b的最小子树删边vector&lt;int&gt;chi[maxn],fa[maxn];/*只遍历一次,因为是一棵树,所以对于每个节点的处理只有一次 1. 初始化,对于每个节点所有size都是不可以到达的,inf 2. size为1是子树本身,0 3. 对于每一个子树节点,有两种选择 a. 割去子树节点,也就是 b == 0 当前 = dp[p][a] + 1; b. 不割去子树,用子树size更新 也就是 b != 0 的时候,用dp[p][a-b] + dp[nt][b]更新dp[p][a] 4. 由于对当前dp没有后效性,所以不需要temp数组 5. 然后最后在dfs外层扫一遍所有的P节点删去数,如果不是根节点,需要+1(因为删上面) 6. 好像发现自己懵逼在哪了......因为它只能保留子树,所以兄弟似乎不影响...往下看就行 */void solve(int p)&#123; fill(dp[p], dp[p] + maxn, inf); dp[p][1] = 0; for (int i = 0; i &lt; chi[p].size(); i++) &#123; int nt = chi[p][i]; solve(nt); for (int a = N; a &gt;= 1; a--) //被更新的size for (int b = 0; b &lt; a; b++) //子树size if (b) update(dp[p][a], dp[p][a-b] + dp[nt][b]); else dp[p][a] = dp[p][a] + 1; &#125;&#125; HDU3586,切断根与叶子最小边权给每一条边边权,求切断根和所有叶子的最小花费 哦对了,所有删去边权的和&lt;m . 为啥DP一开始瞄了一眼别人题解..想了很久都没明白一些人题解里面干嘛要背包…… 然后就直接二分强行做dfs了..WA了几发之后发现弄混淆了两个概念 删去该节点的和 删去该节点的最小边权 于是折腾了一会后发现,只有记忆化搜索才能优化 但是记忆化太麻烦了,不如开一个dp数组 void dfs(int pos,int mp)&#123; if(e[pos].empty()) dp[pos] = inf; for (int i = 0; i &lt; e[pos].size(); i++) &#123; int nt = e[pos][i].to,ct = e[pos][i].ct; dfs(nt, mp); if (ct &gt; mp) &#123; dp[pos] += dp[nt]; &#125;else dp[pos] += min(dp[nt],ct);//当前边权可以与子树边权共同优化 &#125;&#125;//dp[i]是i为根cost 为啥二分二分的原因是,这玩意是一个&lt;m存在性问题,那么符合单调性 while (l &lt;= r) &#123; int mid = l + (r-l)/2; memset(dp, 0, sizeof(dp)); dfs(1, mid); if (dp[1] &lt;= m) &#123; ans = mid; r = mid - 1; &#125;else l = mid + 1; &#125;//对于整数的二分模板. POJ3107 树的重心重心就是使得 (最大的子树) 最小的根 O(n)的算法是假设第一个点为根dfs统计每棵树的子树大小. 然后那个点最大的子树就是$max(n - sub - 1,max(sub))$这道题挺无聊的在于..坑vector/deque,参考网上代码发现,得写邻接表才能避免TLE const int maxn = 50000 + 5;int n,a,b,mt;int cnt[maxn],tot[maxn];struct edge&#123; int to,nt;&#125;e[maxn * 2];int size = 0,head[maxn];int ans[maxn],pos;inline void update(int &amp;a,const int &amp;b)&#123; if(b &gt; a) a = b;&#125;inline void update1(int &amp;a,const int &amp;b)&#123; if(b &lt; a) a = b;&#125;void addEdge(int u,int v)&#123; e[size].to = v; e[size].nt = head[u]; head[u] = size++;&#125;int dfs(const int &amp;p,const int &amp;fa)&#123; tot[p] = 1; for (int i = head[p]; i != -1; i = e[i].nt) &#123; int nt = e[i].to; if(nt == fa) continue; tot[p] += dfs(nt, p); &#125; cnt[p] = n - tot[p]; for (int i = head[p]; i != -1; i = e[i].nt) &#123; int nt = e[i].to; update(cnt[p], tot[nt]); &#125; update1(mt, cnt[p]); return tot[p];&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[EEreview]]></title>
      <url>http://renld.github.io/2016/06/25/EEreview/</url>
      <content type="html"><![CDATA[这大抵是学过第一门,让我觉得大学不那么水的课吧. ​ — 在四级作文里面这般描述 来移动的第一个学期,最直观的感觉是绩点特别容易刷高(第二学期专业4.6),而后课相对较”水”,于是开始盘算转院的想法.因为对于IT人而言,最难受的,莫过于发现自己没有学到很扎实的东西吧.相比软工的模拟卷,我们的卷子总会简单一个层次,相比他们的教学内容,我们也总会显得”现代化”一些,但也相对似乎学到的东西少了那么一些.只能以”反正这些基础知识抓牢最重要”的想法,认可我们院的培养方案. 然而这一想法,是在遇见&lt;&lt;电子与电路技术&gt;&gt;这门课之前. 第一节课保老师就跟我们说,上一届师兄师姐很不争气的在期末考试没有得到漂亮的成绩,问师姐也是”TA努力找分然而还是无可奈何”,直到考试前我也觉得我们院的卷子应该比考前刷过的那几套软院的卷子简单的不可置否心理,然而考卷出来后发现并不如之前所想.这大概是电工带来的一些惊喜吧.毕竟总要有一些东西来拿来”炫耀”XD. 说实在的,这学期电工学的很努力,却显得很费力.周四电工课在一节外教课之后,难免犯困,周五也临近周末,难免有所轻松情绪.每节课与老师有很长时间的眼神交流,依旧会走神.而在电工课上走神的效果,大概可以类比那个”为什么学不好数学,是因为小学上数学课橡皮掉了”的笑话.最重要的是发现,前面几章扫了一遍PPT后,课上走神的那几分钟能补回来.但是最后几章做作业的时候,都是在套公式,”照葫芦画瓢”,终于在最后一章里面的作业上把作业”挂”了. 当时TA特别恳切地写下了这样一段话,我拍照留了下来 平时都很不错,怎么这次这样,是不是自己没有理解清楚? 回去参考同学或PPT的吧. 当时真的面色绯红地对自己有些沮丧.因为真的很努力去学了,却只有事倍功半的结果.(后来检查这章作业是因为莫名其妙的分析错误.)于是时间也快到考试周了,于是开始查漏补缺,但对套了一个月公式的我而言更像是开天辟地.不愿意在死坑在英文里面于是翻开了中文教材,尽管里面有很多细节错误,但是瑕不掩瑜的为我展开了一个新的世界.期末复习的时候每一章中文对应着记录英文笔记,相对”高效”的得到了其中的”奥义”.于是在考试周开始前整理完试卷,准备好了迎接.尽管周四前发现笔记又经历了一遍忘却,但是对于电工的重新学习是功不可没的,想起保老师曾经说的一句话: 电工还是很重要的,不要因为英文而学不好电工. 电子技术的另一方面是电工实验,因为对于高中物理实验”对实验结果与预期符合”的苛求,曾有一些心理阴影.这个学期跟电工实验也算是较上了劲.保老师曾经一句”课前两小时,课中两小时,课后两小时”曾把我们一惊,但是实际我一个学期的电工实验却是基本每次都要重新再来一次实验室完成实验,课后的总结也至少四五个小时.以致于把它称作了”电工project”.当然这样也得到了TA的肯定,期末将我报告收去.也算是一些惊喜.如此”费力”的电工实验中,当仁不让地学会了proteus对电路的模拟,而后对实际实验进行对比分析,学会了matlab/excel对于数据的处理,做出相对漂亮的图像和拟合分析.这是高中顽固的理论所不能及的. 开学写的电工预期文藻很漂亮,而这篇报告是在凌晨四点一个嘈杂环境下写下.但是还想在最后反思一下为什么学的那么”吃力”.(希望能因此收获别人所不能收获的收获吧).尽管我们没有师弟师妹了,但是对于自己的大二的硬件方面学习应该有参考意义. 课前缺乏预习,导致课上”难免的”走神打击是致命性的.而后就”两眼懵逼”地上过一节课.其实大多数时候都是在上课弄清楚了老师到底讲了一些什么,但是不消半个星期忘却的结局,还是挺令人郁闷的.归根结底其实是因为自己没有理解,或者说没有弄清关系式是怎么来的,跟着老师走了一遍,自己就像会推了一般. 仍然习惯于凭借自己智商和搜索引擎解决问题的思维习惯,然而在电子技术上,教材才是王道.教材所对知识点的讲解归纳是搜索引擎所无法媲美的.而这样思维习惯最直接的后果是,看起来学会了,但是并没有构架起真正对于思维的理解.这也是软工和电工之间的区别,软工的直接目的便是直接使用,很多时候搜索引擎能直接高效的解决问题,但是电工是一门专业性极强的学科,很多时候难以凭借”民科”解决问题. 没有正确的使用教材.因为这学期分配给算法的时间较多,于是电工的英文教材看看停停,但是对于外文教材看看停停大抵是大忌.因为很多单词一开始看了后面就忘了,而对于阅读中的”似曾相识”的单词往往会糊弄过去.以致于期末复习前对于整本教材是一知半解. 电工毕竟是一门理工科,而不是通过”套公式”糊弄过去的学科.所以电工其实培养的是一种理性思维,一个较为有逻辑的思维体系.做期末考试题的时候,觉得有一些像高中物理的竞赛题,但是只要”强行” 用KCL, KVL推理,还是可以解决的问题.毕竟理科更多的是对于扎实逻辑思维掌握运用的考察,而不是对于”跳跃思维”,也就是”套公式”记忆力的评判. 这一点不算教训吧.就是对于电工实验以及以后很多的实验课,还是要踏实而且”创新”地去尝试,去做好,就像保老师所说,万一那异常数据,成了以后重大的实验发现呢.其实另一方面我觉得更重要的是,这样的学习下,大概能成为一个理工男,扎实诚恳的精神面貌,或许就是这些扎实科目的练习下,能培养的能力吧. 最后一节实验课,保老师指出”两个10kΩ不一样,你是可以用下面的100Ω的滑动变阻器补偿成一样”的思维方式,毕竟我们上大学,不应该只是走一套套模板,过一场场考试,毕竟我们的方向,不仅是把实验做成功,更是用自己的力量,努力把事情做得更加漂亮.]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[块状链表]]></title>
      <url>http://renld.github.io/2016/06/20/part_list/</url>
      <content type="html"><![CDATA[用途是用$O(\sqrt{n})$的方式线段计算(线段树是二分$O(logN)$) 是不是和莫队很像2333 相当于(数组+链表) 网站part 基本操作： （1）定位：先定位元素所在的链表节点，然后再定位该元素在数组中的位置。 （2）分裂：将某个链表节点分裂成两个节点。 （3）插入：首先定位要插入的位置，然后将所在节点分裂成两个节点，并将数据放到第一个节点的末尾。 如果要插入的是一大块数据，首先要将数据切成多个block（每个block对应一个块状链表的一个节点）并将这些block链起来，然后将它们插入那两个节点之间。 关键点和复杂度分析 该算法的核心是确定链表长度和每个节点的数组长度，以及怎么保证这个长度值？设块状链表中元素总个数为X，链表长度为n，每个节点中数据长度为m，则当m=n=sqrt(X)时，可保证m和n同时最小，此时各种操作的时间复杂度最低。在实际应用时，需维持块状链表的每个节点大小在[sqrt(n)/2, 2*sqrt(n)]，否则，块状链表会退化。维护方法是，适当的时候，对节点进行合并与分裂（维护本身不会使复杂度增加） 论文part 而且块状链表非常好扩展，只要是序列操作，比如：统一赋值，翻转，求和，维护最小值等等，都可以使用块状链表得到的复杂度，而如果将整个块状链表维护成有序的，它甚至可以实现平衡树的一些操作[1]，毕竟平衡树也可以看作是一种维护序列的方法。 又因为块状链表只在每个分块记录一些额外信息，它的空间利用率很高，而同是模拟方法的Splay需要在每个节点上维护全部额外信息，虽然速度比较快，却占用大量内存[2]。 其实，在日常生活中我们经常会用到块状链表：传统的FAT文件系统就是将磁盘扇区分簇，然后用FAT表(FileAllocation Table 文件分配表)来记录每一个簇的状态：是否损坏，是否被使用，如果被使用那么它的下一个簇是哪一个簇。可见，FAT文件系统的思想和块状链表是一致的。 而且因为块状链表空间利用率很高，分块的结构又能很方便的和缓冲区结合使用，Vim[3]也使用了块状链表，在内存的存储和在磁盘上的缓冲都使用了类似块状链表的结构[4]。试想如果用Splay去写一个文本编辑器会是多么复杂而抽象，它又如何方便地利用缓冲区，一旦发生崩溃、断电等意外事件，又如何从磁盘缓冲中重构树结构、恢复数据？ 另外，已经有人在g++的库中写了一个基本的块状链表模板：__gnu_cxx::rope，也就是说，使用C++的同学可以很方便的得到一个现成的块状链表[5]。 [1] 我用块状链表做NOI2006happybirthday，略微比我写的SBT短一些，可以过8个点（第8个点接近时限）。 [2] 利用Splay可以把模拟操作的复杂度降到（其实这也是空间换时间的例子：线段树、Splay维护的额外信息多，空间占用大，但是速度也快），关于Splay的讨论可以参考2007年余江伟的集训队论文《如何解决好动态统计问题》，2004年杨思雨的集训队论文《伸展树的基本操作与应用》。 [3] Vi IMproved，应该算是很有名了吧。 [4] 就像BramMoolenaar所说：A texteditor is used all day by many people; it is worth investing time and effort inmaking it work well. Vim使用的数据结构很复杂，但是原理和块状链表是相似的。 [5] http://www.sgi.com/tech/stl/Rope.html上有一份rope的文档。 例程 4+2 07#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#define maxc 1000000 //数列的最大长度int C; //数列的长度int val[maxc]; //数列中的每个元素struct NODE &#123; //每个元素为链表中的一个节点 int next; //链表的下一节点 int jump; //链表的下sqrt(N)个节点 long long sum; //链表中以这个节点开始的连续sqrt(N)个节点的和&#125;;NODE list[maxc]; //链表的每个节点struct LIST &#123; //连续段 int head; //连续段的起点 int len; //连续段的长度&#125;;int J; //保存sqrt(N)的值LIST l; //整个链表看作一个连续段void init() &#123; //初始化函数 J = sqrt(C); //计算sqrt(N)的值 if (J&lt;1) J=1; //最少为1 int i; for (i=0;i&lt;C;i++)&#123; //初始化链表 //链表的下一元素指针 if(i&lt;C-1) list[i].next=i+1; else list[i].next=-1; //链表的下J元素指针 if(i&lt;=C-J) list[i].jump=i+J; else list[i].jump=-1; list[i].sum = 0; //清空和为0 &#125; long long k; for(i=0,k=0;i&lt;J;i++)k+=val[i]; //计算前J项和 for(i=0;i&lt;C-J;i++)&#123; //计算每个数之后的连续J项和 list[i].sum = k; //从前一个连续J项和，减去第一项，加上最后一项，得到新的连续J项和 k = k - val[i] + val[i+J]; &#125; list[i].sum = k; l.head = 0; //初始连续段的起点 l.len = C; //初始连续段的长段&#125;int getlocate(LIST l, int t) //求连续段的第t个元素的位置&#123; if(t&lt;0 || t&gt;=l.len) return -1; //输入位置不合法 int i; i = l.head; while(t&gt;=J)&#123; //还有超过J个元素 i = list[i].jump; //直接跳过J个元素 t -= J; &#125; while(t)&#123; //不超过J个元素 i = list[i].next; //超过1个元素 t --; &#125; return i; //返加元素所在位置&#125;LIST merge(LIST a, LIST b)&#123; //数列合并 if(a.len==0) return b; //a数列为空时返回b数列 if(b.len==0) return a; //b数列为空时返回a数列 int ha, hb, ia, ib, i,j; i = getlocate(a, a.len-1); //找到a数列最后一个元素 list[i].next = b.head; //指向b数列的第一个元素 LIST re;re.head=a.head, re.len=a.len+b.len; //合并后的数列 if(re.len&lt;J) return re; //数列长度小于J，则不需要改变指针和连续段和 if(a.len&lt;J)&#123; //a的长度小于J，则改变指针要从a的第一个元素开始 ia = 0; //a的第一个元素 ib = J-a.len; //对应的J个元素后所在的位置 &#125; else &#123; //a的长度不小于J ia = a.len - J; //从a的倒数第J个元素开始 ib = 0; //从b的第一个元素开始 &#125; ha = getlocate(a, ia); //求出第一个元素所在位置 hb = getlocate(b, ib); //求出最后一个元素所在位置 long long k; //连续J个元素的和 for(i=k=0,j=ha;i&lt;J;i++,j=list[j].next) k+=val[j]; while(ia&lt;a.len &amp;&amp; ib&lt;=b.len)&#123; //枚举所有需要改变的节点 list[ha].jump = hb; //修改跳过J个元素的指针 list[ha].sum = k; //修改连续J个元素的和 k -= val[ha]; //减去第一个元素 if(hb!=-1) k += val[hb]; //加上最后一个元素 ha = list[ha].next; //第一个元素的下一节点 hb = list[hb].next; //最后一个元素的下一节点 ia++, ib++; //下一个连续J个元素 &#125; return re; //返回合并后的数列&#125;void move(int sa, int sb, int np)&#123; //移动一段连续数列 int leftpartlen; //左边部分的元素个数 if(np&lt;sa)leftpartlen=np+1; //移动段在插入位置的右边 else leftpartlen=np+1-(sb-sa+1);//移动段在插入位置的左边 LIST left, mid, right; //初始段分成三段 left.head = l.head; //左段的起始位置 left.len = sa; //左段的长度 mid.head = getlocate(l, sa); //中段的起始位置 mid.len = sb-sa+1; //中段的长度 right.head = getlocate(l, sb+1);//右段的起始位置 right.len = C-sb-1; //右段的长度 l = merge(left, right); //合并左右段 //在插入位置分成两段 left.head = l.head; //左段起始位置 left.len = leftpartlen; //左段长度 right.head = getlocate(l, leftpartlen);//右段起始位置 right.len = l.len - leftpartlen;//右段长度 l = merge(left, mid); //合并左段和中段 l = merge(l, right); //合并右段&#125;void sum(int sa, int sb)&#123; //求连续段的和 int i,t; long long ans = 0; //初始化和为0 i = getlocate(l,sa); //起始元素位置 t = sb-sa+1; //连续段长度 while(t&gt;=J)&#123; //超过J个元素 ans += list[i].sum; //一次累加连续J个元素的和 i = list[i].jump; //跳过J个元素 t -= J; &#125; while(t)&#123; //不足J个元素 ans += val[i]; //累加一个元素 i = list[i].next; //跳过一个元素 t --; &#125; printf("%I64d\n", ans); //输出答案&#125;int main() &#123; int cs; scanf("%d",&amp;cs); //输入数据组数 while(cs--)&#123; scanf("%d",&amp;C); //输入数列长度 int i,j; for(i=0;i&lt;C;i++)scanf("%d",&amp;val[i]); //输入每个元素 init(); //初始化 int S, sa, sb, np; scanf("%d",&amp;S); //输入操作数 char st[30]; for(i=0;i&lt;S;i++)&#123; scanf("%s",st); if(strcmp(st,"Move")==0)&#123;//如果是移动操作 scanf("%d%d%d",&amp;sa,&amp;sb,&amp;np); sa--,sb--,np--; move(sa,sb,np); //调用移动操作函数 &#125; else if(strcmp(st,"Sum")==0)&#123;//如果是求和操作 scanf("%d%d",&amp;sa,&amp;sb); sa--,sb--; sum(sa,sb); //调用求和操作函数 &#125; &#125; &#125; return 0;&#125; 参考资料 中山大学程序设计竞赛(中山大学内部选拔赛) 真题解(一) 对块状链表的一点研究 苏煜 网上的资料]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SDII_FUN]]></title>
      <url>http://renld.github.io/2016/06/19/sdii/</url>
      <content type="html"><![CDATA[期末三套卷部分题解 sdii 模板 期末 机考附加题(图论算法/贪心) 笔试笔记 期末考试三套模拟卷 12计科T2,9,14,error 09软工T4,T7 10软工T3,T6 记不清题号的笔记 顺便作答疑帖0.0有问题可以在下方留言 12计科T2 Which of the following about constructor is not correct? B) Copy constructor will not be created by the compiler if a default constructor is defined. D) A class has at least two constructors. 参考资料: (B)(又如拷贝构造函数会覆盖默认,认为D也正确) 复杂理论 The Copy Constructor will not be implicitly generated if you have explicitly declared a copy constructor (for class X a constructor taking X, X&amp; or const X&amp; ) there is a member in your class that is not copy-constructible (such as a class with no or inaccessible copy constructor) (C++11) you have explicitly told the compiler to not generate one using A(const A&amp;) = delete; The Default Constuctor will not be implicitly generated if you have explicitly declared any constructor at all There is a member in your class that is not default-constructible (such as a reference, a const object, or a class with no or inaccessible default constructor) (C++11) you have explicitly told the compiler to not generate one using A() = delete; B: 因为定义了一个默认构造,如果不是 taking X, X&amp; or const X&amp; 那么编译器还是会隐式实现 D: 尽管按照上面讲的不能被隐式实现,但还是要求被显式实现 另外这是12年的卷子= = 应该不包括C++11特性 简明题解 : 就是反正compiler会给搞一个default constructor 一个copy constructor T9 With the base class and its inherited class, which of the following statement has a compilation error? A) Base * base = Inherited(); C) Base base = Inherited(); A 对象不能初始化指针 另外 Base * base = &amp;Inherited();也是错的,因为不能把const强转成非const 也就是说类名(参数)这样直接声明的对象是const T14C++中，通过基类的引用或指针调用虚函数时，发生动态绑定。 Error Find 普通对象也可以调用static函数 variable, static function cannot be virtual static function cannot be const 类声明完成后需要加’;’ class Base&#123;&#125;; delete不是new 出来的空间会RE, =0纯虚不能被=false代替 抽象类不能被实例化(在子类里面)不能 声明一个虚基类对象 Base(1) 不能deletereference 不是static 不能在类外 class::fun()调用 add完char[]后最后一位补0 重载了(char *)≠重载(const char *) 09软工(观察代码题) T4虚继承 这道题中是虚继承,所以只生成一次A的拷贝 (下面解析代码来自wiki) 假如类A和类B各自从类X派生（非虚继承且假设类X包含一些数据成员），且类C同时多继承自类A和B，那么C的对象就会拥有两套X的实例数据（可分别独立访问，一般要用适当的消歧义限定符）。但是如果类A与B**各自*虚继承了类X，那么C的对象就只包含一套类X*的实例数据。 class Animal &#123; public: virtual void eat();&#125;;class Mammal : public Animal &#123; public: virtual void breathe();&#125;;class WingedAnimal : public Animal &#123; public: virtual void flap();&#125;;// A bat is a winged mammalclass Bat : public Mammal, public WingedAnimal &#123;&#125;;//爷爷类指针调用Bat b;Animal &amp;mammal = static_cast&lt;Mammal&amp;&gt; (b); Animal &amp;winged = static_cast&lt;WingedAnimal&amp;&gt; (b); 为了正确的调用eat()，还需要相同的可以消歧义的语句：static_cast(bat).eat()或static_cast(bat).eat(). T7注意是每次插入起始位置10软工T3 reference维基百科说的很清楚),大意是reference是一个封装的更加安全(指针派生)的pointer T6sizeof(classname)不包括static大小 电脑没电后的笔记 调用一堆初始化函数后初始化时从右到左 static函数是父类和子类共用的 三金关于01010的博客 主要思想是因为是base指针,它++的步长也就是base的大小 另外Post-increment (++) has higher precedence than dereference (*). When you increment a T*, it moves sizeof(T) bytes.† This is because it doesn’t make sense to move any other value: if I’m pointing at an int that’s 4 bytes in size, for example, what would incrementing less than 4 leave me with? A partial int mixed with some other data: nonsensical. –stackoverflow 软件设计II模板 点击这里下载压缩包 文件说明: 6.11为软设模板,基本能符合类的设计需要 STL学习笔记为下一篇日志的pdf可打印版本,里面是对STL重要容器算法的模板 ACM模板是我花了一定精力从网上收集的很多算法模板,应大家需求共享出来 (不过这样会增加一定的流量费用) sdii/CPP文件夹内有一些函数库的cplusplus主页和软设模板的md源文件,可以自行修改 点击这里进入项目主页愿意为我star的当然欢迎XDD有疑问和建议联系这个邮箱leidar100@gmail.com 期末期末附加题 给一棵树,问能不能两两节点配对完 链接,题号18381,直接主页submit AC的方法 优先队列-镓伟 n是奇数 non是偶数 原来的树如果有一个点连着多于1个1度点 no否则 yes —颂恒 直接bfs..不需要堆优化-诗源 dfs -leida 考试的时候最后三分钟才意识到树形DP… 下面这段代码不一定能过=_=理论AC吧XD(已经AC) #include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 10000 + 5;vector&lt;int&gt; e[maxn];int paired[maxn];//存储是否配对成功int n,a,b,flag;//个数,两个临时变量,YESvoid dfs(const int pos,const int fa)&#123; if (flag == 0) return;//错误状态 for (int i = 0; i &lt; e[pos].size(); i++) &#123; int nt = e[pos][i]; if (nt != fa) &#123; dfs(nt, pos);//测试下一个配对情况 if (flag == 0) return; &#125; &#125; if (paired[pos] == false) &#123; if (fa &lt; 0 || paired[fa] == 1 ) &#123; flag = 0;//已经被配对 &#125;else paired[fa] = paired[pos] = 1; &#125;//没有被子树的节点需要配对&#125;int main()&#123; int T; scanf("%d",&amp;T); while (T--) &#123; scanf("%d",&amp;n); flag = 1; for (int i = 1; i &lt;= n; i++) &#123; e[i].clear(); paired[i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; scanf("%d %d",&amp;a,&amp;b); e[a].push_back(b); e[b].push_back(a); &#125;//加入边 if (n &amp; 1) &#123; flag = 0;//剪枝 &#125; dfs(1, -1);//树 if (flag) &#123; printf("Yes\n"); &#125;else printf("No\n"); &#125; return 0;&#125; 笔试 这次的难度相比上次真的体现出我大移动的光彩(其实也发现了电工理论是要做题,但是软设理论却除了考试外从未做过题的缺憾.) 最后的选择题 交换的是指针,i和j并没有变化 然后这个不是传引用 #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class A&#123;public: int* m;&#125;;void swap(A &amp; a,A &amp; b)&#123; A temp; temp = a; a = b; b = temp;&#125;int main()&#123; int x = 1,y = 2; A a,b; a.m = &amp;x,b.m = &amp;y; swap(a, b); cout &lt;&lt; *a.m &lt;&lt; " " &lt;&lt; *b.m &lt;&lt; endl; cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl; return 0;&#125;//希望考试时候不要弄反顺序了= = ​ vector的erase erase一个迭代器的时候是删除临时副本,迭代器后移 #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec; vec.push_back(1); vec.push_back(2); vec.push_back(2); vec.push_back(3); for (vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); it++) &#123; if (*it == 2) &#123; vec.erase(it); it--; &#125; &#125; for (int i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec[i] &lt;&lt; endl; &#125; return 0;&#125; ​ 异常类的析构顺序 xcode的显示是++--!—(有毒,希望看到这里的小伙伴能run一下) #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class B&#123;public: B()&#123; cout &lt;&lt; "+"; &#125; ~B()&#123; cout &lt;&lt; "-"; &#125;&#125;;void func()&#123; B kk; throw kk;&#125;int main()&#123; try &#123; B k; func(); &#125; catch (...) &#123; cout &lt;&lt; "!" ; &#125; return 0;&#125; 最后题意莫名的: 不要提前交卷!!!!!!否则真·眼瞎还是很可怕的!!!!!!!! 总结: 这次考的并不是很难,virtual还有hint,主要是没有摸索出一套科学的学习方法,而是在用工程的思想去学习,这也无可厚非吧. 另外考完后不要打开软设群,不要刷朋友圈,有毒:) ​ 三金留下的足迹 前面几篇文章中三金都写下了或多或少的一些文字,很是感激 但因为整理缘故只能在renld.duoshuo.com看到.现在记录在下面 因为https的原因有些资源换访问错误建议吧所有连接包括http://...和https://...都改成//...多说居然会吞掉带有代码的评论此评论用户状态为：【一般用户】；ip地址：【58.67.136.214】；用户uid为：【6294806818413609730】6月19日 发表于 期末机考最后一题 Mixed Content: The page at 'https://renld.github.io/2016/06/13/STL-LEARN/#more' was loaded over HTTPS, but requested an insecure script 'http://v3.jiathis.com/code/jia.js?uid=1405949716054953'. This request has been blocked; the content must be served over HTTPS./2016/06/13/STL-LEARN/#more:1 Mixed Content: The page at 'https://renld.github.io/2016/06/13/STL-LEARN/#more' was loaded over HTTPS, but requested an insecure script 'http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js'. This request has been blocked; the content must be served over HTTPS.main.js:1 Uncaught ReferenceError: require is not defined/2016/06/13/STL-LEARN/#more:1 Mixed Content: The page at 'https://renld.github.io/2016/06/13/STL-LEARN/#more' was loaded over HTTPS, but requested an insecure script 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'. This request has been blocked; the content must be served over HTTPS.出错了，github默认支持https，的把那些资源url全都改成自动识别协议吧比如http://a.com或者https://a.com都改成//a.com6月19日 发表于 期末机考最后一题]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[By The Year]]></title>
      <url>http://renld.github.io/2016/06/15/By-the-Year/</url>
      <content type="html"><![CDATA[大一的尾声. 不知少年少女,你们可过的还好吗. 大抵曾经那个诗歌相衬的少年,已经在这一年变了模样. #include &lt;iostream&gt;int main(int argc, const char * argv[]) &#123; std::cout &lt;&lt; "Hello, World!\n"; return 0;&#125; ​ 大抵这是高考过后一个星期,去年这时的少年,应该是最怅然若失的吧.幸好当时还是班长,幸好当时还有很多事情要收拾.看着一摞摞书或是捐给了学弟学妹,或是当做了几十块钱卖给收废品的老妪.也没有什么怅然,选了几本看起来最值得怀念的书留在家中.然而也就留在那了. ​ 高三似乎过得挺有趣的,大抵那时候开始把人生目标设为努力去变成一个有趣的人.好像买了很多很多的书,然后翻的多一些看的少一些吧.这个习惯到大一上学期依旧维持着.高三和邓合租在学校算是一个有趣的point吧.来这边后发现广东的学生都没有租房子的现象.突然想起易老板曾猜测的一句话 雅礼这么好的成绩,或许是补课补出来的 ​ 或许是公立学制之外的努力,才把一所所名校变得这么强大的.然而高三的我终于结束了四年的补习班生涯,混了那么久,耳濡目染之下跟同学讲题也像要板有眼的了.似乎很有趣,也似乎很伤感.到大学之后发现大家一段段精彩的课余生活能力,有的少年会弹吉他,琴弦一拨气质就上来了.于是寒假本来准备学一点琴弦的.但是不知为何作罢.就像大一刚刚开学还跟小航学了一点舞蹈一样,不了了之. ​ 想想最后可能让他失望了吧.高三第二个学期的伊始,他”严肃”地更我说.你要努力考上清华北大啊.我当时也只是笑了一笑.到最后估分640是把理综估到270的水准.然而因为物理的最后一题脑洞开大了一点.老师也似乎一分都没给.数学练了一年的压轴题因为考前情绪的突然激动.一道接着一道的扑街. ​ 上了大学之后不知道为何和别人聊着聊着就会聊回高考.大抵还只记得那是一段金戈岁月.五天前学弟学妹高考,也不知道考得怎样.但是希望他们过完这一站之后,能变得更加成熟地向前追求吧.回忆起当年考作文的时候, 拿起笔写起了高三一年未动过的文言,用时超出了自己的意料,慌张之中还用白话写了一句对仗,试后发现有些追悔莫及.但无论如何,语文救了我一把,把我捧上了中大这个舞台. ​ 出分数前当时和伙伴去四川玩了一圈.那时候开始接触”冒菜”这个名词,开始知道抄手和水饺.开始呼吸一个地方的文化空气.来珠海后,吃了很多冒菜,也去过几次餐馆.味道比那儿清淡太多.就像去国还乡的情怀,离开了楚地之后,才开始炫耀那儿的香辣. ​ ​ 高三暑假的印象,似乎有那么一些重要的人和事.大可组织了别墅party真是辛苦她了.好像当时从高考的碌碌中爬出来,我又陷入了选专业的碌碌.水了很久知乎买了一本书.看着大家你一眼我一语的评论.当时也没有朱彦樵做的YaliUp于是也就大致明白了自己以后不会做什么.又或许是高考后的空虚,觉得哪门专业的事儿多哪门就有趣.似乎现在也算如愿以偿.只记得当时看果壳的时候一句话很动容我,记在这儿 ​ 总之，泼了一大堆凉水，说了一大堆生物专业如何如何悲剧，目的主要是给那些对生物专业充满了不切实际幻想的热血青年当头棒喝。但是，如果你一开始就知道这些还选了生物的话，那么我想你将和我一样永不后悔，和各种瓶瓶罐罐植物动物微生物打交道的乐趣，你试过才知道。May the force be with you，buddy. ​ 所以在志愿咨询会的时候,问老师,会不会被调剂到”生物专业”的志愿.当时只有中大的老师回了我一句,”中大的生物可好了”.不过这也不是当时报中大的理由吧.来中大,来移动其实更多的只是一场邂逅而已.当初甚至不知道中大有四个校区.甚至不知道有珠海.大概这个地名本随着高二的学考地理离我远去了吧.只是画画一般,在北上广各画了一所学校,画画一般,在中大随机圈定了几个专业. 各种落榜或许是机缘巧合 或许是一阵忧伤中的另一次邂逅 ​ 在健身房收到父亲的短信,几天后看到自己志愿落在了中大,被移动录取,发现移动在珠海.然后就匆匆的,开始准备行程,顺便努力去做暑假作业= =毕竟,当年的中大,可是有小学期的呐.与挚友再次一聚,当做给最先去上学的少年的送别宴吧.那次也算是第一次看橘子洲头的烟花,可美了. ​ 中珠,旅游景点一般.深居唐家小镇,每次进程都是半小时以上的公交.对于一些闲适的学院而言,或许倍感无聊吧.然而这一年,一个初入CS行当的少年而言.应该算是充实了罢.当时站在门外时,道听途说的可能只有”C语言”了罢.于是暑假就似乎看了几集java,就像寒假看的Python没有再用过,当然也就忘得比学的还快.所以现在也不急着去学那些高大上的语言.或许也是因为井底之蛙的实现,看不到更大向前的方向吧. ​ 军训而后就开始专业学习的生涯.似乎大一上学期比高三还要忙碌和刻苦,似乎成了古南永口中的”想把大学当做职业技术培训学校大有人在”的人了.军训把C语言看完了之后自信满满的参加了当时的短码之美,立刻被各路OIer们当头棒喝,自那开始发现了原来还有一个名词叫算法.于是买了紫书白书黑书,查了知乎百度谷歌,搜了无数资料下在本地之后,踌躇满志的…刷起了水题.把紫书水题刷的差不多后.和当时的TA师兄聊天,他说 不能老是沉迷在刷水题的快感之中. ​ 所以知道期末考试,都不知道自己当时其实有多水.其中和章鱼,任萌一起参加了新手赛,作为移动大一第一的罚时拿了一个二等奖后,就更加自我膨胀了,于是期末那个星期居然就没碰过代码..期末快速的水完了所有水题之后,就对剩下两道算法题一筹莫展了.于是rk也一直下掉.能留下编程之美的参赛权,大概也是一种幸运吧. ​ 大一上学期的自我膨胀,真是可怕至极.觉得努力了一定要有收获,就为了虚荣而去努力,甚至放下了很多有意思的东西.参加了集训队了之后.发现那些大牛们都没有赛后改题的习惯,居然自己也草草了之.就像跟很多人聊的那样我刷UVA的时候,都是看一个小时题,懵逼一个小时然后再去看别人代码.当时看了别人代码又没有学习下来.跟着大牛一起装逼.以致于事倍功半.大抵是上天眷顾了一下我的运气,最后一次短码之美的月赛,拿了两本书离去,也不算太过遗憾. ​ 那段日子,可真是刻苦啊 每天沉浸在图书馆中,迎接第一缕晨曦与最后一道送别铃声 ​ 大一上学期学院的主要目标大概是想培养我们专业的一种情怀吧.当初不知线代的重要居然一题没有刷就节课了,苏宁大大还给了一个特别漂亮的成绩.单片机玩的时候那可是装逼啊,买了锯子电焊铁各种各样的模块后,各种拍照发朋友圈,“好像真的变成了一个工程师”一样.最后做了一个闹钟出来,似乎还是有一点点遗憾.不过TA给了满分,还是倍感荣幸. ​ 寒假去sicily把lxm老师布置的编程题刷了几十道后,便开始了USACO的路途.不过到了下学期,人就似乎变得更加浮躁.也似乎变得突然有了方向.去YouTube看完了40min学会java,70min学会c++,30min学会java,15min学会html系列,发现这种一个小时学的东西,最多也就两个小时,可以忘掉一干二净.立下flag这学期好好学大英,不过这个flag也是一拖再拖.直到上个星期,聊到一半突然被鼓励了一下下,终于拿起暑假买的四级书.开始刷起了听力. ​ ​ 不过大一下学期和上学期最大的不同大概就是心态了吧. ​ 上学期像是把自己全身心投入算法中区,思修课看算法,大英课看算法.其实也没学到什么真材实料,反而相对而言错过了上学期最为认真的两位老师.遗憾之余这个学期每一节近代史都特别认真的去听沈成飞讲故事,大英也尝试坐在前排,放下手机了. ​ 四月初算是度过了第一个春天.真的,长沙根本体会不到春风十里的舒畅.春风拂面的怡人. ​ 五月因为省赛去了几次广州,看到了回迁之后的一些展望,也和朋友浪了一圈…中大= =. ​ 上学期因为自我膨胀.每节课坐着最后一排.不过大家都知道,做最后一排难免会打开手机.而这学期努力坐在第一排,尽管电工课做第一排和老师保持1/3时间眼神交流还是能走神. ​ 说起电工,保老师可以说是大学到现在为止最为认真的一个老师了吧.也大概让我觉得,第一次开始觉得,或许我也还是需要那种有一点点闲适的心情.他第一节课除了自我介绍,得知他和我爸居然是一个专业毕业的之外,还记得去年师兄师姐三成及格率的难度,于是便立志学好电工 ​ 再而后记得他讲了一些期许.而后便是充实的电工课了.因为前半个学期一直读的英文教材,对于知识点也是磕磕碰碰的仿照例题过去.不过除了理论之外,更有趣的应该是电工实验了吧…而我应该也让TA和实验室老师留下了印象.因为总是需要下周一再来补全漏下的实验部分.而后话很大力气完成实验报告. 同学们的实验,应该课前两个小时的预习,课中做两个小时,课后至少花两个小时整理 ​ 似乎很长的预期,然而对我而言总是要花两三倍,甚至四五倍的时间,才能实现保老师的实验要求.不过上个星期得知自己的实验报告,被选出来存档,也的确有一些小确幸. ​ 四月校赛吧,当时被硕轩和向峰两条大腿拉去,很幸运地又拿了专业年级排名靠前的罚时.然而却因为我提交次数太多,罚时与省赛无缘.但更幸运一些的是被木洪和佳录的队伍拖去省赛开眼界.四月底第一次集训的时候发现,脑洞是有多么的重要,然而之后却和舍友开始”享受了一段人生”,把各种休闲游戏玩了一圈后,省赛也快到了,于是再次出发去广州,和两个超级棒的队友在省赛玩了一天..自那开始思念起了东校的M记 ​ 说起M记大概又想起了期中高数考试前和培楠通宵的夜晚,拖他去KTV唱了很晚之后,贝岗已然爆满,问了几个东校的同学告诉我“M记是你家”…于是我们在那儿看了一集越策越开心和几集老友记..把被KTV拒之门外的零食吃的差不多了之后..就开始在大学城中环游荡了..培楠还顺便讲了一讲孤岛上的鬼故事和抢人案.不过说真的,他上了大学之后,真的变帅了,然后我们溜达到了华工后看了那天的日出.还因为穿着雅礼校服被十一中的妹子认出,打了好多次照面= = ​ 五月中旬戒掉了泡泡堂之类的休闲游戏吧.继续刷起了USACO,从那时候开始我大抵真正的看到了算法大门的一角,看到了所谓的网络流,剪枝.hash,才知道之前的自己是有多么幼稚.前两天放下之前,以一种谜一样的速度刷了几章之后,写题解CSDN的博客也充实了很多.访问量过万后,便开始尝试用更好的框架搭起了这个博客. ​ 觉得前端的东西总是能给人很多很多的成就感,当然要在做出来的前提下.下学期选了HTML后做了一个中珠打砖块,过一阵有时间后探索一下能不能放上这个博客.那天搭了一晚上这个博客因为没备份的修改自动毁了三次后,简直成就感爆棚.(好像又开始自我膨胀了XD).觉得挺有意思,于是从图书馆借了一本游戏开发的书,摆在了书架上. ​ 以前总是羡慕大学有多自由,可以学特别多的知识.其实现在像是越来越功利化了吧,也像古南永所说一个膨胀的灵魂看太多看太快贪心不住蛇吞象,现在也对看起来很棒其实自己兴趣淡然的学科渐渐疏远起来.也不再是高中那个看普通物理学普通化学的少年了,走上了CS这条大道之后,路还是真的很长,但是又像黑夜明灯常亮,总是有很多前行的方向,有很多值得努力的地方. ​ ​ 邂逅过一些OI大神的博客,其中对这段话特别有感触.别人口中最棒的地方,也因为有了选择的余地,可以用道德与理想相较之度量.感慨太深,于是也把这篇日志的题目设为此. ​ 我是2012年5月2日入职的，到今天整整是三个月。这是我首次在产业界的公司实习，与之前在微软亚洲研究院的实习有很大不同。之前在微软做的是「研究」，听起来好像是很厉害的样子，其实有时候做的东西简直是浪费时间。因为我从一开始就清楚，在研究院做的东西只是为了在特定领域有一个突破，至于这个成果会不会造福人类，那可不好说。运气好的话会被微软产品组看中，做成产品，算是为人类做贡献了。大多数时候你的成果还是被打入冷宫，永远无人问津。更普遍的情况是进入了微软的专利库，别人想做成产品都不行，这简直是阻碍人类社会进步了。我在微软亚洲研究院长达十个月的实习给我最大的收获就是让我决定了将来一定不会去读博士。 —byvoid ​ 另外大一的少年,总是会眷念刚过去不久的金戈铁马吧.骄傲的雅礼er,你们可都在自己的地方卓尔不群吧.去年年底做了班节视频快到暑假了,大家不是约好了别墅再聚,球场峥嵘吗XD,任磊达这个学期可是学了足球呢(才不告诉你们就是因为这个就不追求体育绩点了…). ​ 太久没说过话写过字了,上次还是去做那个回答.这次留一句话给还在纠结志愿的学弟学妹们吧 ​ 长得漂亮就来中大 ​]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Notes for STL]]></title>
      <url>http://renld.github.io/2016/06/13/STL-LEARN/</url>
      <content type="html"><![CDATA[C++大学教程第22章. 算法参考cplusplus.com 标准数组可以作为容器,只要把指针当做迭代器就好 容器类型 序列容器 vector deque list 关联容器(重载&lt;运算符,有些需要==) set``multiset 允许重复 map multimap 容器适配器 stack``queue priority_queue 基本操作(记得加括号) 构造,拷贝构造,析构 empty, insert size 运算符重载(大小关系比较) 位置: max_size, begin end rbegin rend erase clear 迭代器 正向 iterator 随机访问p[i]表示和迭代器位置差p个元素的元素 反向 reverse_iterator 对应rbegin和rend istream_iterator&lt;type&gt;和ostream_iterator&lt;type&gt; ostream_iterator&lt;int&gt; output(cout," ");copy(vec.begin(),vec.end(),output) const_iterator 尽量使用前缀++ 重要容器vector insert(pos,num),在原来pos和pos-1之间插入num; 容器必须是非空的,不然front,end没有意义 front,back是引用,begin,back是迭代器 list 对于中间元素的插入删除(对于首尾的使用deque) splice // set some initial values: for (int i=1; i&lt;=4; ++i) mylist1.push_back(i); // mylist1: 1 2 3 4 for (int i=1; i&lt;=3; ++i) mylist2.push_back(i*10); // mylist2: 10 20 30 it = mylist1.begin(); ++it; // points to 2//剪切到第一个迭代器位置(全部) mylist1.splice (it, mylist2); // mylist1: 1 10 20 30 2 3 4 // mylist2 (empty) // "it" still points to 2 (the 5th element)//剪切到第一个迭代器位置(之间) mylist2.splice (mylist2.begin(),mylist1, it); // mylist1: 1 10 20 30 3 4 // mylist2: 2 // "it" is now invalid. it = mylist1.begin(); std::advance(it,3); // "it" points now to 30 mylist1.splice ( mylist1.begin(), mylist1, it, mylist1.end()); // mylist1: 30 3 4 1 10 20 .sort()排序,.unique()排重.merge(ano)和ano依次合并112233… .assign(beg,end);把beg,end连个迭代器之间的赋值给本身 .remove(val)删除所有这个值 关联容器 查询是否包含这个元素 .count(a) == 0 .find(a) == sl.end() 插入 insert(make_pair( ) ) Map[a] = b set相关函数 it=std::set_union (first, first+5, second, second+5, v.begin()); it=std::set_difference (first, first+5, second, second+5, v.begin()); it=std::set_intersection (first, first+5, second, second+5, v.begin()); set_union( setA.begin(), setA.end(), setB.begin(), setB.end(), insert_iterator&lt;set&lt;int&gt;&gt;(ans,ans.begin())); 容器适配器 不支持迭代器 小顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; struct cmp &#123; bool operator() (const node &amp;a, const node &amp;b) &#123; return true; &#125;&#125;;priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; p; STL算法&lt; algorithm&gt;变序算法 copy //std::copy ( myints, myints+7, myvector.begin() );template&lt;class InputIterator, class OutputIterator&gt; OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result)&#123; while (first!=last) &#123; *result = *first; ++result; ++first; &#125; return result;&#125; fill std::fill (myvector.begin(),myvector.begin()+4,5); // myvector: 5 5 5 5 0 0 0 0fill_n(beg,num,val);template &lt;class ForwardIterator, class T&gt; void fill (ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; while (first != last) &#123; *first = val; ++first; &#125;&#125; generate Assigns the value returned by successive calls to gen to the elements in the range [first,last). #include &lt;ctime&gt; // std::time#include &lt;cstdlib&gt; // std::rand, std::srandstd::srand ( unsigned ( std::time(0) ) );int RandomNumber () &#123; return (std::rand()%100); &#125;std::generate (myvector.begin(), myvector.end(), RandomNumber);template &lt;class ForwardIterator, class Generator&gt;void generate ( ForwardIterator first, ForwardIterator last, Generator gen) &#123; while (first != last) &#123; *first = gen(); ++first; &#125;&#125; partion 用一个函数把容器分成两个部分 // partition algorithm example #include &lt;iostream&gt; // std::cout #include &lt;algorithm&gt; // std::partition #include &lt;vector&gt; // std::vector bool IsOdd (int i) &#123; return (i%2)==1; &#125; int main () &#123; std::vector&lt;int&gt; myvector; // set some values: for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9 std::vector&lt;int&gt;::iterator bound; bound = std::partition (myvector.begin(), myvector.end(), IsOdd); // print out content: std::cout &lt;&lt; "odd elements:"; for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=bound; ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "even elements:"; for (std::vector&lt;int&gt;::iterator it=bound; it!=myvector.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0; &#125;template &lt;class BidirectionalIterator, class UnaryPredicate&gt;BidirectionalIterator partition (BidirectionalIterator first, BidirectionalIterator last, UnaryPredicate pred)&#123; while (first!=last) &#123; while (pred(*first)) &#123; ++first; if (first==last) return first; &#125; do &#123; --last; if (first==last) return first; &#125; while (!pred(*last)); swap (*first,*last); ++first; &#125; return first;&#125; random_shuffle // using built-in random generator: std::random_shuffle ( myvector.begin(), myvector.end() );// using myrandom:// random generator function:int myrandom (int i) &#123; return std::rand()%i;&#125;std::random_shuffle ( myvector.begin(), myvector.end(), myrandom);template &lt;class RandomAccessIterator, class RandomNumberGenerator&gt;void random_shuffle (RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator&amp; gen)&#123; iterator_traits&lt;RandomAccessIterator&gt;::difference_type i, n; n = (last-first); for (i=n-1; i&gt;0; --i) &#123; swap (first[i],first[gen(i+1)]); &#125;&#125; replace(注意这里和string不太一样) int myints[] = &#123; 10, 20, 30, 30, 20, 10, 10, 20 &#125;; std::vector&lt;int&gt; myvector (myints, myints+8); // 10 20 30 30 20 10 10 20 std::replace (myvector.begin(), myvector.end(), 20, 99); // 10 99 30 30 99 10 10 99 template &lt;class ForwardIterator, class T&gt; void replace (ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value) &#123; while (first!=last) &#123; if (*first == old_value) *first=new_value; ++first; &#125; &#125; //replace_if template &lt; class ForwardIterator, class UnaryPredicate, class T &gt; void replace_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value) &#123; while (first!=last) &#123; if (pred(*first)) *first=new_value; ++first; &#125; &#125; reverse for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9std::reverse(myvector.begin(),myvector.end()); // 9 8 7 6 5 4 3 2 1template &lt;class BidirectionalIterator&gt; void reverse (BidirectionalIterator first, BidirectionalIterator last)&#123; while ((first!=last)&amp;&amp;(first!=--last)) &#123; std::iter_swap (first,last); ++first; &#125;&#125; rotate按照第二个参数位置旋转 for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9std::rotate(myvector.begin(),myvector.begin()+3,myvector.end()); // 4 5 6 7 8 9 1 2 3template &lt;class ForwardIterator&gt; void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last)&#123; ForwardIterator next = middle; while (first!=next) &#123; swap (*first++,*next++); if (next==last) next=middle; else if (first==middle) middle=next; &#125;&#125; swap_ranges std::vector&lt;int&gt; foo (5,10); // foo: 10 10 10 10 10std::vector&lt;int&gt; bar (5,33); // bar: 33 33 33 33 33std::swap_ranges(foo.begin()+1, foo.end()-1, bar.begin());foo contains: 10 33 33 33 10bar contains: 10 10 10 33 33 template&lt;class ForwardIterator1, class ForwardIterator2&gt; ForwardIterator2 swap_ranges ( ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2)&#123; while (first1!=last1) &#123; swap (*first1, *first2); ++first1; ++first2; &#125; return first2;&#125; transform 转换到另一个数组内 for (int i=1; i&lt;6; i++)foo.push_back (i*10); // foo: 10 20 30 40 50bar.resize(foo.size()); // allocate spacestd::transform (foo.begin(), foo.end(), bar.begin(), op_increase); // bar: 11 21 31 41 51 // std::plus adds together its two arguments:std::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(), std::plus&lt;int&gt;()); // foo: 21 41 61 81 101 unique bool myfunction (int i, int j) &#123; return (i==j);&#125;int myints[] = &#123;10,20,20,20,30,30,20,20,10&#125;; // 10 20 20 20 30 30 20 20 10std::vector&lt;int&gt; myvector (myints,myints+9); // using default comparison: std::vector&lt;int&gt;::iterator it; it = std::unique (myvector.begin(), myvector.end()); // 10 20 30 20 10 ? ? ? ? // myvector.resize( std::distance(myvector.begin(),it) ); // 10 20 30 20 10// using predicate comparison:std::unique (myvector.begin(), myvector.end(), myfunction); // (no changes) 非变序算法 count int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; // 8 elementsint mycount = std::count (myints, myints+8, 10);std::cout &lt;&lt; "10 appears " &lt;&lt; mycount &lt;&lt; " times.\n";//3 find int myints[] = &#123; 10, 20, 30, 40 &#125;;int * p;p = std::find (myints, myints+4, 30);if (p != myints+4)//no find template&lt;class InputIterator, class T&gt; InputIterator find (InputIterator first, InputIterator last, const T&amp; val)&#123; while (first!=last) &#123; if (*first==val) return first; ++first; &#125; return last;&#125; search Searches the range [first1,last1) for the first occurrence of the sequence defined by [first2,last2), and returns an iterator to its first element, or last1 if no occurrences are found. std::vector&lt;int&gt; haystack; // set some values: haystack: 10 20 30 40 50 60 70 80 90 for (int i=1; i&lt;10; i++) haystack.push_back(i*10); // using default comparison: int needle1[] = &#123;40,50,60,70&#125;; std::vector&lt;int&gt;::iterator it; it = std::search (haystack.begin(), haystack.end(), needle1, needle1+4); if (it!=haystack.end()) std::cout &lt;&lt; "needle1 found at position " &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n'; else std::cout &lt;&lt; "needle1 not found\n";template&lt;class ForwardIterator1, class ForwardIterator2&gt;ForwardIterator1 search ( ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)&#123; if (first2==last2) return first1; // specified in C++11 while (first1!=last1) &#123; ForwardIterator1 it1 = first1; ForwardIterator2 it2 = first2; while (*it1==*it2) &#123; // or: while (pred(*it1,*it2)) for version 2 ++it1; ++it2; if (it2==last2) return first1; if (it1==last1) return last1; &#125; ++first1; &#125; return last1;&#125; equal template &lt;class InputIterator1, class InputIterator2&gt; bool equal ( InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 ) &#123; while (first1!=last1) &#123; if (!(*first1 == *first2)) // or: if (!pred(*first1,*first2)), for version 2 return false; ++first1; ++first2; &#125; return true; &#125; mismatch Compares the elements in the range [first1,last1) with those in the range beginning at first2, and returns the first element of both sequences that does not match. template &lt;class InputIterator1, class InputIterator2&gt; pair&lt;InputIterator1, InputIterator2&gt; mismatch (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 )&#123; while ( (first1!=last1) &amp;&amp; (*first1==*first2) ) // or: pred(*first1,*first2), for version 2 &#123; ++first1; ++first2; &#125; return std::make_pair(first1,first2);&#125; lexicographical_compare std::cout &lt;&lt; std::lexicographical_compare(foo,foo+5,bar,bar+9);bool mycomp (char c1, char c2)&#123; return std::tolower(c1)&lt;std::tolower(c2); &#125;std::cout &lt;&lt; std::lexicographical_compare(foo,foo+5,bar,bar+9,mycomp); template &lt;class InputIterator1, class InputIterator2&gt; bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)&#123; while (first1!=last1) &#123; if (first2==last2 || *first2&lt;*first1) return false; else if (*first1&lt;*first2) return true; ++first1; ++first2; &#125; return (first2!=last2);&#125; lower_bound找到一个已排序序列中第一个可能插入不变序位置 // lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vectorint main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); // 3 ^ up= std::upper_bound (v.begin(), v.end(), 20); // 6 ^ std::cout &lt;&lt; "lower_bound at position " &lt;&lt; (low- v.begin()) &lt;&lt; '\n'; std::cout &lt;&lt; "upper_bound at position " &lt;&lt; (up - v.begin()) &lt;&lt; '\n'; return 0;&#125; equal_range std::pair&lt;std::vector&lt;int&gt;::iterator,std::vector&lt;int&gt;::iterator&gt; bounds; // using default comparison: std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 bounds=std::equal_range (v.begin(), v.end(), 20); // ^ // using "mygreater" as comp: std::sort (v.begin(), v.end(), mygreater); // 30 30 20 20 20 10 10 10 bounds=std::equal_range (v.begin(), v.end(), 20, mygreater); // ^ for_each sort min max]]></content>
    </entry>
    
  
  
</search>